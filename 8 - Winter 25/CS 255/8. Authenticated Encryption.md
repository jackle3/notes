# Recap
## CRHF
* A collision-resistant hash is $H: M \to T$ such that it's hard to find $m_0 \neq m_1$ s.t. $H(m_0) = H(m_1)$
* Constructions:
	* SHA2 uses the Davies-Meyer compression function, which is plugged into Merkle-Damgard to build a CRHF for large messages
## Birthday Attack
* Given a CRHF $H$, an attacker can find a collision in time $O(2^{\ell/2})$ where $\ell$ is the output length in bits
* To be secure, the output of the hash function should be at least 256 bits, meaning a collision can be found in time $O(2^{128})$
## CRHF: Merkle-Damgard
* Given a compression function for small fixed-size blocks (e.g. Davies-Meyer), Merkle-Damgard constructs a CRHF for arbitrary large messages
	* Split message into fixed-size blocks
	* Iteratively apply compression function to each block with previous output
	* Final output is a fixed-size hash regardless of input length

# Keyed Hash Functions
* **Goal:** How to build a PRF from a CRHF $H: M \to T$?
	* Note: this PRF is a MAC because every secure PRF with a large range gives a secure MAC
* How do we create a keyed hash function (PRF) from a CRHF that doesn't have a key?

## Bad Attempt
* Prepend the key to the message and use that as the input to the CRHF
$$
F(k, m) := H(k || m)
$$
* This is insecure because of an *extension attack* on Merkle-Damgard hash functions
	* Given $y=F(k, m)$, an attacker can efficiently compute $y' = F(k, m||x)$ for any $x$.
	* Recall that Merkle-Damgard was just a chain, passing the output of the previous block's compression function as the input to the next block's compression function
	* The attacker can just take $y$, treat it as a chaining variable $c$, compress that with $x$ using the compression function, and then continue the chain
	* This is an existential forgery because the attacker can create a valid MAC for a new message $(m||x)$ that they have never seen before, without knowing the key $k$
![[Pasted image 20250203222828.png]]

## HMAC
* First, take the key $k$ and xor it with an inner pad $\texttt{ipad}$, then concatenate it with $m$. Then compute the hash of this.
* Then take the key $k$ and xor it with an outer pad $\texttt{opad}$, then concatenate it with the hash from the previous step. Then compute the hash of this.
$$
F_{\text{HMAC}}(k, m) := H\Big(k \oplus \texttt{opad} || \underbrace{H(k \oplus \texttt{ipad} || m)}_{32\text{ bytes}}\Big)
$$
* Notes:
	* $\texttt{ipad}$ and $\texttt{opad}$ are fixed values defined in the standard
	* The inner pad does the bulk of the work. The outer pad is very fast, just to prevent extension attacks.
	* Notice that HMAC is pretty much a wrapper around a CRHF (e.g. SHA256). This means if a library provides a CRHF, we can easily construct a MAC and a PRF from it (i.e. HMAC)

* **Theorem**: If the compression function used in the Merkle-Damgard construction (e.g. Davies-Meyer) is a secure PRF, then the HMAC is a secure PRF.

# CRHF for Integrity of Software Packages
* When you try to install a Python library from a repo, what happens?
	* Package itself comes from the repo server
	* There exists a separate integrity server that stores the collision-resistant hashes (e.g. SHA256 checksum) of all the packages in the repo
		* Important: attack can write to repo server but not to the integrity server
	* When you download the package, you compute the hash of the package and compare it to the hash stored on the server