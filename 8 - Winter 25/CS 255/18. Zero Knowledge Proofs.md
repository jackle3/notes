# Recap: the Class NP

- A language $L$ is a subset of strings $\{0, 1\}^*$
- $L$ is in NP if there exists a polynomial-time machine $M$ such that:
  $$
x \in L \iff \exists w \in \{0, 1\}^{*} \quad \text{s.t.} \quad M(x, w) = 1
$$
## Example: Equal Discrete Logs
Let $G$ be a finite cyclic group of prime order $q$
$$
L_\text{EDL} = \{(g, h, g^\alpha, h^\alpha) \in G^4 \mid \alpha \in \mathbb{Z}_q \text{ and } g, h \neq 1\}
$$
This is called equal discrete log because the DLog of the second element base the first element is the same as the DLog of the fourth element base the third element.
1. $\text{DLog}_g(h)$
2. $\text{DLog}_{g^\alpha}(h^\alpha) = \frac{\text{DLog}(h^\alpha)}{\text{DLog}(g^\alpha)} = \frac{\alpha \cdot \text{DLog}(h)}{\alpha \cdot \text{DLog}(g)} = \frac{\text{DLog}(h)}{\text{DLog}(g)} = \text{DLog}_g(h)$

Given a four-tuple, can we prove that it is a member of $L_\text{EDL}$?
* Computing discrete logs is hard. Given a four-tuple, there's no way to tell if it's a member of $L_\text{EDL}$ or not.
* This is exactly what **zero-knowledge proofs** allows us to do.
* In this case, $\alpha \in \mathbb{Z}_q$ is a witness that proves that the four-tuple $(g, h, u, v)$ is a member of $L_\text{EDL}$

# Zero Knowledge Proof System for $L \in NP$
A ZK proof system is a pair of efficient algorithms $(P, V)$ prover and verifier.
* The prover $P$ has access to $x$ and the witness $w$
* The verifier $V$ only has access to $x$ and can interact with the prover
	* At the end, the verifier should be able to say yes or no whether $x \in L$
![](../../attachments/Pasted%20image%2020250317195527.png)

## Properties of ZK
1. **Completeness**: For all $x \in L$ and witnesses $w$, if $M(x, w) = 1$ (meaning $x \in L$), then the output of the interaction between $P$ and $V$ must be "yes" with probability 1.
	* A proof system where the verifier always says "yes" would be complete but not useful
![](../../attachments/Pasted%20image%2020250317195835.png)
2. **Soundness**: For all $x \notin L$ and all witnesses $w$, if $M(x, w) = 0$ (meaning $x \notin L$), then the output of the interaction between $P$ and $V$ must be "yes" with negligible probability.
	* A cheating prover $\hat{P}$ should not be able to convince the verifier that $x \in L$ if $x \notin L$
![](../../attachments/Pasted%20image%2020250317195841.png)
3. **Honest Verifier Zero Knowledge (HVZK)**: The protocol should "reveal nothing" about the witness $w$ other than $x \in L$
	* Let the transcript $T$ be the sequence of messages between $P(x, w)$ and $V(x)$ for a fixed $x, w$
		* This is a **random variable** that changes with each run of the protocol
	* $(P, V)$ is HVZK for $L$ if there exists an efficient simulator $S$ such that for all $x \in L$, the distribution generated by the simulator $\{ S(x) \}$ and the transcript $T$ are computationally indistinguishable
		* The transcript captures everything that the verifier learns from the prover.
		* If the transcript is computationally indistinguishable from the output of the simulator, then the verifier learns nothing from the prover.
	* N.B. to prove that the protocol leaks no information, we showed that everything that the protocol did could have been **generated by a simulator** that has no access to the secret witness $w$
![](../../attachments/Pasted%20image%2020250317200545.png)
![](../../attachments/Pasted%20image%2020250317200550.png)

# Simple Example: Where's Waldo
Suppose the verifier gives the prover a picture with 1000 faces on it, where one of them is Waldo. How does the prover convince the verifier that they know where Waldo is without revealing any information about where Waldo is?
1. The verifier gives the prover the picture
2. The prover cuts out Waldo's face from the picture and destroys the rest of the picture
3. The prover returns the cutout face to the verifier
4. The verifier verifies that the returned face is indeed Waldo's face

Key details about this:
* The verifier learns that the prover knows where Waldo is, but they learn nothing else
* The verifier could've simulated that interaction by:
	1. Verifier gives the simulator a picture with 1000 faces on it
	2. The simulator returns a picture of Waldo (that may or may not be in the original picture)
	3. The simulator's picture is computationally indistinguishable from the prover's picture
	
# Simple Example: Lady Sipping Tea
1. The verifier mixes a cup of tea, putting either milk first or tea first. They give it to the prover.
2. The prover tells whether the tea was milk first or tea first. Suppose the prover is always right.
3. The verifier checks if the prover is telling the truth (because they made the tea)

A simulator could simulate the interaction by:
1. The simulator knows what the verifier did, so just always return exactly what the verifier did

# Zero-Knowledge Proof of Knowledge
Proof of knowledge: What if $V$ wants to be convinced that $P$ knows a valid witness $w$ for $x \in L$?
* Now, the prover has to prove knowledge of $w$ in zero-knowledge
* Proving knowledge is a stronger notion than proving soundness ⟶ you're proving knowledge of the witness; soundness proves existence of the witness

**Idea**: $P$ knows $w$ if $w$ can be *extracted* from the prover $P$ and the verifier is convinced that the extractor works
* (1) Complete, (2) HVZK, (3) $w$ can be extracted from $P$

## Schnorr's Protocol: Proof of Knowledge for Discrete Log
Let $L  =\{ (g, h = g^\alpha) \in G^2 \mid \alpha \in \mathbb{Z}_q \}$ where $\alpha$ is the witness.
1. $P$ picks a random value $\rho$ and sends $R \leftarrow g^\rho \in G$
2. $V$ picks a random value $c \in \mathbb{Z}_q$ and sends it to $P$
3. $P$ computes $z \leftarrow c \cdot \alpha + \rho \in \mathbb{Z}_q$ and sends $z$ to $V$
4. $V$ accepts if $g^z = h^c \cdot R$
![](../../attachments/Pasted%20image%2020250317204145.png)

**Key Details**:
* $V$ only sends random messages to $P$
* The order is critical:
	* $c$ must be sent after the prover chose $R$ ⟶ prover is committed to $R$

**Theorem**: Schnorr's protocol is a zero-knowledge proof of knowledge for the discrete log problem.
1. **Completeness**: If the prover is honest and actually knows $\alpha$ and $g^z$, then
$$
g^z = g^{c \cdot \alpha + \rho} = g^{c \cdot \alpha} \cdot g^\rho = h^c \cdot R$$
	- I.e. if $P$ is honest, then $V$ will accept the proof of knowledge

2. **HVZK**:
	- The transcript is fixed and simply contains $(R, c, z)$:
		- $R$ is a random element in the group $G$.
		- $c$ is a random element in $\mathbb{Z}_q$.
		- $z$ is fixed because it must satisfy $g^z = h^c \cdot R$
	- We can simulate the interaction by:
		1. Choose a random $c$ and $z$ from $\mathbb{Z}_q$
		2. Compute $R \leftarrow g^z / h^c$
		3. Output the transcript $(R, c, z)$
	- This perfectly matches the distribution of the real interaction:
		- $c$ is chosen at random, as in the real interaction
		- $z$ satisfies $g^z = h^c \cdot R$
		- $R$ is the division of two random group elements ⟶ must also be random
	- Because we can simulate the transcript, $V$ learns nothing from the transcript because it can simulate it itself

3. **Extraction**:
	- We want to extract $\alpha$ from a prover $P$
	- We can do this as so:
		1. $P$ will pick a random $\rho$ and send $R \leftarrow g^\rho$
		2. $V$ will reply with a random $c_1 \in \mathbb{Z}_q$
		3. $P$ will compute $z_1 \leftarrow c_1 \cdot \alpha + \rho$ and send $z_1$ to $V$
			- We know that $g^{z_1} = h^{c_1} \cdot R$
		4. **Important**: The extractor rewinds $P$ back to the first round.
		5. $V$ will send a new $c_2 \in \mathbb{Z}_q$ (with high prob, $c_1 \neq c_2$)
		6. $P$ will compute $z_2 \leftarrow c_2 \cdot \alpha + \rho$ and send $z_2$ to $V$
			- We know that $g^{z_2} = h^{c_2} \cdot R$
	- Why does this work?
		- Recall that $z = c \cdot \alpha + \rho$ ⟶ $\rho$ is basically a one-time pad that encrypts $c \cdot \alpha$
		- By rewinding $P$, we've essentially forced a two-time pad that cancels out the one-time pad $\rho$
		- We can divide both sides of the equation to extract $\alpha$:
$$
\begin{align*}
\frac{g^{z_2}}{g^{z_1}} = \frac{h^{c_2} \cdot R}{h^{c_1} \cdot R} \quad &\implies \quad g^{z_2 - z_1} = h^{c_2 - c_1} \\
&\implies g^{\frac{z_2 - z_1}{c_2 - c_1}} = h \\
&\implies \alpha = \frac{z_2 - z_1}{c_2 - c_1} \in \mathbb{Z}_q
\end{align*}
$$
	- We have shown that we can extract $\alpha$ from $P$
		- Implies that a malicious $\hat{P}$ cannot convince $V$ unless it knows $\alpha$

# Applications of ZK Proofs: Signatures
Public coin protocols are those where the verifier sends random messages to the prover.
- Any public coin protocol can be made non-interactive using a Fiat-Shamir transform
- This transformation is a hash function $H: \mathbb{Z}_q \times G \to \mathbb{Z}_q$
- Instead of waiting for a challenge $c$ from the verifier, the prover generates a challenge itself using a hash function

It works as follows:
1. The prover picks a random $\rho \in \mathbb{Z}_q$ and computes $R \leftarrow g^\rho \in G$
2. The prover computes a challenge for itself $c \leftarrow H(x, R) \in \mathbb{Z}_q$
3. The prover computes a response $z \leftarrow c \cdot \alpha + \rho \in \mathbb{Z}_q$
4. The prover sends a non-interactive proof $\pi := (R, z)$ to the verifier
5. The verifier can recompute the challenge by itself: $c \leftarrow H(x, R)$
![](../../attachments/Pasted%20image%2020250317210456.png)

**Important**: The public coin ZKPK gives us a signature scheme!

## Schnorr Signatures
A signature scheme that is derived from Schnorr's proof of knowledge for the discrete log problem and making it non-interactive.
- The signature is basically a non-interactive proof that you know the secret key $\alpha$, and you just embed the message $m$ into the proof
![](../../attachments/Pasted%20image%2020250317210853.png)

Generation is similar to the discrete log generation from before:
![](../../attachments/Pasted%20image%2020250317210912.png)

To sign, we basically run through a proof of knowledge of discrete log:
![](../../attachments/Pasted%20image%2020250317211114.png)

Verification is similar to the discrete log verification from before:
![](../../attachments/Pasted%20image%2020250317211156.png)

**Theorem**: $(\text{Gen}, S, V)$ is secure assuming discrete log is hard in $G$ and $H$ is modeled as a random oracle.
