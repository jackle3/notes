# Recap
* **Current goal**: design a key exchange scheme that is secure against eavesdropping!
* **Diffie-Hellman**:
	* This works because $g^{ab} = g^{ba}$, so we can send $g^a$ and $g^b$ separately and compute the shared key $g^{ab}$
	* There was also a $\bmod p$ to make the discrete log problem harder. It works because:
		* $\big[ (g^a) \bmod p \big]^b \bmod p = g^{ab} \bmod p$ ⟶ the mod commutes with exponentiation

# Arithmetic mod P
* On a 32-bit computer, large numbers are stored in multiple "limbs":
	* An $n$-bit number is split into $\lceil n/32 \rceil$ chunks of 32 bits each (called limbs)
![[Pasted image 20250215220815.png]]
* Arithmetic operations must be performed limb by limb:
	* Addition/Subtraction: $O(n)$ time
		* Process each limb once, carrying over as needed
	* Multiplication: $O(n^2)$ time
		* Must multiply each limb with every other limb
		* Then sum up all partial products (requires $n$ $n$-bit additions)
	* Modulo: $k \bmod n$ is $O(n^2)$ time
		* Similar complexity to multiplication
	* **Note**: $n$ is the number of bits in the value. I.e. this is same as $O(\log_2 x)$ where $x$ is an $n$-bit number
* Note: if given a squaring algorithm we can construct a multiplication algorithm that is only a bit slower
![[Pasted image 20250215221532.png]]

# Modular Arithmetic
* Let $n$ be a very large positive integer, and let $p$ be a positive prime.
* Let $\mathbb{Z}_n = \{0, 1, \ldots, n-1\}$ be the set of integers modulo $n$
	* This allows us to compute addition, subtraction, and multiplication modulo $n$
* Modulo $n$ means we add or subtract multiples of $n$ until the result is within $\mathbb{Z}_n$
	* Example: $11 \bmod 5 = 1$ because $11 - 5 \times 2 = 1$
	* Example: $-3 \bmod 15 = 12$ because $-3 + 15 \times 1 = 12$
* **Euclid's algorithm**:
	* For all integers $n, m$, there exists integers $a, b$ such that $a \cdot n + b \cdot m = \text{gcd}(n, m)$
	* $a, b$ can be found using $O(\log (n + m))$ arithmetic operations
	* If $\text{gcd}(n, m) = 1$, then $n$ and $m$ are **relatively prime**
	* **Intuition**: If $d$ divides both $n$ and $m$, then it must also divide $n - km$ for any integer $k$
		* When we divide $n$ by $m$: $n = qm + r$ (where $q$ is quotient, $r$ is remainder)
		* Rearranging: $r = n - qm$
		* Therefore: $\text{gcd}(n,m) = \text{gcd}(m,r)$
		* We can keep reducing to smaller numbers until we get a remainder of 0
		* The last non-zero remainder must be the GCD since it divides both numbers from the previous step

# Modular Exponentiation
* We want to compute $g^x \bmod p$. Use **repeated squaring** algorithm:
	1. Suppose we want to compute $g^{13}$. We can write 13 in binary as $1101_2$. This means we can write $13$ as a sum of powers of 2.
	2. This means $g^{13} = g^{1101_2} = g^8 \times g^4 \times g^1$
	3. Now, you can start with $g^1$ and keep squaring it to get $g^2, g^4, g^8, \ldots$
	4. We can then pick out the ones we want and multiply them together to get $g^{13}$.
## Repeated Squaring Algorithm
1. Let $x = x_n x_{n-1} \ldots x_1 x_0 \in \{0, 1\}^{n+1}$ be the binary representation of $x$
2. Set $z \leftarrow 1$ and $y \leftarrow g$
3. For $i$ from $0$ to $n$:
	1. If $x_i = 1$, set $z \leftarrow z \times y \bmod p$
	2. Set $y \leftarrow y^2 \bmod p$
4. Output $z$

### Runtime
* We have at most $2 \times \log_2(x)$ multiplications (for $z$ and $y$)
	* Each multiplication is $O(n^2)$ time
	* Since $x$ is an $n$-bit number, $\log_2(x) = n$
* If $x \approx p$ where $p$ is an $n$-bit prime, then:
	* Number of multiplications = $O(n)$
	* Each multiplication costs $O(n^2)$ time
	* Total runtime is $O(n^3)$

# Modular Inversion
* In rationals, the inverse of $x$ is simply $\frac{1}{x}$
* **Def**: The inverse of $x \in \mathbb{Z}_n$ is an integer $y \in \mathbb{Z}_n$ such that $x \cdot y \equiv 1 \bmod n = 1 \in \mathbb{Z}_n$
	* Note that we are in $\mathbb{Z}_n$ so we are working with integers modulo $n$
* **Ex**: Suppose $n$ is an odd integer. What is the inverse of $2$ in $\mathbb{Z}_n$?
	* We need to find $y$ such that $2 \cdot y \equiv 1 \bmod n$
	* The answer is $y = \frac{n+1}{2} \in \mathbb{Z}_n$ because $2 \cdot \frac{n+1}{2} = n+1 \equiv 1 \bmod n$
* Which elements in $\mathbb{Z}_n$ have an inverse?
	* **Lemma**: $x \in \mathbb{Z}_n$ has an inverse iff $\text{gcd}(x, n) = 1$
	* **Proof**:
		* Forwards: Suppose $gcd(x, n) = 1$. That means there exists integers $a, b$ such that $a \cdot x + b \cdot n = 1$
			* We reduce that modulo $n$ (subtract multiples of $n$ until result is in $\mathbb{Z}_n$).
				* That gives us $a \cdot x \equiv 1 \bmod n$
				* Therefore, $a$ is the inverse of $x$ modulo $n$
		* Backwards (contrapositive): If $\text{gcd}(x, n) > 1$, then $x$ cannot have an inverse
			* Let $d = \text{gcd}(x, n) > 1$. Then $x = k_1d$ and $n = k_2d$ for some integers $k_1, k_2$
			* For any integer $a$, $a \cdot x \equiv (ak_1)d \bmod n$
			* Since $d$ divides $n$, any multiple of $d$ modulo $n$ must be either $0$ or another multiple of $d$ (since $n = k_2d$). Since $d > 1$, this means $a \cdot x \bmod n$ can never equal $1$
			* Therefore, no value of $a$ can be an inverse of $x$

## Invertible Elements
* Let $\mathbb{Z}_n^*$ be the set of elements in $\mathbb{Z}_n$ that have an inverse.
$$
\mathbb{Z}_n^* = \{0 < x < n \mid \text{gcd}(x, n) = 1\}
$$
* For example:
	* For a prime number, $\mathbb{Z}_p^* = \{1, 2, \ldots, p-1\} = \mathbb{Z}_p \setminus \{0\}$
	* For $n = 12$, we have $\mathbb{Z}_{12}^* = \{1, 5, 7, 11\}$

## Algorithm
* We can use Euclid's algorithm to find the inverse of an element in $\mathbb{Z}_n$
* For $x \in \mathbb{Z}_n^*$, we can find the inverse of $x$ using $O(\log n)$ arithmetic operations.
	* Recall that addition and subtraction is linear in the number of bits in $n$. This means that the time for each operation is $O(\log n)$.
	* The overall runtime to find an inverse is thus $O(\log^2 n)$

# Solving Modular Linear Equations
* Suppose we want to solve $a \cdot x + b = 0 \in \mathbb{Z}_n$ ⟶ The answer is $x = -b \cdot a^{-1} \in \mathbb{Z}_n$
	* We just treat all our arithmetic operations as modulo $n$.
	* This will take $O(\log^2 n)$ time because we need to compute the inverse of $a$
* We can also solve a system of linear equations by running Gaussian elimination modulo $n$

# Structure of $\mathbb{Z}_p^*$
* **Fermat Theorem (1640)**: Let $p$ be a prime. For every element $x \in \mathbb{Z}_p^*$, we have $x^{p-1} \equiv 1 \bmod p$
	* Ex: $p = 5$ ⟶ let $x = 3 \in \mathbb{Z}_5^*$ ⟶ $3^{5 - 1} = 81 \equiv 1 \bmod 5$
## Applications of Fermat's Theorem
* Given $x \in \mathbb{Z}_p^*$, we know that $x^{p-1} = x \cdot x^{p - 2} \equiv 1 \bmod p = 1 \in \mathbb{Z}_p^*$
	* Therefore, $x^{p-2}$ is the inverse of $x$ modulo $p$ ($x \in \mathbb{Z}_p^*$)
	* Using this method, the runtime is $O(\log^3 p)$ (exponentiation is cubic in the number of bits in $p$)
* This gives us an alternative way to compute modular inverses, though less efficient than the Extended Euclidean Algorithm
* Other applications of Fermat's Theorem include:
	* Primality testing: If we find an $a$ where $a^{p-1} \not\equiv 1 \bmod p$, then $p$ is composite
	* Cryptography: Used in RSA and other cryptographic systems
	* Reducing large exponents: For any $a$ and $k$, $a^k \equiv a^{k \bmod (p-1)} \bmod p$
* The theorem can be generalized to Euler's theorem for any modulus $n$:
	* For any $a$ coprime to $n$, $a^{\phi(n)} \equiv 1 \bmod n$
	* Where $\phi(n)$ is Euler's totient function counting numbers coprime to $n$
	* Fermat's theorem is the special case where $n$ is prime, since $\phi(p) = p-1$ for prime $p$
