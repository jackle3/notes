# Recap
* **Current goal**: design a key exchange scheme that is secure against eavesdropping!
* **Diffie-Hellman**:
	* This works because $g^{ab} = g^{ba}$, so we can send $g^a$ and $g^b$ separately and compute the shared key $g^{ab}$
	* There was also a $\bmod p$ to make the discrete log problem harder. It works because:
		* $\big[ (g^a) \bmod p \big]^b \bmod p = g^{ab} \bmod p$ ⟶ the mod commutes with exponentiation

# Modular Arithmetic
* Let $n$ be a very large positive integer, and let $p$ be a positive prime.
* Let $\mathbb{Z}_n = \{0, 1, \ldots, n-1\}$ be the set of integers modulo $n$
	* This allows us to compute addition, subtraction, and multiplication modulo $n$
* Modulo $n$ means we add or subtract multiples of $n$ until the result is within $\mathbb{Z}_n$
	* Example: $11 \bmod 5 = 1$ because $11 - 5 \times 2 = 1$
	* Example: $-3 \bmod 15 = 12$ because $-3 + 15 \times 1 = 12$
* **Euclid's algorithm**:
	* For all integers $n, m$, there exists integers $a, b$ such that $a \cdot n + b \cdot m = \text{gcd}(n, m)$
	* $a, b$ can be found using $O(\log (n + m))$ arithmetic operations
	* If $\text{gcd}(n, m) = 1$, then $n$ and $m$ are **relatively prime**
	* **Intuition**: If $d$ divides both $n$ and $m$, then it must also divide $n - km$ for any integer $k$
		* When we divide $n$ by $m$: $n = qm + r$ (where $q$ is quotient, $r$ is remainder)
		* Rearranging: $r = n - qm$
		* Therefore: $\text{gcd}(n,m) = \text{gcd}(m,r)$
		* We can keep reducing to smaller numbers until we get a remainder of 0
		* The last non-zero remainder must be the GCD since it divides both numbers from the previous step

# Modular Inversion
* In rationals, the inverse of $x$ is simply $\frac{1}{x}$
* **Def**: The inverse of $x \in \mathbb{Z}_n$ is an integer $y \in \mathbb{Z}_n$ such that $x \cdot y \equiv 1 \bmod n = 1 \in \mathbb{Z}_n$
	* Note that we are in $\mathbb{Z}_n$ so we are working with integers modulo $n$
* **Ex**: Suppose $n$ is an odd integer. What is the inverse of $2$ in $\mathbb{Z}_n$?
	* We need to find $y$ such that $2 \cdot y \equiv 1 \bmod n$
	* The answer is $y = \frac{n+1}{2} \in \mathbb{Z}_n$ because $2 \cdot \frac{n+1}{2} = n+1 \equiv 1 \bmod n$
* Which elements in $\mathbb{Z}_n$ have an inverse?
	* **Lemma**: $x \in \mathbb{Z}_n$ has an inverse iff $\text{gcd}(x, n) = 1$
	* **Proof**:
		* Forwards: Suppose $gcd(x, n) = 1$. That means there exists integers $a, b$ such that $a \cdot x + b \cdot n = 1$
			* We reduce that modulo $n$ (subtract multiples of $n$ until result is in $\mathbb{Z}_n$).
				* That gives us $a \cdot x \equiv 1 \bmod n$
				* Therefore, $a$ is the inverse of $x$ modulo $n$
		* Backwards (contrapositive): If $\text{gcd}(x, n) > 1$, then $x$ cannot have an inverse
			* Let $d = \text{gcd}(x, n) > 1$. Then $x = k_1d$ and $n = k_2d$ for some integers $k_1, k_2$
			* For any integer $a$, $a \cdot x \equiv (ak_1)d \bmod n$
			* Since $d$ divides $n$, any multiple of $d$ modulo $n$ must be either $0$ or another multiple of $d$ (since $n = k_2d$). Since $d > 1$, this means $a \cdot x \bmod n$ can never equal $1$
			* Therefore, no value of $a$ can be an inverse of $x$

## Invertible Elements
* Let $\mathbb{Z}_n^*$ be the set of elements in $\mathbb{Z}_n$ that have an inverse.
$$
\mathbb{Z}_n^* = \{0 < x < n \mid \text{gcd}(x, n) = 1\}
$$
* For example:
	* For a prime number, $\mathbb{Z}_p^* = \{1, 2, \ldots, p-1\} = \mathbb{Z}_p \setminus \{0\}$
	* For $n = 12$, we have $\mathbb{Z}_{12}^* = \{1, 5, 7, 11\}$

## Algorithm
* We can use Euclid's algorithm to find the inverse of an element in $\mathbb{Z}_n$
* For $x \in \mathbb{Z}_n^*$, we can find the inverse of $x$ using $O(\log n)$ arithmetic operations.
	* Recall that addition and subtraction is linear in the number of bits in $n$. This means that the time for each operation is $O(\log n)$.
	* The overall runtime to find an inverse is thus $O(\log^2 n)$

# Solving Modular Linear Equations
* Suppose we want to solve $a \cdot x + b = 0 \in \mathbb{Z}_n$ ⟶ The answer is $x = -b \cdot a^{-1} \in \mathbb{Z}_n$
	* We just treat all our arithmetic operations as modulo $n$.
	* This will take $O(\log^2 n)$ time because we need to compute the inverse of $a$
* We can also solve a system of linear equations by running Gaussian elimination modulo $n$

# Structure of $\mathbb{Z}_p^*$
* **Fermat Theorem (1640)**: Let $p$ be a prime. For every element $x \in \mathbb{Z}_p^*$, we have $x^{p-1} \equiv 1 \bmod p$
	* Ex: $p = 5$ ⟶ let $x = 3 \in \mathbb{Z}_5^*$ ⟶ $3^{5 - 1} = 81 \equiv 1 \bmod 5$

## Applications of Fermat's Theorem
* Given $x \in \mathbb{Z}_p^*$, we know that $x^{p-1} = x \cdot x^{p - 2} \equiv 1 \bmod p = 1 \in \mathbb{Z}_p^*$
	* Therefore, $x^{p-2}$ is the inverse of $x$ modulo $p$ ($x \in \mathbb{Z}_p^*$)
	* Using this method, the runtime is $O(\log^3 p)$ (exponentiation is cubic in the number of bits in $p$)