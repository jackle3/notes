# Review: Key Exchange
All the key exchange protocols so far have only been secure against passive adversaries (eavesdroppers).
![[Pasted image 20250310132426.png]]

# Active Adversary
Active adversaries has complete control of the network:
* Can modify, inject, or delete packets/messages from the network (e.g. man-in-the-middle attacks)
* They can also be **corrupt users** controlled by the adversary
	* Goal: key exchange with corrupt users does not affect other sessions
![[Pasted image 20250310132631.png]]
**Problem**: this cannot be solved by just using regular key exchange ⟶ can always have a MITM attack if the two parties cannot authenticate each other

## Trusted Third Party
**All AKE protocols** require a **TTP** to certify user identities
![[Pasted image 20250310132826.png]]

## AKE Syntax
At the end of the AKE protocol, each party has a shared key and know **who** they are communicating with
* Each party has a **secret key** and a **certificate** that they got from the TTP (e.g. CA)
* They can verify the certificate of the other party using the public key of the TTP
* When Alice sends $E(k, \text{"Data"})$, she has a guarantee that only the receiver can read the data
![[Pasted image 20250310132928.png]]

# Basic AKE Security
From Alice's perspective, there are three main goals of the AKE security (**static security**):
1. No one else can know the shared secret $k$ except for the bank
2. Even if adversaries know Alice's other shared keys, $k$ is indistinguishable from a random string
3. If Alice obtains $(k, \text{Bank})$, then Bank must obtain $(k, \text{Alice})$
![[Pasted image 20250310133316.png]]

## AKE Security Levels
1. **Static Security**: same as the goals above
2. **Forward Secrecy**: static security + if the $sk_\text{bank}$ is compromised, previous sessions are not affected
3. **HSM Security**: forward secrecy + interacting $n$ times with the HSM (device that stores keys) compromises at most $n$ sessions
![[Pasted image 20250310133555.png]]

# Protocol 1: Static Security
## One-sided AKE
One side is a verifier (only has $vk_\text{CA}$) while the other is a prover (has secret key, cert, and $vk_\text{CA}$)
* Used when only **one side** has a certificate ⟶ during key exchange, only Bank authenticates itself to Alice
* Usually followed with some identification protocol so that Alice can authenticate itself with Bank
![[Pasted image 20250310134202.png]]
Note that **this is how the web works**:
* When you connect to Amazon, you are the verifier and Amazon is the prover
* During the key exchange (TLS), you know that you are talking to Amazon but Amazon does not know who you are
* Afterwards, you log in to Amazon (identification protocol) ⟶ now both know each other's identity

## Building Blocks
![[Pasted image 20250310134344.png]]

## 1. Simple One-sided AKE
1. Bank sends Alice a random nonce $r$ and its certificate $\text{cert}_\text{bank}$ (which contains $\text{pk}_\text{bank}$)
2. Alice chooses a random shared key $k$ and replies with $E(\text{pk}_\text{bank}, (k, r))$
3. Alice knows it is talking to Bank, but Bank does not know who Alice is
![[Pasted image 20250310134649.png]]

## Insecure Variant: Replay Attack
Notice that the nonce $r$ is **replied under encryption**. If it was instead **sent in the clear**, the protocol would be vulnerable to replay attacks.
![[Pasted image 20250310135050.png]]
When $r$ is not encrypted with the key, the ciphertext $c$ is only dependent on $k$ and not $r$
* An adversary can replay the same ciphertext $c$ with a new $r'$ and reuse the key
* This allows the adversary to replay $c_1$ and all other messages that was sent before with this key
![[Pasted image 20250310135121.png]]

## 2. Two-sided AKE
1. Bank sends Alice a random nonce $r$ and its certificate $\text{cert}_\text{bank}$ (which contains $\text{pk}_\text{bank}$)
2. Alice chooses a random shared key $k$ and replies with two things:
	* $c \leftarrow E_\text{bank}((k, \text{"alice"}))$: to send her own identity to Bank
	* $\sigma \leftarrow \text{Sign}_\text{Alice}((r, c, \text{"bank"}))$ and $\text{cert}_\text{alice}$: to prove to the bank that her identity is authentic
![[Pasted image 20250310135428.png]]

## Insecure Variant: Identity Misbinding
Instead of returning $c \leftarrow E_\text{bank}((k, \text{``alice''}))$, Alice returns $c \leftarrow E_\text{bank}((k, r))$.
![[Pasted image 20250311180700.png]]

An attacker can perform a **identity misbinding attack**:
![[Pasted image 20250311180845.png]]
1. Bank sends $r$ and its certificate $\text{cert}_\text{bank}$ to Alice
2. Alice now thinks it is talking to Bank, so she responds with:
	* $c \leftarrow E_\text{bank}((k, r))$
	* the signature $\sigma$ that signs $(r, c, \text{``bank''})$ under $sk_\text{alice}$
	* $\text{cert}_\text{alice}$ which contains $pk_\text{alice}$
3. The attacker blocks this message and sends a **different message** to Bank:
	* Same ciphertext $c$ as before.
	* $\sigma'$ that signs $(r, c, \text{``bank''})$ under $sk_\text{Evil}$
	* $\text{cert}_\text{Evil}$ which contains $pk_\text{Evil}$
4. When bank receives this, it looks like a perfectly valid message from Evil

**Key Details**:
* Alice thinks she is talking to the Bank
* Bank thinks that it is talking to Evil

**Problem**:
* When Alice says "deposit this check into my account" to the Bank without specifying the account, the Bank will actually deposit it into Evil's account
* This is why the ciphertext $c$ must contain the identity of the other party ⟶ when the Bank receives $c$ (which contains `"alice"`), it can verify that the name is **consistent with the certificate**

## Insecure Variant: Signature Replay Attack
Instead of returning $\sigma \leftarrow \text{Sign}_\text{Alice}((r, c, \text{"bank"}))$, Alice returns $\sigma \leftarrow \text{Sign}_\text{Alice}((r, c))$.

An attacker can reuse the signature $\sigma$ from the previous protocol:
1. Bank sends Alice a random nonce $r$ and its certificate $\text{cert}_\text{bank}$
2. Alice responds with:
	* $c \leftarrow E_\text{bank}((k, \text{"alice"}))$
	* $\sigma \leftarrow \text{Sign}_\text{Alice}((r, c))$ and $\text{cert}_\text{alice}$
3. The attacker intercepts this message
4. Later, Second Bank sends the same nonce $r$ to someone
5. The attacker intercepts this and sends Second Bank:
	* The same ciphertext $c$ from Alice's previous response
	* The same signature $\sigma$ from Alice's previous response
	* Alice's certificate $\text{cert}_\text{alice}$

Since the nonce $r$ and the signed data $(r,c)$ are identical to the previous protocol run, Second Bank will verify the signature using Alice's public key from $\text{cert}_\text{alice}$ and believe it is in direct communication with Alice.
* It might then pull money from Alice even though Alice has not communicated with Second Bank

# Protocol 2: Forward Secrecy

> [!NOTE] Forward Secrecy
> Server compromise at time $T$ should not comrpomise sessions at time $t < T$

The protocols so far are not forward secure:
* It is statically secure: the attacker cannot recover the session key $k$ during the protocol execution
	* Even if the attacker intercepts all messages between Alice and Bank
	* Even if the attacker can modify or block messages
	* This is because $k$ is encrypted with Bank's public key, so only Bank can decrypt it
	* And the signature prevents the attacker from tampering with the encrypted message
* Suppose the attacker records all the messages in the session and later recovers $sk_\text{bank}$
	* The attacker can then decrypt all the previous messages
![[Pasted image 20250311182735.png]]

## 1. Simple One-sided AKE with Forward Secrecy
The key idea is to use **ephemeral** keys for the session: the $pk$ and $sk$ are generated at the beginning of the session and discarded after the session is over.
![[Pasted image 20250311183050.png]]
1. Bank generates a new ephemeral key pair $(pk, sk)$ for the session
2. Bank then sends to Alice:
	* The ephemeral public key $pk$
	* The certificate $\text{cert}_\text{bank}$ which contains the bank's long term public key $pk_\text{bank}$
	* A signature $\sigma \leftarrow \text{Sign}(\text{cert}_\text{bank}, pk)$ that signs the ephemeral public key $pk$ under $sk_\text{bank}$
3. Alice verifies the signature with $\text{Verify}(\text{cert}_\text{bank}, pk, \sigma)$. It fails if the signature is not valid
4. Alice generates a random session key $k$ and sends to Bank:
	* The encryption of the session key under the ephemeral public key $c \leftarrow E(pk, k)$
5. The bank decrypts the session key with the ephemeral private key $k \leftarrow D(sk, c)$
6. Alice and Bank now have a shared key $k$. Bank now deletes the ephemeral key pair $(pk, sk)$

## Insecure Variant: Key Exposure
Suppose the bank does not send the signature of the ephemeral key $pk$ to Alice:
![[Pasted image 20250311183735.png]]

An attacker can now completely expose the session key $k$ by:
![[Pasted image 20250311183922.png]]
1. Intercepting the Bank's first message and generating a new ephemeral key pair $(pk', sk')$
2. Sending $pk'$ to Alice with the bank's certificate $\text{cert}_\text{bank}$
3. Alice now thinks it is talking to the Bank and generates a new session key $k$.
4. Alice sends $c \leftarrow E(pk', k)$ to the attacker, which the attacker can decrypt using $sk'$ to get $k$
5. Suppose Alice then sends data using this $k'$ ⟶ the attacker can read all data sent by Alice to the Bank
# Protocol 3: HSM Security
The HSM is a device that stores keys and performs cryptographic operations. 