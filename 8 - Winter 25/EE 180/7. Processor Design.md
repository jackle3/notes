# Review: Digital Logic Design
![[Pasted image 20250128134342.png]]

# Building a Processor
![[Pasted image 20250128134453.png]]

# Simple Processor
![[Pasted image 20250128134540.png]]
![[Pasted image 20250128134553.png]]

## Instruction Steps
![[Pasted image 20250128134601.png]]

## Initial Processor Datapath
![[Pasted image 20250128134628.png]]

# Fetching the Instruction
1. `Instruction = Memory[PC]`
	* Fetch the instruction from memory
	* In MIPS, instructions are always 32 bits
2. Update program counter for next cycle
	* Address of next instruction is `PC <- PC + 4` (assuming byte addressing)
![[Pasted image 20250128134837.png]]

## Decoding the Instruction
* MIPS ISA has some nice characteristics that makes decoding easy:
	* Instructions are fixed length â€” easy to find next instruction
	* Source registers are always in the same place (or not present)
	* Can read registers in parallel with decoding the instruction
![[Pasted image 20250128135814.png]]

## Register Instructions
* Note that the registers take up 5 bits bc we have $2^{5} = 32$ registers
![[Pasted image 20250128140200.png]]
![[Pasted image 20250128140447.png]]

## Immediate Instructions
### Arithmetic
![[Pasted image 20250128140823.png]]
![[Pasted image 20250128140904.png]]
* For immediates:
	* `RegDst` should be `0` because destination reg is `rt`
	* `ALUSrc` should be `1` because we use immediate for op
![[Pasted image 20250128141702.png]]

### Load
![[Pasted image 20250128141805.png]]
![[Pasted image 20250128141810.png]]
![[Pasted image 20250128142122.png]]
### Store
![[Pasted image 20250128142138.png]]
![[Pasted image 20250128142142.png]]
![[Pasted image 20250128142153.png]]

### Branch
![[Pasted image 20250128142314.png]]
## Jump Instructions
![[Pasted image 20250128142925.png]]
![[Pasted image 20250128142936.png]]

## Updating the PC
![[Pasted image 20250128142502.png]]
![[Pasted image 20250128142815.png]]

## Summary
![[Pasted image 20250128143038.png]]

# Control
![[Pasted image 20250128143112.png]]
![[Pasted image 20250128143211.png]]
![[Pasted image 20250128143230.png]]
![[Pasted image 20250128143336.png]]
![[Pasted image 20250128143348.png]]
![[Pasted image 20250128143417.png]]
![[Pasted image 20250128143421.png]]
![[Pasted image 20250128143434.png]]
![[Pasted image 20250128143439.png]]

# Control Signals
![[Pasted image 20250128143940.png]]

# Multilevel Decoding
![[Pasted image 20250128144519.png]]
![[Pasted image 20250128144532.png]]

# Timing for MemWrite & RegWrite
![[Pasted image 20250128144711.png]]
* Solution: find the worst case path, and adjust the clock period to the delay of the worst case computation.
![[Pasted image 20250128144816.png]]

# Summary
![[Pasted image 20250128144849.png]]
![[Pasted image 20250128144855.png]]
