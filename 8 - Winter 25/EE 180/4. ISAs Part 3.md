
# Procedure Call
* Procedures include **functions, methods, subroutines**, etc
* Implementing procedures in assembly requires a few things:
	1. Memory space for local variables
	2. Arguments to pass in and return values passed out
	3. Execution continues after the call returns
* We run procedures using **jump and link**
## General Steps
* The steps for a procedure call are:
	1. Place arguments into registers for the procedure to use
	2. Transfer control to the procedure using jump and link
	3. Allocate space in stack for the procedure
	4. Perform the procedure body
	5. Place the result value in register for calling program
	6. Free the stack memory from (3)
	7. Return control to point of origin.
## Key Registers
* The key registers and instructions for procedure calls are:
	1. **Call:** Jump and link instruction (`jal target`)
		* Stores `PC + 4` into `$ra`
		* Jumps to target
	1. **Return:** `jr $ra`
		* Jumps to address stored in `$ra`
	1. **Arguments:** convention is to use `$a0 - $a3`
	2. **Return values:** convention is `$v0 - $v1`
* If function needs >4 arguments, use the stack.
* If function needs >8 bytes (2 registers) of return values, use the stack.
## Stack and Heap
* To support recursion, we make space in the stack to **store state (args, local vars, return pointer) of each function instantiation**
* Stack memory is a `last in, first out` data structure.
* The stack grows downwards and shrinks upwards.
	* The **entire stack frame** is pushed and popped for each procedure.![[Pasted image 20250116140457.png|700]]
* **Note:** this is all a software convention. We implement this convention using regular instructions and registers.
![[Pasted image 20250116140711.png|700]]

## Procedure Frame
* The stack saves the arguments, return addresses, registers, and local structures.
* `$fp` points to the first word of stack frame ⟶ `$fp := $sp + [frame sz] - 4`
* Frame sizes are expected to be a multiple of 8 bytes (double word).
	* This is a convention ⟶ because floats are double precision (8 bytes), it's simpler to know for sure that the frame size will be 8-byte aligned.
![[Pasted image 20250116141107.png|700]]
## Register Convention
![[Pasted image 20250116141116.png|700]]
## Caller vs. Callee Saved Registers
**Callee** saved registers (callee **preserves** these for caller)
* Saved regs (`$s0-$s7`), stack/frame ptr (`$sp, $fp, $gp`), return addr (`$ra`)
	* Callee saves these registers on stack before using them
	* Callee restores registers before returning from function
* Caller can assume these registers will maintain their values across function calls

**Caller** saved registers (callee does **not preserve** these for caller)
* Temp regs (`$t0-$t9`), arg regs (`$a0-$a3`), return values (`$v0-$v1`)
	* Callee can use these registers without saving or restoring them.
* If caller needs these after procedure call, caller is responsible for saving and restoring these registers before calling a function

## Call and Return Procedure
**A. Before Caller Invokes Callee**
1. Save caller svaed registers `$a0-$a3, $t0-$t9` as needed
2. Store arguments in `$a0-$a3` (if need more args, pass via stack)
3. Execute `jal` to jump to callee

**B. Before Callee Starts Running (prologue)**
1. Allocate memory for new frame: `$sp = $sp - frame_sz`![[Pasted image 20250116142850.png|700]]
1. Save callee-saved registers `$s0-$s7, $fp, $ra` in the frame as needed![[Pasted image 20250116142900.png|700]]
2. Set frame pointer: `$fp = $sp + frame_sz - 4`![[Pasted image 20250116142907.png|700]]

**C. Before Callee Returns (epilogue)**
1. Place return values in `$v0, $v1`
2. Restore all callee-saved registers that were saved in the prologue
3. Pop the stack frame: `$sp = $sp + frame_sz`
4. Return using `jr $ra`

**D. When Caller Regains Control**
1. Restore any caller-saved registers from (A) as needed.

# Example Procedure Calls
## FooBar
![[Pasted image 20250116143215.png|700]]
## Factorial
![[Pasted image 20250116143225.png|700]]
# Optimizing Tail Recursion
* Tail recursion is a special case of recursion where the recursive call is the last operation in the function, and the return value is the result of the recursive call.![[Pasted image 20250116143704.png|700]]
* We can often rewrite tail-recursive functions as loops, which are more efficient.![[Pasted image 20250116143711.png|700]]
* The assembly code is much more straightforward now.![[Pasted image 20250116143738.png|700]]

# Parallelism
1. Parallelism within a **single thread of control**
	* Data-level parallelism within a single core ⟶ vectorization
2. Parallelism across **multiple threads of control**
	* Thread-level parallelism across multiple cores.

# Data Parallelism (Vectorization)
* Vectorization allows us to perform $N$ operations using one instruction.![[Pasted image 20250116144124.png|700]]

## Instructions
* The basic **vector instructions** are:![[Pasted image 20250116144207.png]]

## Benefits
* Each instruction specifies parallel work ⟶ allows for higher performance
* Instruction cost is amortized better
	* There is overhead in energy for fetching and decoding instructions
	* Vector instructions can amortize energy cost over multiple arithmetic operations

## Example: SAXPY
![[Pasted image 20250116144827.png]]

## Vector Length
* Vector instructions can have either:
	* **Fixed length**: The instruction operates on all elements in the vector
		* Example: Intel SSE instructions
	* **Variable length**: The number of operations is controlled by a vector length register (VL)
		* VL can be between 0 and the maximum number of elements
		* Example: `vadd.vv` with VL=10 performs:
