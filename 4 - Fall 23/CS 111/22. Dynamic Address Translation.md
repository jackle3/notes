---
Date: 2023-11-17
---
# Multiple Segments

- Break virtual address space of a process into segments → map each segment independently
    - E.g. one segment for code, one segment for data/heap, one segment for stack

![[attachments/Untitled 149.png|Untitled 149.png]]

- If there is a shared read-only piece of code, and you run the same process multiple times, you can map all those processes to the same piece of code in the physical address space.

![[attachments/Untitled 1 112.png|Untitled 1 112.png]]

- The base and bound approach still applies here, but it’s by segment

![[attachments/Untitled 2 112.png|Untitled 2 112.png]]

## Finding segment of an address

- We can encode the segment number in the virtual address, to make it easier to find which segment an address belongs to.

![[attachments/Untitled 3 111.png|Untitled 3 111.png]]

- There’s no convention for the virtual address number, so this is still fine.
    - In this case, the virtual address is two chunks: the segment # and the offset from the start of the segment

## Benefits

![[attachments/Untitled 4 106.png|Untitled 4 106.png]]

## Drawbacks

![[attachments/Untitled 5 106.png|Untitled 5 106.png]]

- You have to manually allocate the number of bits to store the segment and the offset in the virtual addresses
- It’s hard to position the segments without external fragmentation, since they are variable length
    - For filesystems, we fixed the fragmentation problem by using fixed-sized blocks to break up the file data

# Paging

- Break up the virtual address space into fixed-sized chunks

![[attachments/Untitled 6 105.png|Untitled 6 105.png]]

- There are no partial pages. This means there can be internal fragmentation, where a page is not fully used.
- The paging is present in both virtual and physical addresses.
    - There is a virtual page number (for just that process)
    - There is also a physical page number, for every process

![[attachments/Untitled 7 102.png|Untitled 7 102.png]]

![[attachments/Untitled 8 94.png|Untitled 8 94.png]]

## Page Maps

- How do we track, for a process, which virtual page maps to which physical page?

![[attachments/Untitled 9 90.png|Untitled 9 90.png]]

- We can think of the page map as an array.
    - The index of the entry is virtual page number.
    - The entry at that index is the physical page number and additional info (struct)

![[attachments/Untitled 10 85.png|Untitled 10 85.png]]

- For 4KB pages (4096 bytes), the offset can be 0-4095.
    - Thus, we can store the offset in 12 bits (the amount needed to represent any number 0-4095) → 12 bits = 3 hexadecimal digits
- The last 12 bits of the virtual address is the offset, and the rest of the bits is the page number.

## Examples

![[attachments/Untitled 11 83.png|Untitled 11 83.png]]

- The offset is the same on the virtual page and the physical page.

![[attachments/Untitled 12 80.png|Untitled 12 80.png]]

- Notice that you just append the two chunks of the address together.

## Free List

![[attachments/Untitled 13 75.png|Untitled 13 75.png]]

## Summary

![[attachments/Untitled 14 68.png|Untitled 14 68.png]]