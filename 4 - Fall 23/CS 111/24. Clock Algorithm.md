---
Date: 2023-11-29
---
# Page Replacement

![[attachments/Untitled 144.png|Untitled 144.png]]

## Clock algorithm → LRU

![[attachments/Untitled 1 107.png|Untitled 1 107.png]]

- Basically go through the pages in a circular pattern, and find a page that hasn’t been reference since the **last time we checked** (ie. kicked something out)
- To implement this, add a **reference** bit to the page table.
    - The reference bit is 1 whenever a page is read or written.
- The clock algorithm is triggered everytime we want a physical page, but there is no more left.

![[attachments/Untitled 2 107.png|Untitled 2 107.png]]

![[attachments/Untitled 3 106.png|Untitled 3 106.png]]

- When we remove it, we delete the physical page map for virtual page 2, and give it to virtual page 5.

![[attachments/Untitled 4 102.png|Untitled 4 102.png]]

- Notice that the clock hand (on the left) is save at D, since we already kicked out the virtual page that was using C.

### Wrapping Around

- It’s possible to you will have to do multiple cycles in a single run of the clock algorithm.

![[attachments/Untitled 5 102.png|Untitled 5 102.png]]

- In the example above, every page has been referenced before.
    - If we start from C, it will have to do a full cycle of every page, going back to C.
    - At that point, it will kick out C since it’s the first page set to zero.

### Summary

- Note that the clock hand sweeps over the **physical** pages, since it’s deciding on a physical page to kick out.

![[attachments/Untitled 6 101.png|Untitled 6 101.png]]

- For a page, if the reference bit is 1, it will first set it to zero. If by the second time it comes back, it’s still zero, the page gets kicked out.
    - When a page is read or written, it will set the reference bit to 1.

## Multiple Processes

![[attachments/Untitled 7 98.png|Untitled 7 98.png]]

# OS Execution

- We’ve focused on how the process runs with the virtual address space. Now we focus on how the OS runs.

![[attachments/Untitled 8 91.png|Untitled 8 91.png]]

- For example, `waitpid` is a system call, meaning that the OS will run that code.
    - However, `waitpid` takes in the parameter `status`, which is a reference to a local variable, which has a virtual address.
        - The OS does not know the process’s virtual address, only the process does.

![[attachments/Untitled 9 87.png|Untitled 9 87.png]]

- If we did the option above, we would have to manually go into the process’s virtual address table to translate it in software.

![[attachments/Untitled 10 82.png|Untitled 10 82.png]]

- In this option, we stay in the virtual address space of the process. The OS is present in every process’s virtual address space.
- **The OS and the user (process) is in the same address space**
    
    ![[attachments/Untitled 11 80.png|Untitled 11 80.png]]
    
    - There is space at the top of every process for the OS. The OS maps this region directly to physical memory.
        - All of the virtual addreseses for the OS in every process map to the **same** part of the physical memory.

![[attachments/Untitled 12 77.png|Untitled 12 77.png]]