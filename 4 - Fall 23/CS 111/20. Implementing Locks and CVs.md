---
Date: 2023-11-13
---
# Implementing Locks

![[attachments/Untitled 141.png|Untitled 141.png]]

## Queues

- There is a waiting queue for each mutex, storing the threads currently waiting on it.
- There is a global ready queue, storing the threads that are ready to run.
- Note that each thread must be only part of **one** queue at a time.
    - The thread can’t be in a waiting queue and a ready queue at the same time.
    - The thread also can’t be in more than one mutex’s waiting queue at the same time.

## Locking

- If it can’t be instantly locked, put the thread to the back of the waiting queue for that mutex, then block until we are able to continue.

![[attachments/Untitled 1 104.png|Untitled 1 104.png]]

- Blocking means we block our current thread and then switch to the next ready thread.
    - `blockThread` basically triggers a context switch inside our implementation.

## Unlock

![[attachments/Untitled 2 104.png|Untitled 2 104.png]]

- In this case, calling `unblockThread` adds the next waiting thread to the ready queue. From here, it can be context switched into and ran.
    - This code doesn’t get to run right now. We just mark it as ready.

## Race Condition

- One race condition is if it gets interrupted when it passes the if statement in `lock`, but right before it can run `locked = 1`.

![[attachments/Untitled 3 103.png|Untitled 3 103.png]]

- To fix this race condition, we can disable interrupts within the functions to prevent another thread from running.

# Using Interrupts for Locks

- This is one way to implement this. However, there is still the chance of a race condition (or more accurately, deadlock)
    
    ![[attachments/Untitled 4 99.png|Untitled 4 99.png]]
    
- As such, we disable interrupts for the whole function.
    
    ![[attachments/Untitled 5 99.png|Untitled 5 99.png]]
    
- We do the same thing for unlocks
    
    ![[attachments/Untitled 6 98.png|Untitled 6 98.png]]
    

# Interrupt Guard

- In the implementations above, there is an issue: if the caller of `unlock` disables interrupts, this `unlock` function will enable them when it is called, which is not what we want.
    
    ![[attachments/Untitled 7 95.png|Untitled 7 95.png]]
    
- To fix this, we can use an interrupt guard.
    
    - `IntrGuard` is like `unique_lock` but for interrupts. It **saves the current interrupt state** (enabled/disabled) when it’s created and turns interrupts off. When it is deleted, it **restores interrupts to the saved state.**
    - Key idea: if interrupts are already disabled when an IntrGuard is created, it keeps them disabled
    
    ![[attachments/Untitled 8 89.png|Untitled 8 89.png]]
    
    ![[attachments/Untitled 9 85.png|Untitled 9 85.png]]
    

## Interrupt handshake

- Notice that in `lock`, when we call `blockThread` to switch to another thread, interrupts will still be disabled.
    
    - This is okay because we know that every possible way a thread resumes (e.g. timer or inside lock) will reenable interrupts. Therefore, this isn’t a problem.
    
    ![[attachments/Untitled 10 80.png|Untitled 10 80.png]]
    

# Implementing CVs

![[attachments/Untitled 11 78.png|Untitled 11 78.png]]

## wait

![[attachments/Untitled 12 75.png|Untitled 12 75.png]]

## notify_one and notify_all

![[attachments/Untitled 13 71.png|Untitled 13 71.png]]