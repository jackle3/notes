---
Date: 2023-11-27
---
# Recap of Memory Designs

## Base and Bound

- Map entire virtual address space contiguously, with a base and a bound.

![[attachments/Untitled 156.png|Untitled 156.png]]

- Changing the base means moving where in physical memory it’s allocated.
    - No change in the virtual address space.
- Changing the bound lets the process use higher virtual addresses.
    - However, hard to make use of upward space because we can’t move existing stack up after program starts
        
        ![[attachments/Untitled 1 119.png|Untitled 1 119.png]]
        

## Multiple Segments

- Put segments of virtual memory in differeng segments. Each segment has a base and bound.

![[attachments/Untitled 2 119.png|Untitled 2 119.png]]

- Changing a base just moves where the segment is in memory.
- Changing bound lets it use higher virtual addresses.
    - This is good for heap and code, but bad for stack because you can’t move the stack up. Can’t use the higher addresses of the stack.

## Paging

- Store memory in chunks called pages. Removes external fragmentation, but introduces internal fragmentation.
    
    ![[attachments/Untitled 3 118.png|Untitled 3 118.png]]
    

### Page + Offset Address

![[attachments/Untitled 4 113.png|Untitled 4 113.png]]

# Page Map

- The size of the page map for the paging implementation is a concern.

## Invalid Page Numbers

- Because we have an entry for every page, this can get very large.

![[attachments/Untitled 5 112.png|Untitled 5 112.png]]

## Size of page map

- The page map for a single process can get very big, since we have an entry for every page.
- In x86-64, virtual page numbers are **36-bit**, and each map entry is **8-byte**
    - There are $2^{36}$﻿ possible virtual page numbers.
    - $2^{36} \text{virtual pages} \times 8 \text{ bytes per page entry} = 512 \text{ GB needed for page map}$﻿
- Most processes are **small**, so page map will be sparse
    - Most pages will be not present
    - Large processes use their address space sparsely (code is at bottom, stack at top, middle is unused)

## Multi-level tree

![[attachments/Untitled 6 110.png|Untitled 6 110.png]]

- Basically only allocate memory for ranges that exist

# Demand Paging

- What happens when **memory fills up?**
- A process needs all of its pages in memory in order to run.
    - If there is not enough memory:
        1. Save the contents of some physical page to the **disk**
        2. Use that page for new data in memory
        3. Load the old data back into another physical page later if needed
- **Makes physical memory look larger than it is**

![[attachments/Untitled 7 107.png|Untitled 7 107.png]]

- This works because of **locality** → most programs spend most of their time using a small fraction of their code and data

## Swapping to Disk

![[attachments/Untitled 8 99.png|Untitled 8 99.png]]

- In the example elow, we want to put **virtual page 6** into memory, and we kick out **vpage 0**
- First, pick a page and swap it to disk. Mark that page as not present in the page map.
    
    ![[attachments/Untitled 9 95.png|Untitled 9 95.png]]
    
- Then, we can map that old physical page to another virtual page
    
    ![[attachments/Untitled 10 90.png|Untitled 10 90.png]]
    

## Accessing swapped page

![[attachments/Untitled 11 88.png|Untitled 11 88.png]]

- Page fault occurs when the program accesses a page that is not present.
    - When a page fault occurs, we check the swap to see if it’s in there.
- We then kick out another physical page. In this case we kick out **vpage 7**
    
    ![[attachments/Untitled 12 85.png|Untitled 12 85.png]]
    
- Then we load it our desired page (**vpage 0**) back in and mark it as present
    
    ![[attachments/Untitled 13 80.png|Untitled 13 80.png]]
    

# Trashing

- When the pages **being actively used** don't fit in physical memory, so we spend all time reading/writing pages, slowing the system down
    - This leads demand paging to significantly slow the system

![[attachments/Untitled 14 70.png|Untitled 14 70.png]]

# Page Fetching

- If there is space in memory, when should we bring pages back into memory?

![[attachments/Untitled 15 67.png|Untitled 15 67.png]]

- We also **don’t always have to wrap a swapped page to disk**

![[attachments/Untitled 16 63.png|Untitled 16 63.png]]

# Types of Pages

![[attachments/Untitled 17 59.png|Untitled 17 59.png]]