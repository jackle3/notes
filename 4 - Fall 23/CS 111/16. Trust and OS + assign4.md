---
Date: 2023-11-03
---
# **Definitions of Trust**

- Trust is an unquestioning attitude where one stops questioning the dependability of a thing, which involves intentions, dependence, and the balance of vulnerability and risk (Page 13).
- Trust amongst tech users, app developers, and OS developers is intertwined, extending agency to software through an unquestioning attitude (Page 23).
- Trust emerges through:
    - **Assumption**: Trust absent clues to warrant it.
        - This is like trusting someone or something without needing any proof or history that they're trustworthy.
        - It's like when someone shouts "watch out!" and you duck without thinking.
        - You're assuming they're warning you of real danger without needing evidence first
    - **Inference**: Trust from evidence of past performance, characteristics, institutions.
        - This type of trust is based on what you know about someone or something's past behavior. For example, if you use a password management service, your trust might be based on good reviews or a solid privacy policy you've read about. It's trust that comes from a track record or reputation
    - **Substitution**: Structural arrangement to partly decrease the need for trust (Page 21).
        - This is when you set up systems or structures that reduce the need to trust in the first place. For instance, you might keep some passwords stored only on your local machine and not in an app. This way, you're not just trusting the app to keep your passwords safe; you're also taking steps to protect yourself just in case
- **Agential gullibility** â†’ giving more trust than is warranted

# **Key Examples**

- **Trusting Linux**: The lecture uses Linux as an example to illustrate trust in an operating system. Despite its complexity, with over 1.1 million commits and contributions from 13.9k contributors, and more than 8 million lines of code, users and developers place trust in Linux as a reliable and secure OS (Pages 7, 12, 19, 24).
- **Self-assessment Example**: Participants are asked to identify a person, thing, or service they trust, using the criteria of assumption, inference, and substitution to evaluate how that trust manifests in their daily lives (Page 21).

**Information from Slide 16:**

- When you trust people or software, you integrate it into your own functioning, which means you rely on it as part of your daily activities or work.
- Trusting allows you to work more efficiently because you stop questioning everything and save time by not double-checking all the time.
- However, there's a risk involved because if the person or thing you trust fails, you can feel betrayed. This is why it's important to trust with great care, acknowledging the power and necessity of trust but also being aware of the risks (Page 16).

**Slide 16 Takeaway:**

- Trust is described as powerful and necessary, yet it comes with inherent risks. If you trust in people or things, you're likely to incorporate them into your life or work, expect efficiency gains from not having to verify their actions constantly, and experience a sense of betrayal if that trust is broken. The slide emphasizes the need to extend trust carefully, considering the potential for both reliance and risk (Page 16).

# **Lecture Takeaway**

- Trust is often required, powerful, and dangerous. A significant design challenge in computing is creating structures that enable us to substitute trust, which will be explored in assignment 4 through the use of the monitor pattern to write multithreaded programs (Page 41).

# Unique Locks

![Untitled 147.png](../../attachments/Untitled%20147.png)

- For example, we can use this with the monitor pattern methods:

![Untitled 1 110.png](../../attachments/Untitled%201%20110.png)

![Untitled 2 110.png](../../attachments/Untitled%202%20110.png)

![Untitled 3 109.png](../../attachments/Untitled%203%20109.png)