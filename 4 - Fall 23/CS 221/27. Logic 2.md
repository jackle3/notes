---
Date: 2023-11-29
---
# Propositional Logic

- Restricting the set allowed set of formulas

## Definite Clauses

- If a conjunction of propositional symbols hold, then some other propositional symbol $q$﻿ holds.

![[attachments/Untitled 109.png|Untitled 109.png]]

## Horn Clause

![[attachments/Untitled 1 75.png|Untitled 1 75.png]]

- The goal clause is equivalent to the negation of $\neg (p_1 \land \dots \land p_k)$﻿

## Modus ponens

![[attachments/Untitled 2 75.png|Untitled 2 75.png]]

- The conjunction of the propositional symbols $p_1, \dots, p_k$﻿ implies $q$﻿.
    - If we are given $p_1, \dots, p_k$﻿ as our premises (evidence), then we get $q$﻿, which is our conclusion.
- It takes linear time to apply this rule, as each application generate a clause that contains a single propositional symbol.

### Completeness

- Modus ponens is **complete** with respect to Horn clauses:
    - If we suppose that $KB$﻿ contains only Horn clauses and $p$﻿ is an entailed propositional symbol, then applying modus ponens will then derive $p$﻿.
    - Any propositional symbol that is entailed can be derived by modus ponens too

![[attachments/Untitled 3 75.png|Untitled 3 75.png]]

- The KB above only has Horn clauses, and we want to ask whether the **KB entails traffic**.
    - Entailling means can we derive Traffic based on the things in our knowledge base.
- The tree is the derivation tree, where the root is our goal (derived using inference rules)
    - The leaves are the original formulas in KB.
    - Each internal node is a formula produced by applying an inference rule (e.g. modus ponens) with the children as premises.

## Conjunctive normal formula

![[attachments/Untitled 4 72.png|Untitled 4 72.png]]

- A CNF is equivalent to a KB where each formula is a clause.

### Equivalent Representations

- Every formula in propositional logic can be written into an equivalent CNF formula.

![[attachments/Untitled 5 72.png|Untitled 5 72.png]]

## Horn clauses and disjunction

- We can rewrite all the implications within horn clauses as disjunction (or) and negation

![[attachments/Untitled 6 71.png|Untitled 6 71.png]]

- A Horn clause says that there can be **at most one positive literal**.
    - A literal is either $p$﻿ or $\neg p$﻿, where $p$﻿ is a propositional symbol
    - A clause is just a disjunction (or) or literals
    - The negative literals are the propositional symbols on the left of the implication, and the positive are the ones on the right.
- We can rewrite the modus ponens with disjunction

$\frac{A, A \to C}{C} \to \frac{A, \neg A\lor C}{C}$

- The intuition is that you can cancel out $A$﻿ and $\neg A$﻿.
    - To respect soundness, we dequire $\{A, \neg A \lor C\}$﻿ to entail $C$﻿. This is equivalent to if $A \land (\neg A \lor C)$﻿ is true, then $C$﻿ is also true.

## Resolution inference rule

![[attachments/Untitled 7 69.png|Untitled 7 69.png]]

- Takes two general clauses, where one of them has $p$﻿ and the other has $\neg p$﻿. The conclusion is just the disjunction of the two clauses with $p$﻿ removed.
- It can take exponential time to apply this rule, as each application generates a clause that has a subset of the propositional symbols.
- **Resolution is sound and complete for propositional logic**

### Resolution inference steps

![[attachments/Untitled 8 65.png|Untitled 8 65.png]]

- $f$﻿ is entailed by $KB$﻿ iff $KB \cup \neg f$﻿ is unsatisfiable.

![[attachments/Untitled 9 62.png|Untitled 9 62.png]]

- Deriving false represents finding a contradiction, meaning it’s unsatisfiable

### Example

![[attachments/Untitled 10 60.png|Untitled 10 60.png]]

- The leaves are the CNF formulas in the KB, the internal nodes are things produced from resolution rule.
- Since we derive false, the original knowledge base was unsatisfiable

## Time Complexity Summary

![[attachments/Untitled 11 59.png|Untitled 11 59.png]]

---

# First-order logic

- Adds quantifiers and variables to propositional logic.

## Syntax

![[attachments/Untitled 12 58.png|Untitled 12 58.png]]

- Atomic formulas are analogue to propositional symbols, but now with additional structure

## Quantifiers

![[attachments/Untitled 13 56.png|Untitled 13 56.png]]

- **Universal Quantifier:** $\forall x. (P(x) \to Q(x))$﻿
    - The connective between P and Q is an implication. This is because when we talk about every P, we are only restricting our attention to objects **x for which P(x) is true**.
- **Existential Quantifier:** $\exists x. (P(x) \land Q(x))$﻿
    - The connective is conjunction, because we’re looking for an object x such that P(x) and Q(x) both hold

## Examples

![[attachments/Untitled 14 54.png|Untitled 14 54.png]]

## Models

![[attachments/Untitled 15 52.png|Untitled 15 52.png]]

- If predicates are unary and binary, a model can be represented as a directed graph.
    
    ![[attachments/Untitled 16 50.png|Untitled 16 50.png]]
    
- To simplify this, we can make two assumptions on models to imply a one-to-one relationship between constant symbols (syntax) and objects (semantics).
    
    ![[attachments/Untitled 17 47.png|Untitled 17 47.png]]
    

## Propositionalization

- Because of the one-to-one mapping between **constant symbols** and **objects**, first-order logic can be translated into propositional logic.
- We can think of each FOL atomic formula like `Student(alice)` as a propositional symbol

![[attachments/Untitled 18 45.png|Untitled 18 45.png]]

- We can use **any inference algorithm for propositional logic** on FOL if we translate it

## Definite and Horn Clauses

![[attachments/Untitled 19 42.png|Untitled 19 42.png]]

![[attachments/Untitled 20 41.png|Untitled 20 41.png]]

## Substitution and Unificiation

- Substitution maps variables (e.g. x, y, z) to terms (e.g. alice, bob)
    
    ![[attachments/Untitled 21 38.png|Untitled 21 38.png]]
    
- Unification takes two formulas $f$﻿ and $g$﻿ and returns the most general substitute $\theta$﻿ that makes $f$﻿ and $g$﻿ equal.
    
    ![[attachments/Untitled 22 34.png|Untitled 22 34.png]]
    
    - Notice that `alice, y` and `bob, z` fails because we can only map variables to terms, not terms to terms.

## Modus ponens

![[attachments/Untitled 23 31.png|Untitled 23 31.png]]

![[attachments/Untitled 24 29.png|Untitled 24 29.png]]

- `Unify` identifies the appropriate substitution, so that it can generate the conclusion $b'$﻿.

## Example

- We bind $x, y, z$﻿ to appropriate objects (constant symbols), which is used to generate the conclusion `Knows(alice, mdp)`

![[attachments/Untitled 25 26.png|Untitled 25 26.png]]

## Time complexity

- There can be exponential or an infinite number of possible atomic formulas.

![[attachments/Untitled 26 23.png|Untitled 26 23.png]]

## Completeness

![[attachments/Untitled 27 21.png|Untitled 27 21.png]]

## Semi-decidability

![[attachments/Untitled 28 19.png|Untitled 28 19.png]]

- If a formula is entailed, then we will be able to derive it
- If it is not entailed, then we don’t even know when to stop the algorithm

# Summary

## Ingredients of Logic

![[attachments/Untitled 29 18.png|Untitled 29 18.png]]

## Inference Algorithms

![[attachments/Untitled 30 18.png|Untitled 30 18.png]]

- A knowledge base is a set of **formulas we know to be true**. Semantically the KB represents the conjunction of the formulas.
- The central goal of logic is **inference**: to figure out whether a query formula is entailed by, contradictory with, or contingent on the KB (these are semantic notions defined by the interpretation function).
- We can perform **inference directly on syntax** by applying inference rules, rather than always appealing to semantics (and performing model checking there).
- We would like the inference algorithm to be both **sound** (not derive any false formulas) and **complete** (derive all true formulas). Soundness is easy to check, completeness is harder.

## Formulas

![[attachments/Untitled 31 16.png|Untitled 31 16.png]]

## Tradeoffds

![[attachments/Untitled 32 16.png|Untitled 32 16.png]]

## FOL and Propositional logic

![[attachments/Untitled 33 16.png|Untitled 33 16.png]]

- When there is a one-to-one mapping between constant symbols and objects, we can propositionalize, thereby converting first-order logic into propositional logic.
- Variables in first-order logic are different from variables in variable-based models (CSPs).
    - CSP variables correspond to atomic formula and denote truth values (known or unknown)
    - First-order logic variables denote objects (e.g. a person in “people in a class”)