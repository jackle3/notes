## Lecture 1: Introduction

### Goals

* Master accurate model of address space
* Translate C to assembly

### History

* Make writing Unix (the OS) and tools for Unix easier
* Design principles:
	* Simple
	* Minimalist
	* More concerned with efficiency and minimalism than safety or abstraction

### C Demo

* Below is a simple hello world program

```c
#include<stdio.h>
#include<stdlib.h>

// argc is number of command line args
// argv is the character string

int main(int argc, char **argv) {
    for (int i = 0; i < argc; i++) {
        printf("Hello, World! %c\n", argv[i]);
    }
}

// c doesn't have print, only printf
```

* To compile, you use make.
* To debug, use gdb.

```bash
# File name is hello.c

# Compiling
make hello

# Running program
./hello
# prints "Hello, World! ./hello"

./hello "My name is Chris"
# prints "Hello, World! My name is Chris"
```

### Logistics

* Lab sign up is Jan 10th, 10 am.
	* https://cs107.stanford.edu/labs
* Midterm is Feb 15th, evening
* Final Exam is Mar 24th, 8:30 am to 11:30 am

### Assignment 0

* https://web.stanford.edu/class/cs107/assign0/

### Bits and Bytes Introduction

* One bit only has two states (on/off).

* If we want more states, we simply combine bits together.

* Using bits, we can encode anything we want.

* To convert decimal to binary

	* Divide by two. Find remainder of the division. Remainder is the rightmost bit.
```
    Convert 84 to binary.
    
    84/2 = 42 -> rem 0
    42/2 = 21 -> rem 0
    21/2 = 10 -> rem 1
    10/2 = 5 -> rem 0
    5/2 = 2 -> rem 1
    2/2 = 1 -> rem 0
    1/2 = 0 -> rem 1
    
    Binary of 84 is 1010100
```

### Number Representations

* Unsigned Integers: positive integers and zero one
* Signed Integers: negative, positive, and zero integers
	* Represented in two's complement
* Floating point numbers: a base-2 representation of scientific notation, for real numbers

![image-20230220113955335](attachments/cs107.assets/image-20230220113955335.png)

* Pic above is integer overflow. Can't represent that big of a number in an int.
* The **C int** type is 32-bit, meaning it uses 32 digits. We can represent up to $2^{32}$.
	* Ints are singed. Largest positive number is $2^{31} - 1$.

### Information Storage

* Everything can be thought of as a block of 8 bits, called a byte.

![image-20230220114027605](attachments/cs107.assets/image-20230220114027605.png)

* You can't address a bit. You must address at the byte level
* Hexadecimal often used because binary can be too long to write out bytes, and decimal isn't numerically friendly for byte representation

![image-20230220114048959](attachments/cs107.assets/image-20230220114048959.png)

* Converting from hex to binary is just 4 digit binary chunks from the chart above.
	* ex. "4F3A" is "0100 1111 0011 1010"
* You can reverse process to get binary to hex. Go from right to left to get each hex code.
	* ex. "11 1100 1010 1101 1011 0011" is "3CADB3"
* You can convert decimal to hex in the same way as binary, just divide by 16 now.

### Printing

* Binary is 0b, `printf("%b\n", 0b1010)`
* Hexadecimal is 0x, `printf("%x\n", 0x20)`
* Octal is 0

---

## Lecture 2: Int and Bits/Bytes

* Office hours are now available

### Integer Representations

* The `int` datatype is a 32-bit number.

* Unsigned: only represent non-negative numbers

	* Decimal representation is directly related to binary representation.
	* If you have a 4-bit number, there are 16 possible numbers (0 to 15)

	* Range of unsigned integer is 0 to $2^w-1$, where $w$ is the number of bits.

* Signed: can represent negative, zero, and pos numbers
	* Signed numbers store data in two's complement.
	* Positive numbers are represented as themselves in binary.
	* Negative numbers are the two's complement of themselves.

### Two's Complement
![image-20230220114118466](attachments/cs107.assets/image-20230220114118466.png)

* A negative number in two's complement is obtained by inverting all the bits of its positive counterpart, and then add 1. Works the same the other way.
* **Trick: Going from the right in the binary representation, write down numbers until you get to a 1. Then, invert the rest of the digits.**
* Properties:
	* There is only one zero
	* The highest order bit (leftmost) is 1 for negative, 0 for positive
	* Adding two numbers is just adding the two's complement.
	* Subtracting is just changing the second number to two's complement and adding.
	* Multiplying is just multiplying the two's complements and throwing away overflow digits.
	* If you have get more bits after arithmetic than you have space, throw away the extra bits.
	* E.g. (-3) + (-4) = 1101 + 1100 = 11001 = 1001
		* Throw away the 5th bit

### Casting and Printing

* When casting, the underlying bits do not change. The variable is just being treated as the type that it is cast to.
* You can't convert a signed number to its unsigned counterpart using cast.

![image-20230220114228102](attachments/cs107.assets/image-20230220114228102.png)

* `printf` has three 32-bit integer representations:
	* `%d`: signed 32-bit int
	* `%u`: unsigned 32-bit int
	* `$x`: hex 32-bit int

![image-20230220114236506](attachments/cs107.assets/image-20230220114236506.png)

### Comparison

* If a operation has both a signed and a unsigned value, **C implicitly casts the signed argument to unsigned** and assumes both numbers are non-negative.

![image-20230220114258289](attachments/cs107.assets/image-20230220114258289.png)

* Note: In C, 0 is false and everything else is true. C will always choose 1 to represent true, but every number besides 0 is also true.

### Min and Max

* Use the `sizeof` operator to find how many bytes each type uses.

![image-20230220114318997](attachments/cs107.assets/image-20230220114318997.png)

* Each data type has maximum and minimum values, defined in `limits.h`

![image-20230220114331225](attachments/cs107.assets/image-20230220114331225.png)

### Expanding Bit Representation

* You can convert between integers of different sizes.
	* `short` to `int`, `int` to `long`
	* You can always convert a smaller type to a bigger type.
	* You might not be able to convert bigger type to smaller type.
* For unsigned values, it simply adds leading zeros to the representation (called "zero extension")

```c
unsigned short s = 4;
// s = 0000 0000 0000 0100b

unsigned int i = s;
// i = 0000 0000 0000 0000 0000 0000 0000 0100b
```

* For signed values, we perform a "sign extension" by repeating the sign of the value for the new digits.

``` c
short s = 4;
// s = 0000 0000 0000 0100b

int i = s;
// i = 0000 0000 0000 0000 0000 0000 0000 0100b

short s = -4;
// s = 1111 1111 1111 1100b

int i = s;
// i = 1111 1111 1111 1111 1111 1111 1111 1100b
```

* If we cast from a bigger data type to a smaller data type, C **truncates** the number.

```c
int x = 53191;
short sx = (short) x;
int y = sx; // y = -12345
```

![image-20230220114405032](attachments/cs107.assets/image-20230220114405032.png)

* This also affects unsigned integers, including with addition.

```c
#include<stdio.h>
#include<stdlib.h>
#include<limits.h> // for UINT_MAX
int main() {
    unsigned int a = UINT_MAX;
    unsigned int b = 1;
    unsigned int c = a + b;
    printf("a = %u\n",a); // a = 4294967295
    printf("b = %u\n",b); // b = 1
    printf("a + b = %u\n",c); // a + b = 0
    return 0;
}
```

### Data Sizes

* Below is a table showing how many bytes each data type is for 32-bit and 64-bit machines.

![image-20230220114417835](attachments/cs107.assets/image-20230220114417835.png)

### Addressing and Byte Ordering

* All pointers on the myth machines are 8 bytes, or 64-bits long. A program can "address" up to $2^{64}$ bytes of memory, because each byte is individually addressable.

* An `int` is 4 bytes long. We can represent `int` as a 8-digit hex number: `0x01234567`.

	* We can separate out the bytes: `01`, `23`, `45`, `67`.

	![image-20230220114437270](attachments/cs107.assets/image-20230220114437270.png)

* Some machines store the bytes **ordered from least significant byte** to most significant byte, called “little endian” (because the “little end” comes first).

	* They put the least significant byte first in memory.

* Other machines store the bytes **ordered from most significant byte** to least significant byte, called “big endian” (because the “big end” comes first).

	* They put the most significant byte first in memory.

![image-20230220114453274](attachments/cs107.assets/image-20230220114453274.png)

### Boolean Algebra

* Below shows the symbols and bitwise operators. The table below is truth tables.

![image-20230220114458918](attachments/cs107.assets/image-20230220114458918.png)

* Bitwise operators: `~` for NOT, `&` for AND, `|` for OR, and `^` for "exclusive or," which means that if one and only one of the values is true, the expression is true.
	* Bitwise operators are not the same as logical. Uses single character representations for AND and OR

![image-20230220114604919](attachments/cs107.assets/image-20230220114604919.png)

* We can represent finite sets with bit vectors and perform set functions like union, intersection, and complement.

![image-20230220114557645](attachments/cs107.assets/image-20230220114557645.png)

### Bit Masking

* Take a number, and cut out a part of the number (masking out the remaining values).
	* A mask is a bit pattern that will be used to choose a selected set of bits in a word
* E.g. the mask `0xFF` means getting the lowest byte in an integer.

```c
int j = 0x89ABCDEF;
int k = j & 0xFF;
// k now holds the value 0xEF,
// which is the low-order byte of j

// 000000FF &
// 89ABCDEF
// --------
// 000000EF
```

* E.g. `~0` makes an integer with all 1s, regardless of the size
* E.g. making the least significant byte all ones, and all other bytes of the number unchanged.

```c
int j = 0x87654321;
int k = j | 0xFF;
// k now holds the value 0x876543FF
```

* E.g. complements all but the least significant byte, with the least significant byte unchanged.

```c
int j = 0x87654321;
int k = j ^ ~0xFF;
// ~0xFF is 0xFFFFFF00 for 8-bit
// k now holds the value 0x789ABC21,
// which is the complement
```

### Shift Operations

* Shifts bit patterns to the left and to the right
* `x << k` will shift `x` to the left by `k` number of bits.
* `<<` replaces the lower order bits with zeros as it moves bits to the left.

![image-20230220114622058](attachments/cs107.assets/image-20230220114622058.png)

* `>>` there are two types of right shift

![image-20230220114637300](attachments/cs107.assets/image-20230220114637300.png)

![image-20230220114645880](attachments/cs107.assets/image-20230220114645880.png)

---

## Lecture 3: Chars and C-Strings

### C's Char Type

* `char` is a 1-byte value
* chars are signed, although we usually use 0 to 127
* chars are numbers, but they are used to store data about characters

### Ctype Library

* A useful library for chars

* The functions are `int` instead of `char`, so we can represent the full unsigned char range (0 to 255) plus the special EOF, which is often represented by $-1$

* Type `man function` to find more about ctype functions

	![image-20230220114731567](attachments/cs107.assets/image-20230220114731567.png)

* For these functions, we get a nonzero value if the character falls into the tested class, and zero if not.

	* Zero for false, nonzero for true

### C Strings

* Simply a sequence of `chars`, following by a terminating 0 (called a "null" byte)

* To create string, use `char *`. For example, `char *s = "hello";`

	* This would just be a pointer. It won't allow us to modify characters. However, what we can do is to do

	```c
    char *s2 = "hello"; // can’t change letters, can change where s2 points:
    // no: s2[0] = ‘b’, yes: s2 = s1
    
    //PREFERRED CONSTRUCTION:
    char s4[100]; // can change letters/content, not where s4 points:
    strncpy(s4, s2, strlen(s2)+1); // similar to saying s4 = s2
    ```

* Strings are referenced by a **pointer** to its first character, or by an array variable
	* Array variable is converted to a pointer when we need to access the elements

![image-20230220114817979](attachments/cs107.assets/image-20230220114817979.png)

* You can't compare strings by their pointer values.

	* The pointers are just numbers, pointing to the first character.
	* Doesn't compare string, just compares the memory address.

* Assigning string pointer to another string pointer does not make a copy. They both point to the same thing.

	![image-20230220114833585](attachments/cs107.assets/image-20230220114833585.png)

### The String Library

* The library `<string.h>` is a very important library.
* Need to be familiar with the library functions. Do not rewrite these functions unless asked to explicitly.
* String library functions all have a worse-case complexity of $O(n)$.

#### Strlen

* Calculates and returns the length of the string. The prototype is ==`size_t strlen(const char *str)`.==
	* `size_t` is just an unsigned long.
	* `const` means this function will not change our string.
* `strlen("cs107")` will return 5, the length of the string.
* Works by walking through characters of the string until it reaches the null byte.

#### Strcmp

* Compares two strings, character-by-character.
* Returns $0$ for identical strings.
* Returns $< 0$ if s is before t in the alphabet.
* Returns $> 0$ if s is after t in the alphabet.
* It compares the ASCII values. `48` is `0`, `65` is `A`, `97` is `a`.
* Prototype is==`int strcmp(const char *s, const char *t);`==

#### Strncmp

* Does same comparison but stops after $n$ characters.
* It doesn't traverse past null characters. Behaves exactly like `strcmp` if `n` is greater than the length.
* Prototype is ==`int strncmp(const char *s, const char *t, size_t n);`==
* Shorter strings but otherwise same are considered less.
	* E.g. "cat" is less than "cats"

#### Strchr

* Returns a pointer to the first occurrence of a character in s.

* Returns NULL if character is not in string.

	![image-20230220115016809](attachments/cs107.assets/image-20230220115016809.png)

* You can do pointer arithmetic with the pointers, to find how many characters after the beginning of the string a certain character is.

#### Strstr

* Locate a substring.

* Returns a pointer to the first occurrence of needle (the substring) in the haystack (the string).

	* Pointer will be from the haystack, not the needle.

* Returns NULL if the substring does not exist.

	![image-20230220115026734](attachments/cs107.assets/image-20230220115026734.png)

#### Strcpy

* Copies src to dst, including the null byte.

* The caller is responsible for ensuring there is enough space in dst to hold the entire copy.

	* Create an array of a certain size, and copy the string into that array.
	* If we for example just had `char *wordcopy`, this is just a pointer pointing at a random place in memory. We don't know if there's enough space at that memory to hold our word.

* The strings may not overlap.

* Returns a pointer to the destination. Essentially just returns `char *dst`.

	![image-20230220115035312](attachments/cs107.assets/image-20230220115035312.png)

#### Strncpy

* Similar to strcpy, except that at most n bytes will be copied.

* If there is no null byte in the first n bytes of src, then dst will not be null-terminated.

	![image-20230220115042460](attachments/cs107.assets/image-20230220115042460.png)

* You have to manually put the null byte in.

#### Strcat and Strncat

* Concatenate two strings by appending src onto the end of dst.
* strncat only copies up to n bytes, and dst is always null-terminated, which adds an extra byte.

![image-20230220115049501](attachments/cs107.assets/image-20230220115049501.png)

![image-20230220115110512](attachments/cs107.assets/image-20230220115110512.png)

#### Strspn

Calculates and returns the length in bytes of the initial part of s which contains only characters in accept.

![image-20230220115120881](attachments/cs107.assets/image-20230220115120881.png)

#### Strcspn

Similar to strspn, except returns length in bytes of initial part of s that does not contain any characters in reject.

![image-20230220115126091](attachments/cs107.assets/image-20230220115126091.png)

#### Strdup

* Returns a pointer to a **heap-allocated** string which is a copy of s.
* Like strcopy, but allocates space for you.
* It is the responsibility of the caller to free the pointer.

![image-20230220115142492](attachments/cs107.assets/image-20230220115142492.png)

#### Strndup

* Like strdup
* Only copies up to n bytes. Resulting string will be null-terminated.

![image-20230220115146546](attachments/cs107.assets/image-20230220115146546.png)

* Both functions require you to free the copy when it is no longer needed. Otherwise there's a memory leak.

### String Function Summary

![image-20230220115210848](attachments/cs107.assets/image-20230220115210848.png)

### Examples

Write a 1-line boolean expression involving a valid `string (char*) s` for the following:

* s contains the substring "107"

	* `strstr(s, "cs107") != NULL`
	* Find substring. It returns  pointer. Check if that pointer is not null, bc if its not null then "107" exists in s.

* s is the empty string

	* `s[0] == '\0'`
	* `strlen(s) == 0`
	* If the first character is null terminator, the string is empty.

* s is equal to the string t

	* `strcmp(s, t) == 0`

* s does not contain '#'

	* `strchr(s, '#') == NULL`

* s is the same length as the string t

	* `strlen(s) == strlen(t)`

* s's second character is the same as the string t's third (assume both strings have enough characters)

	* `s[1] == t[2]`

* s is a prefix of t (assume t is much, much longer)

	* `strstr(t, s) == t`
	* `strncmp(s, t, strlen(s))`

* (hard) the first 5 characters of s are digits (0-9)

	* `strspn(s, "0123456789") >= 5`

* Find index of first character

	```c
  char buf[9]; strcpy(buf, “arillaga”);
  char *first_r = strchr(buf, ‘r’);
  int index = first_r - buf;
  ```

* Get pointer to first instance of substring

	```c
  char *where_llaga = strstr(“arrillaga”, “llaga”);
  ```

## Lecture 4: Arrays and Pointers

### Pointers

* A pointer is a memory address.

	* On myth machines, all pointers are 64-bits, or 8-bytes long (unsigned long).

	![image-20230220121850721](attachments/cs107.assets/image-20230220121850721.png)

* To print pointer, use `%p` in printf.

* Pointers are all 64 bits. You can specify the type that the pointer is pointing to.

	* `int *xptr` is a pointer to an integer.
	* `char *cptr` is a pointer to a character.

* `&x` means address of `x`.

### Pointers to Pointers

* This gives us the address of a pointer.

	![image-20230220121859964](attachments/cs107.assets/image-20230220121859964.png)

* Generally pointers to pointers are used if you need to modify a pointer.

### Why Pointers

* Pointers are used as references to values
* Lets us write functions that can modify and use values that are created elsewhere in the program, without having to make a copy.
* Pointers allow us to reserve new memory.
* Pointers to pointers allow us to refer a particular element in an array generically.

### Arrays

* Contiguous blocks of memory with a fixed length.
* Can access using bracket notation (`arr[2]`) or with pointer arithmetic (`*(arr + 2)`).
* Arrays are not pointers. You can't change what an array points to.

![image-20230220130738620](attachments/cs107.assets/image-20230220130738620.png)

* Shorts are two bytes. That's why each address is offset by 2 bytes each time.
* `int nelemes = 12 / 2` -> the array takes up 12 bytes. You divide that by the size of the values, to get the number of elements.

* Arrays are not pointers

![image-20230220130803840](attachments/cs107.assets/image-20230220130803840.png)

#### Arrays Can Decay to Pointers

* You can assign array addresses to pointers.

![image-20230220130814041](attachments/cs107.assets/image-20230220130814041.png)

* A pointer to an array points to the first element in the array.

	* We can use pointer arithmetic or bracket notation to access elements.

* To modify elements in the array, we can do it in two ways.

	* `arr[2] = 42` or `*(arr+2) = 42`. This will change the element `7` to `42`.

* The compiler knows the width of the type, so `arrptr++` will move according to the type.

	![image-20230220130851539](attachments/cs107.assets/image-20230220130851539.png)

* There's nothing to determine the end of an array.

![image-20230220130921833](attachments/cs107.assets/image-20230220130921833.png)

* What does `*arrptr++` mean?

	* It does not mean "add one to the value that `arrptr` points to".

	* To do that, we write `(*arrptr)++`

#### Arrays Decay in Functions

* You lose the ability to determine the size using `sizeof` if the array decays into a pointer.

* Every time you pass an array into a function, it becomes a pointer.

	* If you do `sizeof` now, you just get the size of the pointer, not the array
	* `void func(int arr[])` is the same as `void func(int *arr)`
	* This means the array will decay to a pointer when you pass it in.
	* If you want to keep track of the size of an array in a function, pass through another parameter to denote the size of the array.

#### Arrays Are Passed by Reference

* Arrays are passed by reference when used as arguments in a function.

	* This is because the array variable decays to a pointer, which is just an address.

	* The function will have access and will be able to modify the array.

	![image-20230220131030839](attachments/cs107.assets/image-20230220131030839.png)

	* Aside: `size_t` is an unsigned long.

* If we want a parameter to not be modifiable, we use `const`

### Memcpy

* This can be used to copy array data. Similar to `strcpy` and `strncpy`

![image-20230220131043026](attachments/cs107.assets/image-20230220131043026.png)

* `void *` means that any pointer can be passed into the `memcpy` function.
* Note that you must specify how many bytes are copied.
* `src` and `dest` must not overlap. If you have overlapping areas, use `memmove`.

![image-20230220131111767](attachments/cs107.assets/image-20230220131111767.png)

* `memcpy` is generally faster than `memmove`

### Memmove

* It is the same as `memcopy`, except `src` and `dest` can overlap.

![image-20230220131117265](attachments/cs107.assets/image-20230220131117265.png)

* Prefer to use this over `memcopy`. If you absolutely need it to be as fast as possible and you know the memory locations don't overlap, then use `memcopy`.

![image-20230220131124675](attachments/cs107.assets/image-20230220131124675.png)

### Declaring Strings

* You can declare a specific string using a ==string literal== in two different ways.

![image-20230220131201152](attachments/cs107.assets/image-20230220131201152.png)

* In first case, the string literal is used to make an array that you can modify.

* In the second case, there is no array, and there is just a pointer to the string literal. This literal is put into read-only memory, so it can't be modified.

	* Trying to modify this can lead to segfault.

### Things to Be Careful about

#### Dereferencing

* Be careful when dereferencing pointers.
* NULL pointers or bad addresses (an address that doesn't point to anything viable) lead to segfaults.

![image-20230220131223515](attachments/cs107.assets/image-20230220131223515.png)

#### Array Bounds

* C does not check for the end of your array. It can lead to a buffer overflow.

![image-20230220131233344](attachments/cs107.assets/image-20230220131233344.png)

### Memory Footprint

![image-20230220131303665](attachments/cs107.assets/image-20230220131303665.png)

![image-20230220131335703](attachments/cs107.assets/image-20230220131335703.png)

* These work because we know the size of elements in the array (they are `ints`)
* As long as we know the size of elements, we can always swap (or compare, etc) two elements in an array.

#### Swap Array of Pointers

![image-20230220131353851](attachments/cs107.assets/image-20230220131353851.png)

![image-20230220131402375](attachments/cs107.assets/image-20230220131402375.png)

* We've just swapped the pointers. We didn't swap any characters.
	* This reorders the order of the array.

## Lecture 5: Stack and Heap

* Reminder: arrays memory addresses are offset based on their types
	* Int arrays have each element 4 bytes apart
	* Char arrays have each element 1 bytes apart
* You can use bracket notation if you a pointer with a type (e.g. `char *`, `int *`, etc)
	* Can't do this `void *`

* Ending from last lecture, our goal is to write a generic swap function.

![image-20230220131520734](attachments/cs107.assets/image-20230220131520734.png)

* This function takes in the width of the type. Then, you can swap anything using that.

### Double Pointers

![image-20230220131615667](attachments/cs107.assets/image-20230220131615667.png)

* In the first example (`nextCharA`), `p++` doesn't change the original pointer `pA` in the calling main function. It just simply moves the local pointer `p` to the next character.

	* `pA` still points to the `h` in the character array.

* All variables in C are passed by value. Therefore, if we want to change a pointer, we need a double pointer.

* In the second example (`nextCharB`), it is passing in the **address** of `pB`.
	* We dereference `p` to get `pB`, then we can get the characters.
	* The line `(*p)++` changes the variable `pB` itself.
	* `h` lives at `0x1234`. `pB` lives at `0x100`. When we go to the address `0x100`, you will find that it has the value `0x1234`.
	* `p` is a pointer pointing at `0x100`, since it is the address of `pB`.
	* When we dereference `p` and add one to it, we go to `0x100` and change the value that it is strong to be `0x1235`, or the next character.
	* Since `pB` is `0x100`, we have changed `pB` itself to be the next character.
* To access elements in a `char **`, we can either do `p[0][0]` or `(*p)[0]`
* **With arrays, always draw a picture**. You can make up the addresses, the picture would just help with understanding.

#### Example: Envp from Assign2

![image-20230220131820687](attachments/cs107.assets/image-20230220131820687.png)

* `char *envp[]` is the same as `char **envp;``
* ``envp` is a double pointer. It's essentially an array of pointers.

* `envp[2]` is the pointer at index 2 in the array.
* The type of `envp[2]` is a `char *`, because its a pointer to a character.

* **Note**: for arguments in main, `argv[argc]` is defined to be NULL. However, this is an anomaly for C arrays in general. Generally you need another variable to know the length of the array.

### x86-64 Memory Layout

* There are two main areas of memory that your program can access.
	* These are called the `stack` and the `heap`

![image-20230220131851723](attachments/cs107.assets/image-20230220131851723.png)

* The diagram above shows the memory layout in linux on an x86-64 computer.

#### Stack

* By default has access to an 8MB stack segment in memory.
* The stack is upside down. It grows downward in memory, so your program starts with a location on the stack and you get the next 8MB lower in memory.
* Stack overflow occurs when you write more memory than the 8MB stack allows.

#### Shared Library

* Located below the stack.
* Contains all the standard libraries used by programs (e.g. stdlib.h, etc)
* Your programs do not have access to these directly, except to call functinos that are there

#### Heap

* Memory managed by the operating system, comprises the vast majority of memory in comupter.
* When a program wants to use heap memory, it requests it from the operating system.
	* In C++, its `new` and `delete`
	* In C, its `malloc`, `calloc`, `realloc`, and `free`
* The heap starts a low memory address and grows upwards.

#### Global Data

* Located below the heap.
* Contains global variables and string literals.

### Stack Allocation

* When a function creates a local variable or when a function receives parameters, the data is either kept in registers or kept on the stack.
	* For now, assume that all local variables go on the stack.
* Arrays are also kept on the stack.

#### Example Program

![image-20230220132042815](attachments/cs107.assets/image-20230220132042815.png)

* If we look at the memory addresses through gdb, we can see their location on the stack.
* ./cs107.assets/Notice that the location of the stuff itself doesn't matter too much, its just that it goes on the stack.
* The last command prints out the memory byte by byte
* It prints out 30 bytes worth of memory starting at the address of `a`
* Notice the one at `0x…968`, we see `0x45` then `0x23` then `0x01`. However, we know that `a` is `0x12345`. This is because the myth machines are little endian, so it stores it backwards.

### Stack Frames

* Every time you call a function, the data for the current function needs to be saved.
	* In x86, a function just uses memory farther down the stack, and leaves the part of the stack that the calling function was using unchanged.

![image-20230220132137549](attachments/cs107.assets/image-20230220132137549.png)

* When we leave a function, we remove the stack frame (in reality it just becomes garbage, doesn't get erased instantly) and move up.
	* Essentially, the stack frame is popped from the stack.

![image-20230220132143548](attachments/cs107.assets/image-20230220132143548.png)

* This is why recursive functions tend to stack overflow, because each call is a new stack frame.

#### Parameter Passing

* Parameters can also be put onto the stack, and they behave just like local variables.

![image-20230220132156516](attachments/cs107.assets/image-20230220132156516.png)

* These parameters might actually point to other elements on the stack.
	* In this example, `colors` points to the `values` array.
	* Non-pointers are just copied over (e.g. `nelems`)

#### Why Do We like Stack Allocation?

* It is fast.
	* Allocating space in the stack is efficient because the program already has access to the memory.
* It is convenient.
	* When you leave a function, all the stack-allocated data is left in place and there isn't anything to clean up.
	* The scope (lifetime) of this data is inside the function, so it keeps things tidy.
* Type safety.
	* You are controlling the type of variables, and therefore the complier can do a lot of checks on the data.
	* Isn't always the case if you use heap memory.

#### Why We Dislike Stack Allocation

* We have limited memory.
	* Only 8MB. If your program needs more space, you can't get it from the stack.
* Size is fixed at declaration, with no option to resize.
	* You can't resize an array once you allocate it. It's there for the lifetime of your function or block.
* Limited scope.
	* Once the function or block is finished, the stack-based memory is gone.
	* You can't return a pointer to a stack array or any local variable.

### Dynamic Allocation

* In C++, we used `new` and `delete` to request memory for arrays and objects.
* In C, we can request memory from the heap using `malloc`, `calloc`, `realloc`. We return the memory to the operating system using `free`.

#### Malloc

* The most common method for requesting memory from the heap.
* Used to allocate a specified number of bytes.
* The memory is not zeroed.
	* Caveat: new memory that your process has not used before will be zeroed for security reasons.
	* However, if the OS re-issues you memory, it won't be zeroed.

![image-20230220132214059](attachments/cs107.assets/image-20230220132214059.png)

* Size is always in bytes, so often you need to calculate the number of bytes with `sizeof` and multiplication.
* `malloc` returns a `void *` pointer, which basically means you can assign the return value to any pointer.

![image-20230220132226825](attachments/cs107.assets/image-20230220132226825.png)

* The complier knows its an int array because we put it into an `int *`.
* If `malloc` returns `NULL`, there wasn't enough memory for the request.
	* As a contingency, every time after you use `malloc`, you should check if its null. If it is null, simply crash the program.

#### Calloc

* Similar to malloc, but takes two parameters which are multiplied to calculate the number of bytes.
* It also zeros the memory for you.

![image-20230220132235897](attachments/cs107.assets/image-20230220132235897.png)

* `nmemb * size` will be how many bytes it allocates for you.
* The following statements are equivalent:

![image-20230220132241306](attachments/cs107.assets/image-20230220132241306.png)

* The for-loop with malloc is slower because calloc is highly optimized to zero out memory.

#### Realloc

* Can be used to (potentially) change the size of the memory block pointed to by its pointer.

![image-20230220132247803](attachments/cs107.assets/image-20230220132247803.png)

* Returns a pointer to the memory block.
	* Often will be the same pointer you pass in as `ptr`
	* If it needs to move the data, it moves it for you, then frees the old memory using `free`, then passes back a different pointer.
* If the request fails, it returns `NULL`, but the original memory is not affected.
	* That is, your original pointer is still valid.

![image-20230220132255274](attachments/cs107.assets/image-20230220132255274.png)

#### Free

* Used to return memory to the operating system.
* When you use malloc, calloc, and realloc, the function is responsible for returning the memory to the operating system when it is no longer needed.
	* Un-returned memory is called a memory leak, and wastes memory.

![image-20230220132306672](attachments/cs107.assets/image-20230220132306672.png)

* In the following, we are not doing anything to the pointer `x`. We are just telling the operating system that we will no longer use the memory that `x` currently points to.
	* It doesn't delete the memory, and we can still use `x` to point at something else.

```c
char *x = malloc(50);
// ... code goes here
free(x);
```

* You can't `free` the same allocated memory twice.

---

## Lecture 6: Heap and Void *

### More On Heap Allocation

![image-20230220132338031](attachments/cs107.assets/image-20230220132338031.png)

#### Why Do We like Heap Allocation?

* It is plentiful.
	* You can request a lot of heap memory if your program needs it.
* Allocation and deallocation are under the program's control
	* You can precisely determine the lifetime of a block of memory
* You can resize the memory
	* You can use realloc to resize a block.

#### Why Don't We like Heap Allocation?

* Only moderately efficient
	* The OS needs to be involved, and it needs to search for available space and update its records, etc
* Low type safety
	* You only get a void * pointer back, limits ability to provide compiler warnings
* Memory management is tricky
	* Need to remember to initialize, keep track of bytes, and free
* Leaks possible
	* Causes programs to waste memory

#### Choose between Stack and Heap Allocation

![image-20230220132351629](attachments/cs107.assets/image-20230220132351629.png)

* An example of dynamic construction would be like readline. You don't know the size of the line beforehand

### Generic Pointer

* The `void *` pointer is a pointer that has an unspecified pointee type.

* It is a pointer, but does not have a width associated with the underlying data based on some type.

	* E.g. if you have an array and ur at the first element, the complier does not know how to get to the next element bc there isn't a width for the types

* You can pass `void *` pointers to and and from functions, and you can assign them values with the `&` operator.

	![image-20230220132405887](attachments/cs107.assets/image-20230220132405887.png)

	* You can assign `void *` pointers to a pointer with a type to let it know the width.

* You can't dereference a `void *`, nor can you use pointer arithmetic.

![image-20230220132414680](attachments/cs107.assets/image-20230220132414680.png)

#### Why Do We Use Void *?

* Even though the `void *` loses function, we use it if a function needs to be generic so it can deal with any type.
* We see this with `free` and `realloc`
	* `void free(void *ptr);`

#### Swap Elements

* Suppose we wanted to write a function to swap the first and last element of a generic array.

![image-20230220132429110](attachments/cs107.assets/image-20230220132429110.png)

* We can use `void *` and explicitly include the width of the type.

	* Notice that the width is passed through, and we use `memmove` to copy the elements.
	* In the example above, we use `char` as a stand-in for a 1-byte type. So we first create an array that is `width` in length to store the copy.
	* In the third line, notice that we cast it to `char *` in order to dereference it as a 1-byte type array. Then, we add the number of bytes to get to the last location.
	* Gets us address of the place we want to start copy from.

#### Getting Ith Element in Array Idiom

![image-20230220132538254](attachments/cs107.assets/image-20230220132538254.png)

### More about `void *`

* We can't dereference in a generic way. However, suppose we wanted to write a function to print arrays generically.

![image-20230220132628767](attachments/cs107.assets/image-20230220132628767.png)

* The issue is that `printf` requires you to have a type. We don't know what the type of the elements in `arr` is, so we don't know how to format them to print.

* The calling function can tell us how to print the elements in the array!

### Function Pointers

* We can pass `function pointers` as parameters to other functions.
	* This tells the other function to run this function on the element when you get to it.

![image-20230220132705457](attachments/cs107.assets/image-20230220132705457.png)

* You can use `cdecl` on Myth (or cdecl.org) to explain the code.

![image-20230220132710890](attachments/cs107.assets/image-20230220132710890.png)

* Look back at our `printf` example.

![image-20230220132732399](attachments/cs107.assets/image-20230220132732399.png)

* Notice that we replace the `printf` with our function pointer.
* The calling function provides the function pointer, and the function pointer is specific to the type of data stored in the array.
* We can write multiple functions to print each type.

![image-20230220132747253](attachments/cs107.assets/image-20230220132747253.png)

* Our function pointer in `print_array` is expecting a function that takes a `void *`, so we need our `print_int` function to take the `void *`.

### Qsort

![image-20230220132828662](attachments/cs107.assets/image-20230220132828662.png)

* Given a pointer to the base of some array, it sorts the array. This is a generic function.
* Notice that you need to give it a comparison function. You pass it as a comparison function.

![image-20230220132839332](attachments/cs107.assets/image-20230220132839332.png)

* We are given a `char **`. Therefore, to use `strcmp`, we need to cast the `void *` to a `char **`, then we dereference it to get a `char *`.

### Function Pointer Takeaways

![image-20230220132908409](attachments/cs107.assets/image-20230220132908409.png)

## Lecture 7: Void *, Generic Stack

### Structs

* A way to group several related variables together in one place.
* Can contain many different data types.

```c
struct MyStructure {
    int myNum;
    char myLetter;
}

int main() {
    // Create a structure variable of myStructure called s1
    struct MyStructure s1;

    // Assign values to members of s1
    s1.myNum = 13;
    s1.myLetter = 'B';

    return 0;
}
```

* You can use `typedef` to avoid having to type `struct` before it every time.

```c
typedef struct MyStructure {
    int myNum;
    char myLetter;
} MyStructure;

int main() {
    // Create a structure variable of myStructure called s1
    MyStructure s1;

    // Assign values to members of s1
    s1.myNum = 13;
    s1.myLetter = 'B';

    return 0;
}
```

### Qsort with an Array of Structs

![image-20230220133007413](attachments/cs107.assets/image-20230220133007413.png)

* The arrow is the same as `*(r1ptr).width`

![image-20230220133013614](attachments/cs107.assets/image-20230220133013614.png)

![image-20230220133026565](attachments/cs107.assets/image-20230220133026565.png)

![image-20230220133036539](attachments/cs107.assets/image-20230220133036539.png)

* Note that we are unable to check the type of a pointer.
	* The `void *` pointer passed into rect_comp_area, we have no way of knowing that it is a rectangle except just assume.

### Building a Generic Stack

* A stack is a last-in-first-out data structure.
* The push operation adds an element
* The pop operation removes an element.
* Note: You can use assert to crash the program if you encounter a result you shouldn't have (ie. a pointer that is null)
* We will be building our stack as a linked list.

1. We start by defining a node that will hold a pointer to a "next" node, and some data.

	 * Don't know anything about the type of data, although the stack will know its width.

	 ```c
   typedef struct node {
       struct node *next;
       void *data; // it's generic so we use void *
   } node;
   ```

2. We now build our stack type.

	 * It will have a defined width of the type for each node.
	 * Since it's a defined width, all elements pushed to the stack must have that same width.
	 * It also needs to keep track of how many elements it has.
	 * It also needs to keep track of the top of the stack, so it can quickly pop and push.

	 ```c
   typdef struct stack {
       int elem_size_bytes; // the size of the type
       int nelems;
       node *top;
   } stack;
   ```

3. We now need a function to create our stack.

	 ```c
   // We could do it manually
   stack s1;
   s1.elem_size_bytes = sizeof(int); // stores ints
   s1.nelems = 0;
   s1.top = NULL;
   ```

	 ```c
   // We could use a function that returns our stack
   stack *stack_create(int elem_size_bytes) {
       // we put our stack on the heap so we can
       // return the pointer to it
       stack *s = malloc(sizeof(stack));
       // crashes program if malloc failed
       assert(s != NULL);
       // set the initial conditions
       s->elem_size_bytes = elem_size_bytes;
       s->nelemes = 0;
       s->top = NULL;
       // return the pointer to the heap memory
       // that we just initialized
       return s;
   }
   ```

	 * The stack must have a set width (the size in bytes of the elements in it)

4. We also need a function to push elements into the stack.

	 ```c
   // push data onto the top of the stack
   void stack_push(stack *s, const void *data) {
       // create a new node for the element
       // remember that the stack is a linked list
       node *new_node = malloc(sizeof(node));
       assert(new_node != NULL);
       
       // the data was a void *, so we create space for it
       new_node->data = malloc(s->elem_size_bytes);
       assert(new_node->data != NULL);
       
       // copy the memory from the data into our space
       memcpy(new_node->data, data, s->elem_size_bytes);
       
       // append new_node to the front of the linked list
       new_node->next = s->top;
   	// update the front of the linekd list
       s->top = new_node;
       // update the size of the stack
       s->nelems++;
   }
   ```

	 * We make a copy because we don't want to change the original data.

5. We also need a pop function.

	 ```c
   // will return true of item popped, false if not
   bool stack_pop(stack *s, void *addr) {
       // takes in the stack's pointer, also need a
       // place to copy data back to
       
       // return false if empty stack
       if (s->nelems == 0) {
           return false;
       }
       
       // create a reference to top for ease
       node *top = s->top;
       
       // copy data to the passed in pointer
       memcpy(addr, top->data, s->elem_size_bytes);
       
       // rewire
       s->top = top->next;
       s->nelems--;
       
       // free the existing heap memory
       free(top->data);
       free(top);   
       
       // we were able to pop, so return true
       return true;
   }
   ```

6. We now test this in main

	 ```c
   int main(int argc, char **argv) {
       stack *intstack = stack_create(sizeof(int));
       
       // put the values 0 to 9 into stack
       for (int i = 0; i < 10; i++) {
           stack_push(intstack, &i);
       }
       int popped_int;
       while (stack_pop(intstack, &popped_int)) {
           printf("%d\n", popped_int);
       }
       
       // free our stack
       free(intstack);
       
       return 0;
   }
   ```

```c
   int main(int argc, char **argv) {
       // stack points to pointers to chars (strings)
       stack *string_stack = stack_create(sizeof(argv[0]));
       // sizeof(argv[0]) is the same as sizeof(char *)
       
       for (int i = 1; i < argc; i++) {
           // we want to push the entire string, not 
           // string characters
           // we must pass in char * pointers, or char **
           // that is, we are pushing string pointers
           stack_push(string_stack, argv + i);
           // same as below
           // stack_push(string_stack, &argv[i]);
       }
       
       char *next_arg;
       while (stack_pop(string_stack, &next_arg)) {
           printf("%s\n", next_arg);
       }
       
       // free our stack
       free(string_stack);
       
       return 0;
   }
```

---

## Lecture 8: Floating Point Numbers

### Real Numbers

* Irrational real numbers can have infinite length after the decimal point, so we have to find a way to represent it on a computer.

![image-20230220133612889](attachments/cs107.assets/image-20230220133612889.png)

### Fixed Point

* This is one way to represent real numbers.
* It's not what is used on most systems and libraries.

![image-20230220133625629](attachments/cs107.assets/image-20230220133625629.png)

* In the example above, $d_2 = 1, d_1 = 2, d_0 = 3, d_{-1} = 4, d_{-2} = 5$.
* The range of numbers we can represent with this system is $0$ to $999.99$.
* Our maximum precision with this is up to five digits, up to the 100th place (two digits after decimal point, three before)

![image-20230220133706389](attachments/cs107.assets/image-20230220133706389.png)

* One nice thing is that arithmetic with fixed-point is really easy.

![image-20230220133729144](attachments/cs107.assets/image-20230220133729144.png)

#### Issues

![image-20230220133804423](attachments/cs107.assets/image-20230220133804423.png)

### Floating Point

* Represent decimal numbers in a form where the decimal point is "floating" - it can shift around the representation of the number.

![image-20230220133837999](attachments/cs107.assets/image-20230220133837999.png)

* In $V = x \times 2^y$, $x$ is the numerical value of the number itself, and $y$ is the scaling factor

#### Fractional Values in Binary

![image-20230220133855695](attachments/cs107.assets/image-20230220133855695.png)

* E.g. `101.1b` is `5.5f`:  `101b` is `5f`, and `0.1b` is `1 \times 2^{-1} = 0.5f`
* If you shift the decimal point above by one to the left (e.g turn it into $b_1b_0.b_{-1}b_{-2}b_{-3}$), the number gets divided by two.
	* E.g. `101.1b` is `5.5f`, then we have `10.11b` is `2.75f`
* If you shift the decimal point to the right by one, the number is multiplied by two.
* The number $0.11111\dots1b$ is equal to the number just below 1 (similar to 0.999 in decimal)
	* e.g. $0.111111_2 = \frac{63}{64}$

![image-20230220133954472](attachments/cs107.assets/image-20230220133954472.png)

### IEEE Floating Point

* This is a standard for floating point numbers use by almost all computers today.
* Defines the bit pattern (32-bit, 64-bit, etc) as a number in the form.

![image-20230220134021179](attachments/cs107.assets/image-20230220134021179.png)

#### Example

![image-20230220134040636](attachments/cs107.assets/image-20230220134040636.png)

#### Bit Representation

![image-20230220134107290](attachments/cs107.assets/image-20230220134107290.png)

* The diagram above is for a 32-bit number.

### Normalized Floats

* These have a Mantissa that ranges between 1 and $2 - \epsilon$.
* This occurs when the exponent is nonzero.

![image-20230220134156633](attachments/cs107.assets/image-20230220134156633.png)

### Integers

* When is floating point value an integer?

![image-20230220134308243](attachments/cs107.assets/image-20230220134308243.png)

#### Convert Decimal to Floating Point

![image-20230220134417440](attachments/cs107.assets/image-20230220134417440.png)

* The binary representation of `1234567` is `100101101011010000111`.
	* Imagine the decimal point is at the end of this, so we have `100101101011010000111.`
	* We need to figure out how much to shift to get that decimal point in the binary representation for it to be at the front, right after the first 1.
	* Our goal is to make `1.00101101011010000111`
	* If we count this, we see that we need to shift 20 times.
* For the bias we add 127 because we're going from decimal to floating point. Before, when we were going from floating point to decimal, we subtracted 127.

### Denormalized Floats

![image-20230220134457176](attachments/cs107.assets/image-20230220134457176.png)

### Exceptional Floating Point Values

![image-20230220134527771](attachments/cs107.assets/image-20230220134527771.png)

### Arithmetic with Floating Point Numbers

![image-20230220134553512](attachments/cs107.assets/image-20230220134553512.png)

* The above occurs because of floating point arithmetic.

![image-20230220134559506](attachments/cs107.assets/image-20230220134559506.png)

![image-20230220134613259](attachments/cs107.assets/image-20230220134613259.png)

![image-20230220134644898](attachments/cs107.assets/image-20230220134644898.png)

* Our shift for the binary number above is 66 times, which removes a lot of bits since we only have 23 bits to work with. The `3.14` are in these lower bits that get removed.

![image-20230220134701993](attachments/cs107.assets/image-20230220134701993.png)

### Floating Point Precision

![image-20230220134732695](attachments/cs107.assets/image-20230220134732695.png)

* Because of how floating point arithmetic works, $0.1 + 0.2$ is not exactly identical to the floating point representation of $0.3$.

![image-20230220135836735](attachments/cs107.assets/image-20230220135836735.png)

* To actually compare, have some small $\epsilon$ value and check if $abs((0.1 + 0.2) - 0.3) < \epsilon$
	* Basically check with a tolerance.

#### More Examples

![image-20230220135859297](attachments/cs107.assets/image-20230220135859297.png)

* They are the same number in floating point format because the extra bits at the end are truncated.

### Takeaways

![image-20230220135938622](attachments/cs107.assets/image-20230220135938622.png)

![image-20230220135949519](attachments/cs107.assets/image-20230220135949519.png)

---

## Lecture 9: Assembly Part 1

* Assembly code is a textual representation of the machine code giving the instructions to the underlying machine.
* `gcc` is the complier. It compiles assembly code unique to the computer.
* `x86` is a family of assembly code made by Intel. `x86-64` is a 64-bit processor in the x86 family of assembly code.

### Machine-Level Code

![image-20230220140318251](attachments/cs107.assets/image-20230220140318251.png)

* `%rip` holds the address of where in memory the next instruction is going to come from.
* Registers are not in memory. They are much faster than main memory.
	* When a function returns values, it puts that value into a register.

![image-20230220140410074](attachments/cs107.assets/image-20230220140410074.png)

### First Look

![image-20230220140509364](attachments/cs107.assets/image-20230220140509364.png)

* The full assembly code of the file above is over 1000 lines long. Only the important ones are shown.
	* `.LC0` is a label. The label is our string.
	* The two `%rsp` lines are modifying our stack pointer.
	* The instructions that say `mov` are moving things around.
	* E.g. `movl $1, %esi` moves the number 1 into a register.

![image-20230220140526889](attachments/cs107.assets/image-20230220140526889.png)

* To get the assembly code of a function in gdb, use `disas` for disassemble.
* Return values go into `%rax`

### Data Formats

![image-20230220140629551](attachments/cs107.assets/image-20230220140629551.png)

### Accessing Information

* Memory is different than registers.

![image-20230220141116427](attachments/cs107.assets/image-20230220141116427.png)

* In 16-bits, there were 8 registers.
	* ax, bx, cx, and dx are the first four registers
	* si and di are for parameters
	* bp is base pointer for the stack
	* sp is the stack pointer
* In 64 bits, `%r-` means 64-bit
	* `$rax` encompasses `%eax` and `%ax`

![image-20230220141124158](attachments/cs107.assets/image-20230220141124158.png)

![image-20230220141130386](attachments/cs107.assets/image-20230220141130386.png)

![image-20230220141136434](attachments/cs107.assets/image-20230220141136434.png)

#### Nested

* The integer registers are nested.

![image-20230220142309219](attachments/cs107.assets/image-20230220142309219.png)

### General-Purpose Registers

![image-20230223165008604](attachments/cs107.assets/image-20230223165008604.png)

### Special Registers

![image-20230223165028098](attachments/cs107.assets/image-20230223165028098.png)

### Operand Forms

![image-20230220142324107](attachments/cs107.assets/image-20230220142324107.png)

* **Immediate**: for constant values, lieke `$1`, `$0x1A`, or `$-42`
* **Register**: for constant values. Represents the value of the register. Examples: %rax, %edx, %r8d
* **Dereference**: The parentheses $(x_a)$ is the dereference operator.
* **Memory**: for accessing some memory location according to a computed address, often called the effective address. As seen above, there are many different addressing modes to allow different forms of memory references.

* The most important one is the last one, which is the general operand.

![image-20230220142334973](attachments/cs107.assets/image-20230220142334973.png)

* This operand has an immediate value, two registers, and a scaling factor (basically the width of the type)

#### Example

![image-20230220143138489](attachments/cs107.assets/image-20230220143138489.png)

* The memory is on the left, the registers are on the right. They are separate. The registers have values, and the memory also have values.

![image-20230220143234343](attachments/cs107.assets/image-20230220143234343.png)

* `%rax`: directly accessing the register.
* `0x104`: address in memory
* `$0x108`: this gets us the actual number `0x108`
* `(%rax)` is the same as `0(%rax, 0, 1)` in the general form. This is dereferencing.
	* This is equal to `0 + R[%rax] + 0 * 1` = `0 + 0x100 + 0 * 1`
	* The big R is getting us the register value.
	* So now we have look at the thing at the address `0x100`, which contains `0xFF`
* `4(%rax)` is the same as `4(%rax, 0, 1)` in the general form.
	* This is equal to `4 + 0x100 + 0 * 1` = `0x104`.
	* We get the value at address `0x104`.
* `9(%rax, %rdx)` is the same as `9(%rax, %rdx, 1)` in the general form.
	* This is equal to `9 + 0x100 + 0x3` = `0x10C`.
	* We get the value at address `0x104`
* `260(%rcx, %rdx)` is `260 + 0x1 + 0x3` = `0x104 + 0x1 + 0x3` = `0x108`
* `0xFC(, %rcx, 4)` is the same as `0xFC(0, %rcx, r)`
	* This is equal to `0xFC + 0 + R[%rcx] * 4` = `0xFC + 0x1 * 4` = `0xFC + 0x4` = `0x100`

![image-20230223165043577](attachments/cs107.assets/image-20230223165043577.png)

### Data Movement Instructions

* Copies data from one location to another.

![image-20230220143305784](attachments/cs107.assets/image-20230220143305784.png)

#### Mov

![image-20230220143348230](attachments/cs107.assets/image-20230220143348230.png)

* You need to tell mov how wide the thing is that you're moving
* `mov S,D` where S is source and D is destination
* Registers are 8-byte values. `movl` moves 4 bytes into the lower 4 bytes of the register then zeros out the upper 4 bytes.
	* The rest of the instructions leave the register unchanged except for the part copied.

#### Movabsq

* This is used to move 64-bit immediate values into a register. The `movq` instruction only takes up to 32-bits, so we need this.
* It can have a `64-bit` immediate as a source, and only a register as a destination.
* E.g. `movabsq $0x0011223344556677, %rax`

#### Movz and Movs

![image-20230220143419805](attachments/cs107.assets/image-20230220143419805.png)

* `movs` keeps the sign of a number when extended. If it sees the most significant bit is `1`, it extends that, etc.

![image-20230220143439166](attachments/cs107.assets/image-20230220143439166.png)

### Practice

![image-20230220143502815](attachments/cs107.assets/image-20230220143502815.png)

* We need to line up our move command with our register.

1. `%eax` is a `l` register, while `(%rsp)` is a memory address, so we need to use `movl`
2. We're moving an address into `%dx`, which is the 16-bit register, which is a word.

### Errors with Mismatches

![image-20230220143520044](attachments/cs107.assets/image-20230220143520044.png)

* For the second to last one, we're moving register to register. Our registers have to line up in size. We're trying to move something bigger to something smaller.

---

## Lecture 10: Assembly Part 2

### Takeaways from Lect 9

* There are now 64-bit registers, but the smaller registers are still backwards compatible.
* Addresses in memory are represented as a linear equation, shown in the general operand (e.g. `6(%rax, %rdx, 4) = 6 + R[rax] + R[rdx] + 4)`)
* In x86, you can only move between a register to memory, memory into a register, or between registers. We can't move between memory.

### Code

* We will write a function in assembly.
* Below is the code in the main function. Notice that the function moveexamples is just a prototype. We will write its contents in assembly.

```c
#include<stdio.h>
#include<stdlib.h>

void movexamples(char *arr);

int main(int argc, char **argv)
{
    char hello[] = "hello";
    printf("Before function call: %s\n",hello);
    movexamples(hello);
    printf("After function call: %s\n",hello);

    return 0;
}
```

* In assembly, anything with a colon after it is a label. This is how functions are called.

```assembly
# File: mov_examples.s
# ---------------

.section .text

	.type	movexamples, @function
	.globl  movexamples

movexamples:
    # rdi should hold the address of a char array 
    # subtracts stack ptr to get space on the stack
    subq $24,%rsp

    # some mov operations
    movl $0x4050, %eax # move numb 0x4050 into eax
    movq %rsp, %rax # move stack ptr into rax
    movw %ax, %dx # move ax into dx
    movl $1,%ecx # move the number 1 into ecx

    # move value at (rdi + rcx) into al
    # rcx currently holds the number 1
    # essentially, we are dereferencing rdi + 1
    # rdi holds address of first char in hello
    # rdi + 1 is the address of the letter 'e'
    # al will now hold the char 'e'
    movb (%rdi, %rcx), %al

    # move 0x61 (this is the char a) into stack ptr
    movb $0x61, (%rsp)
    
    # move 0x61 into memory address pointed by rdi + 1
    # the string "hello" in rdi now becomes "hallo"
    movb $0x61,(%rdi, %rcx)
    movq %rax, 12(%rsp) # move rax into 12 + stack ptr

    # moves stack ptr back to original pos
    addq $24,%rsp
    
    #return
    ret
```

* The address of the `h` in "hello" is put into the `rdi` register.

* The first parameter is always stored in the `rdi` register.

* To get info about a register, we could `p $rsp`

* To display the next 4 instructions, use `display/4i $rip`

### Lea Instruction

* It's very similar to the mov instruction. It reads from a memory into a register, but it does not dereference. It moves the address itself.
* It doesn't touch the memory itself.
* This is the `&` operator in C.

![image-20230220143635884](attachments/cs107.assets/image-20230220143635884.png)

![image-20230220143719579](attachments/cs107.assets/image-20230220143719579.png)

* The `leaq` line above moves the address of `12 + rsp` into `rdx`. This corresponds with the `int *aptr = &a` line.
* Suppose  `12(%rsp)` holds the number `42` at address `0x1234`.
	* `movq 12(%rsp), %rdx` moves the value `42` into rdx.
	* `leaq 12(%rsp), %rdx` moves the address `0x1234` into rdx.

### Stack

![image-20230220143748881](attachments/cs107.assets/image-20230220143748881.png)

#### Example

* Suppose we are given three values. `%rax` is a value. `%rsp` is an address, since it's a stack pointer.

![image-20230220143819290](attachments/cs107.assets/image-20230220143819290.png)

* Push moves the stack pointer down and puts the thing into the stack.
	* Changes stack pointer and puts a value in memory.
* Pop takes the thing at the stack top and puts it into rdx, then moves the stack  top pointer back up.
	* Once the stack pointer is moved up, the value still in the stack is garbage. It'll get overwritten later.

![image-20230220143905261](attachments/cs107.assets/image-20230220143905261.png)

* It adds and removes 8 is because it's adding an address. It's moving 8 bytes. Pointers are 8 bytes long.

### Unary Instructions

![image-20230220143929029](attachments/cs107.assets/image-20230220143929029.png)

* `neg` is the two's complement negation. `not` is simply the one's complement, flipping all the bits.
* `inc D` is the `++` operator, and `dec D` is the `--` operator

### **Binary Instructions**

![image-20230220144039716](attachments/cs107.assets/image-20230220144039716.png)

* `add $rax, $rdx` is the same as `rdx += rax`
* `sub $rax, $rdx` is the same as `rdx -= rax`
* Division is missing from this list. ==Division is done a different way== due to how division works.

### Shift Instructions

![image-20230220144148253](attachments/cs107.assets/image-20230220144148253.png)

* `sal` means shift arithmetic left. Shift using the sign of the number.
* `shl` is identical to `sal`, because the sign doesn't matter when shifting left.
* `sar` is shift arithmetic right. This is the one that extends the sign bit.
	* `1100 >> 1 = 1110`
* `shr` is shift logical right. This always brings in zeros.
	* `1100 >> 1 = 0110`
* The first operand is either an immediate value representing the amount we're shifting, or the register `%cl`. We can put the value we're shifting into `%cl` and shift using that.
* In the examples, the first one shifts the value in rax left by 3. The second one logical shifts the value located at rax + 8 * rdx by the value held in cl. The third one arithmetic shifts the value at 8 + rax right by 4.

### More Multiplication Instructions

![image-20230220144537642](attachments/cs107.assets/image-20230220144537642.png)

* Multiplying can scale very quick. You may end up needing more space than you have available.
	* E.g. when you multiply two 8-bit number, the maximum answer we can get is a 16-bit number.
* If we want to use these commands, we first have to put the value we want `S` to be multiplied by into `rax`.
* This essentially stores the answer in two registers.

![image-20230220144631753](attachments/cs107.assets/image-20230220144631753.png)

* It first moves the second parameter, the value of x, into rax. Then, it multiplies this by rdx.

### Division Operations

![image-20230220144947330](attachments/cs107.assets/image-20230220144947330.png)

![image-20230220145014238](attachments/cs107.assets/image-20230220145014238.png)

* `cqto` takes the value in `%rax` and sign extends it into `%rdx`.
* The quotient is stored in `%rax` after division. The remainder is stored in `%rdx` after division.

### Control

![image-20230220150324200](attachments/cs107.assets/image-20230220150324200.png)

### Condition Codes

![image-20230220150408409](attachments/cs107.assets/image-20230220150408409.png)

* These registers are called `eflags`

![image-20230223165401280](attachments/cs107.assets/image-20230223165401280.png)

##### ![image-20230220150430045](attachments/cs107.assets/image-20230220150430045.png)

* The `leaq` instruction does not set any condition codes, because it is intended to for addresses and computations with addresses.
* All the other arithmetic instructions (`inc, dec, neg, not, add, sub, imul, xor, or, and, shl, sar, shr,` etc.) do set the flags

![image-20230220150622471](attachments/cs107.assets/image-20230220150622471.png)

#### `cmp` And `test`

![image-20230220151410526](attachments/cs107.assets/image-20230220151410526.png)

* For example, if you do `cmp` it tests the subtraction and sets the flags, but it does not actually change anything.
* `test` does the same with but now with logical and.

#### Set Bytes with Condition Codes

![image-20230220151510764](attachments/cs107.assets/image-20230220151510764.png)

### Jumps

* Notice the things at the end. `e` means equal, `ne` means not equal, `a` is above, `b` is below, `g` is greater, `l` is less, etc

![image-20230220151621237](attachments/cs107.assets/image-20230220151621237.png)

##### Example

![image-20230220151946092](attachments/cs107.assets/image-20230220151946092.png)

* The `cmp` compares `eax` to `0x63`, which is the same as 99. It essentially does `eax - 99`. While its still less than, the sign flag will be `1`.

	![image-20230220152145270](attachments/cs107.assets/image-20230220152145270.png)

* `jle` runs if `SF != OF`. The sign flag is 1, and the overflow flag is 0. Therefore, it will jump back to line `7`.

	![image-20230220152154883](attachments/cs107.assets/image-20230220152154883.png)

* **Trick:** `jle` means jump if less than or equal. Looking at the two lines, this means we do the jump if `eax` is less than or equal to `0x63`.

* There is multiple ways for the compiler to this exact code. The assembly below does the exact same thing.

	* The `-O1` basically changes the optimization value.

![image-20230220152256376](attachments/cs107.assets/image-20230220152256376.png)

* `jne` does jump if not equal or not zero. Basically we start from 100 and go down until we hit zero.
* This is not exactly what the code does, but it loops 100 times. We don't do anything with `i` so the compiler just optimizes it and just writes code to loop 100 times.

![image-20230220152531436](attachments/cs107.assets/image-20230220152531436.png)

### Jump Instructions Encoding

![image-20230220152810758](attachments/cs107.assets/image-20230220152810758.png)

![image-20230220152836581](attachments/cs107.assets/image-20230220152836581.png)

* `eb` means jump. `03` means jump 3 steps away. This would jump to `a` because the `%rip` will be at `7` after the line runs, and then you want to jump `3` to `a`.

![image-20230220152946667](attachments/cs107.assets/image-20230220152946667.png)

![image-20230223165500203](attachments/cs107.assets/image-20230223165500203.png)

![image-20230223165507160](attachments/cs107.assets/image-20230223165507160.png)

![image-20230223165515407](attachments/cs107.assets/image-20230223165515407.png)

* Note that in the code above the `<main + 31>` is an additional thing that GDB adds in to make it easier to read. The assembly will just have the address.

## Lecture 11: Assembly Part 3

### Reverse Engineer Assembly to C

* First argument is in %rdi, second is %rsi, third is %rdx, fourth is %rcx
* The calling function needs to put the data into these registers

![image-20230226234403999](attachments/cs107.assets/image-20230226234403999.png)

* The first `leaq` puts `x + y` into `rax`
* It then does `rax += z`
* If `x` is greater than or equal to `-3`, jump to `.L2`

![image-20230220153040963](attachments/cs107.assets/image-20230220153040963.png)

* Notice that there are 3 returns. This is because once that line is reached, nothing else is ran in the code.

### GDB Assembly

![image-20230226234657086](attachments/cs107.assets/image-20230226234657086.png)

### More Reverse-engineer

![image-20230226234757172](attachments/cs107.assets/image-20230226234757172.png)

* Note that these first few lines are moving immediate values into an contiguous block. This corresponds with the int array in the C code.

![image-20230226235013475](attachments/cs107.assets/image-20230226235013475.png)

* This next chunk creates the long array.
* Notice that sometimes C instructions don't show up in the assembly. In this case, the `i_nelems` doesn't show up in the assembly.
	* The actual line of code is `size_t i_nelems = sizeof(i_array) / sizeof(i_array[0])`. The compiler can figure this out beforehand and it doesn't include it in the assembly.

![image-20230227000307457](attachments/cs107.assets/image-20230227000307457.png)

* These next few lines set up the code for the `print_array` function.
	* The line `0x400596` is the address of a function. This is the function pointer for printing that is used in the `print_array` function.
	* The `4` in the 3rd parameter comes from the fact that it's the size of the int. The compiler just puts the immediate value there instead of calling the `sizeof` function.

![image-20230227000410782](attachments/cs107.assets/image-20230227000410782.png)

* We now look at the `print_array` function. This is a generic function.

![image-20230227000515082](attachments/cs107.assets/image-20230227000515082.png)

* The first thing it does is save all the parameters into registers. This is because the parameters may be overwritten later on when we call other functions.

![image-20230227000729327](attachments/cs107.assets/image-20230227000729327.png)

* These first few lines and jumps is for the `for` loop. In this case, `ebx` is the register storing the value in `i`.

![image-20230227001115929](attachments/cs107.assets/image-20230227001115929.png)

* Lines 33 and 35 performs `i * width`. Then, we add the array into `rdi`. This line essentially translates to `arr + width * i`.
* We then call the function with this element.

![image-20230227001224432](attachments/cs107.assets/image-20230227001224432.png)

* The chunk of lines after this is just the code for `printf`.

![image-20230227001329964](attachments/cs107.assets/image-20230227001329964.png)

* We then add `1` to `ebx`. This is our `i++` line.

![image-20230227001538413](attachments/cs107.assets/image-20230227001538413.png)

### Conditional Moves

![image-20230227001629005](attachments/cs107.assets/image-20230227001629005.png)

![image-20230227002045471](attachments/cs107.assets/image-20230227002045471.png)

* Both of these functions perform the same move. However, notice that there is no jumps in the `cmovdiff`.

![image-20230227002246792](attachments/cs107.assets/image-20230227002246792.png)

* The ticks is the speed. Notice that the one with no jumps is faster.

### While Loops

![image-20230227003858428](attachments/cs107.assets/image-20230227003858428.png)

* It does this because while loops don't always run the body statement. It checks the condition first before running the body statement.

![image-20230227004003817](attachments/cs107.assets/image-20230227004003817.png)

* From `.L6` in the example above, once it subtracts `1` from `%rdi`, it falls through and runs `.L5` too, which jumps back to `L.6`.

![image-20230227004102915](attachments/cs107.assets/image-20230227004102915.png)

![image-20230227004347291](attachments/cs107.assets/image-20230227004347291.png)

* This is the same. It compares the thing first. If it fails, it jumps down to done. Otherwise, it falls through and runs the loop.

![image-20230227004438795](attachments/cs107.assets/image-20230227004438795.png)

![image-20230227004457723](attachments/cs107.assets/image-20230227004457723.png)

### For Loops

* For loops are just disguised while-loops.

![image-20230227004609078](attachments/cs107.assets/image-20230227004609078.png)

* Because of this, the assembly is pretty similar to a while loop.

![image-20230227004646928](attachments/cs107.assets/image-20230227004646928.png)

![image-20230227004703759](attachments/cs107.assets/image-20230227004703759.png)

![image-20230227005548374](attachments/cs107.assets/image-20230227005548374.png)

### Procedures (Functions)

![image-20230227005832513](attachments/cs107.assets/image-20230227005832513.png)

* The special instructions in `x86` is the `call` instruction.

### Run-Time Stack

* You can have up to 6 arguments/parameters that go in registers. The remaining arguments go in the stack.

![image-20230227005953528](attachments/cs107.assets/image-20230227005953528.png)

* Notice that the return address must go in the stack. This address is the instruction right after the instruction call.

![image-20230227010159932](attachments/cs107.assets/image-20230227010159932.png)

![image-20230227010516289](attachments/cs107.assets/image-20230227010516289.png)

### Data Transfer

![image-20230227011217902](attachments/cs107.assets/image-20230227011217902.png)

![image-20230227011337041](attachments/cs107.assets/image-20230227011337041.png)

* Notice that `a4` and `a4p` are on the stack. Therefore, we must fetch them from the stack.

### Local Stack Storage

![image-20230227135152603](attachments/cs107.assets/image-20230227135152603.png)

![image-20230227162244803](attachments/cs107.assets/image-20230227162244803.png)

### Local Storage in Registers

![image-20230304125345455](attachments/cs107.assets/image-20230304125345455.png)

* `rbx` is a caller-owned register: if you're in a function and you modify `rbx`, you must return `rbx` to the value it started with before you modified it.
* It is guaranteed to be same when you return from function.
* These registers can be used to store values while you call functions.

 ![image-20230304125619703](attachments/cs107.assets/image-20230304125619703.png)

* Notice that we push `rbp` onto the stack in the beginning, then pop to return it at the end of the function.
* Notice that it uses `rbx` and `rbp` to store values between function calls.

### Recursion

![image-20230304125916272](attachments/cs107.assets/image-20230304125916272.png)

* We save $n$ in `rbx` since we're calling functions continuously. We want the value of $n$ to be saved.
* When we first run the function, notice that the first item on the stack is the return address.

![image-20230304130136445](attachments/cs107.assets/image-20230304130136445.png)

![image-20230304130220392](attachments/cs107.assets/image-20230304130220392.png)

* The first few lines are the base case.

![image-20230304130312370](attachments/cs107.assets/image-20230304130312370.png)

* The current value of `rbx` is stored on the stack so it can restore it to it after the function finishes calling.

![image-20230304130404332](attachments/cs107.assets/image-20230304130404332.png)

* The value of $n$ from each function call is stored on the stack, so we can multiply it later.
* Note that when we're stepping through a function, we're the callee.
* If function a calls function b calls function c calls function d:
	* a is b's caller
	* b is c's caller
	* b is a's callee

---

## Lecture 12: Assembly Part 4

### Array Allocation and Access

![image-20230304130843912](attachments/cs107.assets/image-20230304130843912.png)

![image-20230304130900689](attachments/cs107.assets/image-20230304130900689.png)

#### Pointer Arithmetic

![image-20230304131036702](attachments/cs107.assets/image-20230304131036702.png)

![image-20230304131106962](attachments/cs107.assets/image-20230304131106962.png)

### Structs

![image-20230304132248308](attachments/cs107.assets/image-20230304132248308.png)

![image-20230304132300459](attachments/cs107.assets/image-20230304132300459.png)

* The array in the struct is kept in memory.

![image-20230304132417557](attachments/cs107.assets/image-20230304132417557.png)

* To move memory, we must first move the memory into a register, then move from that register to the new place in memory.

![image-20230304132433736](attachments/cs107.assets/image-20230304132433736.png)

![image-20230304132536928](attachments/cs107.assets/image-20230304132536928.png)

![image-20230304132632582](attachments/cs107.assets/image-20230304132632582.png)

### Data Alignment

![image-20230304132716558](attachments/cs107.assets/image-20230304132716558.png)

![image-20230304132917535](attachments/cs107.assets/image-20230304132917535-7965358.png)

* It adds the gap because ints should have an offset divisible by 4.

### Function Pointers

![image-20230304133103405](attachments/cs107.assets/image-20230304133103405.png)

![image-20230304133317284](attachments/cs107.assets/image-20230304133317284.png)

* The first few comparison lines circled is the logic for the for loop. Then, the call to the comparison function is at `*%r15`. It dereferences the address and gets the value of the function pointer, and calls the function.

---

## Lecture 13: Managing the Heap Part I

* There are two areas of main memory: the stack and the heap
* Programs by default has 8MB of stack space
* The heap is controlled by the operating system, and a **heap allocator** maintains the heap as collection of **contiguous memory blocks** that are either free or allocated.
	* Allocated blocks are reserved. When you call malloc, you have access to an allocated block. It remains allocated for the rest of the program or until you call free.
	* Heap allocate frees the block at the end.

![image-20230306174129679](attachments/cs107.assets/image-20230306174129679.png)

![image-20230306174246146](attachments/cs107.assets/image-20230306174246146.png)

### Malloc, Free, and Realloc

![image-20230306174318098](attachments/cs107.assets/image-20230306174318098.png)

### Allocator Requirements

![image-20230306174413705](attachments/cs107.assets/image-20230306174413705.png)

* Errors caused by the caller is not your problem, it's the caller's problem.

![image-20230306174436812](attachments/cs107.assets/image-20230306174436812.png)

* Boundary means if we ask for 20 bytes, we would get a chunk that is divisible by 8.

### Allocator Goals

![image-20230306174511184](attachments/cs107.assets/image-20230306174511184.png)

![image-20230306174536268](attachments/cs107.assets/image-20230306174536268.png)

### Tracing the Heap

* This is a general example. It's not a true example of what our heap allocate will do.
* Each chunk below represents 4 bytes.

![image-20230306174808637](attachments/cs107.assets/image-20230306174808637.png)

![image-20230306174818144](attachments/cs107.assets/image-20230306174818144.png)

* Note that here, we have a fragmented heap. There are free blocks that are split up.
* Also note that after you free, `a` and `c`'s values do not change. They stay the same, we just have to keep track that those addresses are now freed.

![image-20230306174823533](attachments/cs107.assets/image-20230306174823533.png)

* Notice that `a` and `e` point to the same chunk of memory. However, we should never use `a` again since that is technically a garbage value.

![image-20230306174832594](attachments/cs107.assets/image-20230306174832594.png)

* If it can, `realloc` simply just extends the block into free space.

![image-20230306174838914](attachments/cs107.assets/image-20230306174838914.png)

* If there is not enough free space to extend, it'll move it to another chunk that is free.

![image-20230306174849047](attachments/cs107.assets/image-20230306174849047.png)

* Even though there is technically 24 bytes available, it is not contiguous so we can't.

### Heap Allocator Implementation Issues

* How do we track the information in a block?
	* Remember, free() is only given a pointer, not a size.
	* When you do `malloc(20)`, it needs to keep track of how many bytes it allocated.
* How do we organize/find free blocks?
* How do we pick which free block from available options?
* What do we do with excess space when allocating a block?
* How do we recycle a freed block?

### Separate List / Table

![image-20230306175903014](attachments/cs107.assets/image-20230306175903014.png)

* This approach is kind of slow. This is why Valgrind is so slow.

### Block Header

![image-20230306180005739](attachments/cs107.assets/image-20230306180005739.png)

* The 96 bytes is the heap.

![image-20230306180033634](attachments/cs107.assets/image-20230306180033634.png)

![image-20230306180102006](attachments/cs107.assets/image-20230306180102006.png)

![image-20230306180116472](attachments/cs107.assets/image-20230306180116472.png)

![image-20230306180139573](attachments/cs107.assets/image-20230306180139573.png)

![image-20230306180209206](attachments/cs107.assets/image-20230306180209206.png)

![image-20230306180335990](attachments/cs107.assets/image-20230306180335990.png)

![image-20230306180411396](attachments/cs107.assets/image-20230306180411396.png)

### Implicit Free List

![image-20230306180520888](attachments/cs107.assets/image-20230306180520888.png)

* In this implementation, buffer overflows in the heap can cause the heap to get very messed up. This is because it can wipe out the header blocks.
* This implementation results in an $O(n)$ `malloc`.

![image-20230306180604651](attachments/cs107.assets/image-20230306180604651.png)

### Placement (fit)

![image-20230306180814246](attachments/cs107.assets/image-20230306180814246.png)

### Splitting and Coalescing

![image-20230306181101759](attachments/cs107.assets/image-20230306181101759.png)

### Coalescing

![image-20230306181157282](attachments/cs107.assets/image-20230306181157282.png)

![image-20230306181240635](attachments/cs107.assets/image-20230306181240635.png)

![image-20230306181308173](attachments/cs107.assets/image-20230306181308173.png)

* You can't coalesce backwards without a footer.

### Explicit Free List

![image-20230306181503222](attachments/cs107.assets/image-20230306181503222.png)

* It's implemented as a doubly linked list. This is because when we free one block, we need to be able to connect all the blocks.

![image-20230306181545622](attachments/cs107.assets/image-20230306181545622.png)

![image-20230306181634692](attachments/cs107.assets/image-20230306181634692.png)

* Every allocated block must be at least 16 bytes to save room for the pointers.

![image-20230306181717256](attachments/cs107.assets/image-20230306181717256.png)

![image-20230306181754172](attachments/cs107.assets/image-20230306181754172.png)

---

## Lecture 14: Managing the Heap Part 2

### Implicit and Explicit Heap Allocation

![image-20230306195155837](attachments/cs107.assets/image-20230306195155837.png)

### Implicit Heap Allocation

#### Initialization

![image-20230306195303352](attachments/cs107.assets/image-20230306195303352.png)

![image-20230306195333226](attachments/cs107.assets/image-20230306195333226.png)

#### Allocation

![image-20230306195357430](attachments/cs107.assets/image-20230306195357430.png)

![image-20230306195425874](attachments/cs107.assets/image-20230306195425874.png)

* With an implicit heap allocator, we have to always start from the first block and do a linear search through the heap.

![image-20230306195439887](attachments/cs107.assets/image-20230306195439887.png)

* We're working with 8-byte alignment, so we have to round up to the next multiple of 8, which is 24 bytes.
* The user will only use 20 bytes since that's how much they requested.

![image-20230306195507689](attachments/cs107.assets/image-20230306195507689.png)

#### Free

![image-20230306195535240](attachments/cs107.assets/image-20230306195535240.png)

* `f 1` is passed in the address `0x28`, which is the address of that block. We go back one address to the header and change it to free.

![image-20230306195552669](attachments/cs107.assets/image-20230306195552669.png)

* We skipped over the first free block because there wasn't enough space.

![image-20230306195633359](attachments/cs107.assets/image-20230306195633359.png)

* Notice that it allocates 24 bytes in that chunk. We can't do 12 because its not a multiple of 8. However, we also can't do 16 because we'd just have a block header that says there is 0 bytes free. There's no point to this header.

	![image-20230306203816675](attachments/cs107.assets/image-20230306203816675.png)

![image-20230306203905910](attachments/cs107.assets/image-20230306203905910.png)

* We simply set the header to free.
* Note that the implicit heap allocator does not coalesce.

#### Reallocation

![image-20230306204024397](attachments/cs107.assets/image-20230306204024397.png)

* We can combine it when we realloc

![image-20230306204048484](attachments/cs107.assets/image-20230306204048484.png)

#### Reallocation with Moving

* If we weren't able to realloc at that spot, we would've had to search through every space.

![image-20230306204130609](attachments/cs107.assets/image-20230306204130609.png)

* The above is an example of searching through to the first available block.

### Explicit Heap Allocation

![image-20230306204305450](attachments/cs107.assets/image-20230306204305450.png)

#### Allocation

![image-20230306204343073](attachments/cs107.assets/image-20230306204343073.png)

![image-20230306204410742](attachments/cs107.assets/image-20230306204410742.png)

![image-20230306204421605](attachments/cs107.assets/image-20230306204421605.png)

#### Free

![image-20230306204554014](attachments/cs107.assets/image-20230306204554014.png)

* We add this block to our linked list. We create two pointers in this block.

![image-20230306204603981](attachments/cs107.assets/image-20230306204603981.png)

* Notice that the pointers point to the header of each block. We can do it any way, but there is less pointer arithmetic if we just make it point to the header.
* We also update the pointer to the first free block.

#### Allocate after Free

![image-20230306204635000](attachments/cs107.assets/image-20230306204635000.png)

![image-20230306204656893](attachments/cs107.assets/image-20230306204656893.png)

![image-20230306204707977](attachments/cs107.assets/image-20230306204707977.png)

* Notice that we update the next pointer in the first free chunk. This is because the free chunk has moved to a new spot.

#### More Allocation

![image-20230306204738474](attachments/cs107.assets/image-20230306204738474.png)

![image-20230306204745783](attachments/cs107.assets/image-20230306204745783.png)

* Adding this took up all of the space in that chunk. Again, note that it allocated 24 bytes for the 12 byte request.
* Notice that it removes the pointers and updates the pointer to the free block. It also updates the doubly linked list values.

#### Free and Coalesce

![image-20230306204827611](attachments/cs107.assets/image-20230306204827611.png)

![image-20230306204838631](attachments/cs107.assets/image-20230306204838631.png)

* It combines the free block and moves the pointers.

#### Realloc

![image-20230306204852152](attachments/cs107.assets/image-20230306204852152.png)

* If we moved free blocks around, we would have to update the pointers for those.
* We can use the pointer to previous to update the block when we free/allocate something.

![image-20230306205430130](attachments/cs107.assets/image-20230306205430130.png)

* We can use the previous to go to the old free block, and then update it to point to the next free block after we allocated.

### Struct Casting

![image-20230306205635072](attachments/cs107.assets/image-20230306205635072.png)

* We can lay a struct definition over a pointer and use the built-in pointer functionality of C to access the data at that `void *` pointer. This works because the struct data is stored in contiguous blocks of memory.
* Some example structs for this assignment would be things like a header struct or a node struct for the linked list.

![image-20230306205816474](attachments/cs107.assets/image-20230306205816474.png)

* Since we cast it, we can access each of the data points. Remember that the arrow is basically like `*(si).email`.
* This is the same idea behind if we did `char *x = *(char **)ptr`.
* We just simply tell the compiler that the thing there is a struct.

![image-20230306205838226](attachments/cs107.assets/image-20230306205838226.png)

* C doesn't know the type of data. However, since you know it'll be a `struct student_info`, you can cast it to work with it more easily.

![image-20230306205953693](attachments/cs107.assets/image-20230306205953693.png)

![image-20230306210036952](attachments/cs107.assets/image-20230306210036952.png)

* It can get extremely difficult to debug if we don't use the struct casting method, since we would be constantly casting and doing pointer arithmetic.

#### GDB

* This is how it is initially, right after the memory has been allocated.

![image-20230306210331750](attachments/cs107.assets/image-20230306210331750.png)

![image-20230306210433327](attachments/cs107.assets/image-20230306210433327.png)

![image-20230306210519177](attachments/cs107.assets/image-20230306210519177.png)

![image-20230306210529514](attachments/cs107.assets/image-20230306210529514.png)

![image-20230306210536864](attachments/cs107.assets/image-20230306210536864.png)

![image-20230306210548894](attachments/cs107.assets/image-20230306210548894.png)

![image-20230306210611269](attachments/cs107.assets/image-20230306210611269.png)

![image-20230306210730313](attachments/cs107.assets/image-20230306210730313.png)

---

## Lecture 15: Optimization

* This optimization is not in terms of Big O. This is optimization in terms of memory performance and assembly instructions.

### Optimization Considerations

* **Measure the code.** Time the code to see if there is an issue.
	* We optimize code to make it faster (or smaller). If there isn't a problem, don't optimize it.
	* If the code scales well, it probably doesn't need to be optimized.
* **Use the correct algorithm and design.**
	* This is more about improving Big O or fixing bad design.
* **Keep it simple.** Simple code is easy to debug and optimize.
* **Let gcc work**. gcc can do a lot of optimizations by itself.
	* Don't pre-optimize before compiling it with a high optimization in gcc.
	* After that, you can look and see where you can optimize.
* **Optimize explicitly as a last resort**. Measure again and attack the bottlenecks first.
	* Only do this if it is still slow after using the compiler and everything else.

### Optimization Blockers

* The code below will not be optimized by gcc.

![image-20230310141438551](attachments/cs107.assets/image-20230310141438551.png)

* The two functions above look like they do the exact same thing.
* However, notice that they are pointers. Consider the case where `xp` and `yp` point to the same number.

![image-20230310141835074](attachments/cs107.assets/image-20230310141835074.png)

* We see that we don't get the same answer.
* When dealing with pointers, always consider the case where two pointers point to the same thing.

![image-20230310141954918](attachments/cs107.assets/image-20230310141954918.png)

### Optimization Examples

#### Constant Folding

![image-20230310142102187](attachments/cs107.assets/image-20230310142102187.png)

* The compiler can just do math on the constants put the result into the compiled program.
* Higher levels of optimization make debugging harder.

#### Common Subexpression Elimination

![image-20230310142524965](attachments/cs107.assets/image-20230310142524965.png)

* If the compiler see that multiple expressions evaluate to the something, it can just eliminate them all.

#### Strength Reduction

* Multiplication, division, and mod are strong operations.

![image-20230310142641934](attachments/cs107.assets/image-20230310142641934.png)

* The compiler will try avoid strong operations.

#### Code Motion

![image-20230310142748922](attachments/cs107.assets/image-20230310142748922.png)

* It will sometimes move code and precompute it, so it can reuse it quickly.

#### Dead Code Elimination

![image-20230310142928645](attachments/cs107.assets/image-20230310142928645.png)

* Some of the statements above do nothing, so the compiler just removes them.
* Notice that the loop for result is gone, because we don't use it anywhere else in the program.

![image-20230310143103804](attachments/cs107.assets/image-20230310143103804.png)

* The entire code simply adds one to `param1`.
* `volatile` can be used to make sure code isn't removed by the compiler.

### Gcc and Optimization

![image-20230310144554056](attachments/cs107.assets/image-20230310144554056.png)

* For -O3, since wrapping for signed numbers is an undefined operation, the code may break if we rely on it.
* For -Os, one example is loop unrolling. If you have a loop running 8 times that perform the same operations, optimizers may make that loop instead run 2 times and perform 4 of those operations. -Os will not do this because it can increase the code size.

![image-20230310143441943](attachments/cs107.assets/image-20230310143441943.png)

* The optimizations will try not to break the code.

![image-20230310143628093](attachments/cs107.assets/image-20230310143628093.png)

### What Gcc Cannot Do

![image-20230310144741670](attachments/cs107.assets/image-20230310144741670.png)

### Optimization Examples

![image-20230310144824397](attachments/cs107.assets/image-20230310144824397.png)

* Note that `strlen(s)` is an O(n) operation.
* The optimization will perform code moving on this. It will move it to just calculate `strlen` once, and then reuse that variable.

![image-20230310145546459](attachments/cs107.assets/image-20230310145546459.png)

* Although logically `strlen` does not change, the compiler won't optimize it because the string is being changed. It won't risk changing the code.

### Hand-optimization

![image-20230310150238981](attachments/cs107.assets/image-20230310150238981.png)

* The compiler doesn't know what the `vec_length` function does, so it won't move it out of the function for us.

![image-20230310150323122](attachments/cs107.assets/image-20230310150323122.png)

![image-20230310150356134](attachments/cs107.assets/image-20230310150356134.png)

* Since the compiler can't remove function calls, by adding it directly we can speed it up.
* Since we are guaranteed that the code will not go out of bounds, we can remove the bounds checking, which can be a cause of slowdowns.

![image-20230310150419238](attachments/cs107.assets/image-20230310150419238.png)

![image-20230310150512549](attachments/cs107.assets/image-20230310150512549.png)

![image-20230310150637029](attachments/cs107.assets/image-20230310150637029.png)

### Caching

![image-20230310150739484](attachments/cs107.assets/image-20230310150739484.png)

### Locality

![image-20230310151045455](attachments/cs107.assets/image-20230310151045455.png)

* It will try move data that is frequently accessed into a faster cache.
* It will also try move blocks of data into the cache instead of one thing at a time.
* The hit rate means the processor is really good at knowing when to move memory into the cache, so that it comes from a faster memory.

### Using Callgrind

![image-20230310151204310](attachments/cs107.assets/image-20230310151204310.png)

* You can use callgrind to find bottlenecks in the code. Look at places in the annotation with a lot of instructions.

---

## Lecture 16: Memory Safety
