## Lecture 0: Set Theory

### Grading

* 25% PSETs -> 10 PSETs
* Two midterms
* One final

### Introduction to Set Theory

* **Set**: An unordered collection of distinct objects. The objects can be anything.
* Set Notation: `{}` curly braces, comma-separated elements

![image-20230218160435630](image-20230218160435630.png)

#### Empty Sets

![image-20230218160502679](image-20230218160502679.png)

#### Infinite Sets

* $\N = \{0, 1, 2, 3 \dots\}$ -> set of natural numbers (non-negative)
* $\Z = \{\dots, -2, -1, 0, 1, 2, \dots\}$ -> set of integers
* $\R$ -> all real numbers

#### Set Builder Notation

![image-20230218160518760](image-20230218160518760.png)

* Example: $\{n | n \in \N$ and $n$ is even $\}$

### Subsets

* $S$ is a subset of $T$ if all elements of $S$ are also elements of $T$
* The notation is $S \subseteq T$

![image-20230218160538420](image-20230218160538420.png)

#### Subsets and Elements

* $x \in S$ means you can point at $x$ inside of $S$
* $A \subseteq B$ means you can form $A$ by circling elements of $B$

![image-20230218160604240](image-20230218160604240.png)

* The empty set is always a subset of any set.

#### Power Set

* The power set of $S$ is the set containing all subsets of $S$

* The symbol is $\wp(S)$.

![image-20230218160614432](image-20230218160614432.png)

### Cardinality

* The cardinality of a set is the number of elements that the set contains.
* For a set $S$, the cardinality is notated as $|S|$.

![image-20230218160629041](image-20230218160629041.png)

#### Cardinality of Infinite Sets

* The cardinality of infinite sets is called aleph-nought, denoting no end point.
  * $|N| = \aleph_0$

##### Example:

* Consider $S = \{ n | n \in \N$ and $n$ is even$\}$. What is the cardinality of $S$, $|S|$?
  * Two sets have the **same cardinality** if you can pair up elements until nothing else is left on both sides.

| ![image-20230218160638691](image-20230218160638691.png) | ![image-20230218160643323](image-20230218160643323.png) |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

* Using this logic, we can pair up every number $n$ in $\N$ with its counterpart in $S$.

![image-20230218160704109](image-20230218160704109.png)

#### **Do all infinite sets have same cardinality?**

![image-20230218160723220](image-20230218160723220.png)

* The cardinality of the power set of $S$ will always be greater than $S$.

#### Cantor's Theorem

![image-20230218160742211](image-20230218160742211.png)

![image-20230218160750905](image-20230218160750905.png)

![image-20230218160810698](image-20230218160810698.png)

---

## Lecture 1: Mathematical Proofs

### Set Combinations

Given set $A = \{1, 2, 3\}$ and set $B = \{3, 4, 5\}$, we have the following

<img src="cs103.assets/image-20230218161051336.png" alt="image-20230218161051336" style="zoom:50%;" />

#### Union

Union combines the two sets.

$A \cup B = \{1, 2, 3, 4, 5\}$

![image-20230218161108675](image-20230218161108675.png)

#### Intersection

Intersection only keeps elements that are in both sets.

$A \cap B = \{3\}$

![image-20230218161134873](image-20230218161134873.png)

#### Difference

Difference removes every element of set B from set A.

$A \setminus B = \{1, 2\}$

![image-20230218161143532](image-20230218161143532.png)

#### Symmetric Difference

Symmetric difference keeps all elements except those that are in both sets.

$A \triangle B = \{1, 2, 4, 5\}$

![image-20230218161149029](image-20230218161149029.png)

### Proofwriting

* Proofs demonstrate **why** a math statement is true, following the rules of math.

#### Rules

| ![image-20230218161259143](image-20230218161259143.png) | ![image-20230218161304450](image-20230218161304450.png) |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

* Focus on precision and completeness, not persuasion.
* Be sure to not skip any steps.
* Proofs should be a list of steps that precisely and completely explains why something is true.

### Proof #1

#### Definitions

1. An integer $n$ is called **even** if there is an integer $k$ such that $n = 2k$.
2. An integer $n$ is called **odd** if there is an integer $k$ such that $n = 2k+1$.

#### Theorem

* The theorem is the thing we want to prove. For our first example, the theorem is as follows.

> **Theorem**: For all integers $n$, if $n$ is even, then $n^2$ is even.

* **Always** start by writing the theorem.

#### Steps to Proofwriting

1. Find definitions for any terms
   * In this case, we would find the formal definition of an even number.
2. Examine the grammatical structure of the proof
   * This theorem uses `for all` and `if ... then ...`
   * "For all" means we need this to be true for all elements.
     * So we have to tell our reader to pick **any** integer.
   * The "if ... then ..." part means that the "then" part only holds if the ''if" part is true.
     * So we tell our reader to pick any integer **assuming** that the "if" condition is true.

![image-20230218161424454](image-20230218161424454.png)

3. For problems like these, it helps to do some casework to find the exact pattern.

![image-20230218161432260](image-20230218161432260.png)

4. It may also be helpful to have some pictures.

![image-20230218161441594](image-20230218161441594.png)

#### Completed Proof

![image-20230218161454294](image-20230218161454294.png)

### Proofwriting Notes

![image-20230218161527184](image-20230218161527184.png)

### Example with Odd and Even

![image-20230218161644547](image-20230218161644547.png)

* There are some basic facts that we can assume.
  1. Every integer is either even or odd.
  2. No integer is both even and odd.

![image-20230218161652506](image-20230218161652506.png)

#### Completed Proof

![image-20230218161722620](image-20230218161722620.png)

#### Important Notes

* We know that $m$ and $n$ are arbitrary odd integers. Thus, they can be different integers. Thus, we must use different variables for their definitions because $k \neq r$.
* Try to number equations to refer back easier.
* Proofs are expected to be written in complete sentences.

### Universal and Existential Statements

![image-20230218161755447](image-20230218161755447.png)

![image-20230218161816268](image-20230218161816268.png)

### Proving an Existential Statement

![image-20230218161824965](image-20230218161824965.png)

#### Theorem

![image-20230218161857607](image-20230218161857607.png)

### Floors and Ceilings

![image-20230218161910107](image-20230218161910107.png)

#### Theorem with Cases

![image-20230218161932097](image-20230218161932097.png)

### Relationship between Reader and Proof

![image-20230218161959798](image-20230218161959798.png)

### Proofwriting Rules

![image-20230218162008712](image-20230218162008712.png)

---

## Lecture 2: Indirect Proofs

### Implications

* An implication is a statement of the form "If P is true, then Q is true."
* The antecedent is the part after the "if", the consequent is the part after the "then"

![image-20230218162032642](image-20230218162032642.png)

* Implication is directional. "If P then Q" does not imply "If Q then P."
* Implication only says something about the consequent when the antecedent is true. It tells nothing when the antecedent is false.
* Implication does not mean causation.

#### Diagram

![image-20230218162101346](image-20230218162101346.png)

### Negation

* A **proposition** is a statement that is either true or false.
  * e.g. "If $n$ is an even integer, then $n^2$ is an even integer"

* The **negation** of proposition $X$ is a proposition that is true whenever $X$ is false.
  * E.g. $X$ is "it is snowing outside"
    * The negation is "it is not snowing outside"
    * The negation is **not** "it is sunny outside"

![image-20230218165135565](image-20230218165135565.png)

* The negation of **universal** statements is the corresponding **existential** statement
* The negation of **existential** statements is the corresponding **universal** statement
* The negation of an **implication** is not an implication itself. It becomes two clauses joined by an `and`. We see that the antecedent holds, but the consequent is false.

### Contrapositive

* Contrapositive statements reverse and negate the implication.

![image-20230218165330918](image-20230218165330918.png)

* The two yellow statements above negate to the exact same statement. Thus, they are equivalent.
  * When P is true, Q is also true. Thus, when Q is false, P must be false.

#### Diagram

![image-20230218165349073](image-20230218165349073.png)

#### Definition

* The contrapositive of an implication means exactly the same thing as the implication itself.

![image-20230218165557869](image-20230218165557869.png)

* To prove "If P is true, then Q is true", you can choose to instead prove the equivalent statement "If Q is false, then P is false" if that seems easier.
  * This is a proof by contrapositive.

#### Example

**Theorem**: For any $n \in \Z$, if $n^2$ is even, then $n$ is even.

> Theorem: For any $n \in \Z$, if $n^2$ is even, then $n$ is even.
>
> Proof: We will prove the contrapositive of this statement, that if $n$ is odd, then $n^2$ is odd. So let $n$ be an arbitrary odd integer. We want to show that $n^2$ is odd as well.
>
> We know that $n$ is odd, which means that there exists an integer $k$ such that $n = 2k + 1$. This in turn tells us that
> $$
> \begin{align*}
> 	n^2 &= (2k + 1)^2 \\
> 	&= 4k^2 + 4k + 1 \\
> 	&= 2(2k^2+2k) + 1 \\
> \end{align*}
> $$
> From this, we see that there is an integer $m$ (namely, $2k^2 + 2k$) such that $n^2 = 2m + 1$. That means that $n^2$ is odd, which is what we needed to show. $\blacksquare$

![image-20230218165638311](image-20230218165638311.png)

#### Biconditionals

* The previous theorem, combined with what we saw on Wednesday, tells us the following:
  1. For any integer $n$, if $n$ is even, then $n^2$ is even.
  2. For any integer $n$, if $n^2$ is even, then $n$ is even.
* These are two different implications. We need to prove each.
* We use the phrase **if and only if** to indicate that two statements imply each other.
  * E.g. For any integer $n$, $n$ is even if and only if $n^2$ is even.

* To prove a theorem of the form **P if and only if Q**, you need to prove two separate statements.
  * First, prove that **if P is true, then Q is true**
  * Second, prove that **if Q is true, then P is true**
  * You can use any proof techniques you'd like to show each of these statements.

#### Proof by Contradiction

* Shows that some statement $P$ is true by showing that $P$ is not false.

> Prove a statement $P$ is true by showing that isn't false.
>
> 1. First, assume the negation ($P$ is false). The goal is to show that this assumption is bad.
> 2. Next, show this leads to an impossible result.
>    * E.g. We might have that 1 = 0, or that $x \in S$ and $x \notin S$, that a number is both odd and even, etc.
> 3. Finally, conclude that since $P$ can't be false, we know that $P$ must be true.

**Example**

In the realm of set cardinalities, is there a "largest" set? That is, is there a set that's bigger than every other set?

> Theorem: There is no largest set.
>
> Proof: Assume for the sake of contradiction that there is a largest set; call it S.
>
> Now consider the power set $\mathcal P(S)$. By Cantor's Theorem, we know that $|S| < |\mathcal P(S)|$, so $\mathcal P(S)$ is a larger set than $S$. This contradicts the fact that $S$ is the largest set.
>
> We've reached a contradiction, so our assumption must have been wrong. Therefore, there is no largest set. $\blacksquare$

![image-20230218165750223](image-20230218165750223.png)

**Theorem**

We prove an implication by contradiction. We first negate the implication.

![image-20230218165801498](image-20230218165801498.png)

Then, we prove the whole thing.

![image-20230218165808556](image-20230218165808556.png)

### Proving Implications

![image-20230218165834810](image-20230218165834810.png)

### Summary

![image-20230218165841135](image-20230218165841135.png)

---

## Lecture 3: Propositional Logic

Propositional logic is reasoning about boolean values.

* A **proposition** is a statement that is either true or false.
* Propositional logic is math system for reasoning about propositions.
* Every statement in propositional logic consists of **propositional variables** combined via **propositional connectives**.
  * Variables are the propositions themselves.
  * Connectives encode how propositions are related (e.g. "if ... then ...")

### Propositional Logic as Boolean Algebra

* Focus on analyzing and manipulating the structure of arguments.
  * Replace individual English sentences that state **<u>facts</u>** with **<u>propositional variables</u>**
  * Replace the **<u>“if...then,” “and,” “or,”</u>** etc. with **<u>operator symbols</u>**.

#### Propositional Variables

* Each proposition is represented as a <u>propositional variable</u>.
* Usually lower-case letters, such as `p, q, r, s`
* Each variable can only take either **true** or **false**

#### Propositional Connectives

There are seven connectives.

1. Logical Negation
   
   ![image-20230218165910752](image-20230218165910752.png)
2. Logical conjuction
   
   ![image-20230218165915995](image-20230218165915995.png)
3. Logical disjunction (this is an inclusive or)
   
   ![image-20230218165922782](image-20230218165922782.png)

#### Truth Tables

* The truth table shows the truth value of a propositional logic formula as a function of its inputs.
* Stanford has a tool for this: https://web.stanford.edu/class/archive/cs/cs103/cs103.1234/tools/truth-table-tool/
* Exclusive-or (xor) is `(p or q) and not (p and q)`. This is represented as  $p \oplus q$

### Mathematical Implication

* We can represent implications using this connection (an arrow)

  ![image-20230218170008624](image-20230218170008624.png)

* $p \rightarrow q$ will evaluate to true if the statement holds with the given inputs of $p$ and $q$.

* If $p$ is true, then $q$ is true. This means if $p$ is false, $q$ can be either true or false. But if $p$ is true, $q$ must be true.

  ![image-20230218170055883](image-20230218170055883.png)

![image-20230218170044976](image-20230218170044976.png)

### The Biconditional Connective (Contrapositive)

* The statement "$p$ if and only if $q$" means that both $p \rightarrow q$ and $q \rightarrow p$.

  ![image-20230218170120990](image-20230218170120990.png)

* The truth table of this connective has the same meaning as "$p$ implies $q$ and $q$ implies $p$".

![image-20230218170130726](image-20230218170130726.png)

* Relates to contrapositive because it has to either be both false or both true.

### True and False

* The symbol $\top$ is a value that is always true.
* The symbol $\bot$ is a value that is always false.

### Proof by Contradiction

* If we want to prove $p$ is true using a contradiction, the setup looks like this:
  1. Assume $p$ is false.
  2. Derive something that we know is false.
  3. Conclude that $p$ is true.
* In propositional logic, we have $(\neg p \rightarrow \bot) \rightarrow p$
  * Assuming p is false implies something that is always false, which implies that p must be true.

### Operator Precedence

* All operators are right-associative.
* We can use parentheses to disambiguate.

![image-20230218170206068](image-20230218170206068.png)

**<u>Main Ideas to Remember</u>**

* $\neg$ binds whatever immediately follows it.
* $\land$ and $\lor$ bind more tightly than $\rightarrow$.
  * An expression commonly written without parentheses is $p \land q \rightarrow r$

### Summary Table

![image-20230218170212609](image-20230218170212609.png)

### Translating into Propositional Logic

| <img src="cs103.assets/image-20230218170247439.png" alt="image-20230218170247439" style="zoom:50%;" /> | ![image-20230218170307110](image-20230218170307110.png) |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

### Propositional Equivalence

* To show that the statement $p \land q$ is false, we would have to show that $p$ is false or that $q$ is false.
* To show that the statement $p \lor q$ is false, we would have to show that both $p$ is false and $q$ is false.
* These equivalences are called **<u>de Morgan's Laws</u>**

![image-20230218170327747](image-20230218170327747.png)

* These equivalences hold to the truth tables too.
* We can use de Morgan's Laws to find equivalents to implies statements.

![image-20230218170359103](image-20230218170359103.png)

* When $p$ is false, $p \rightarrow q$ is true. When $p$ is true, $p \rightarrow q$ is only true if $q$ is true.

### Recap

![image-20230218170454588](image-20230218170454588.png)

* The truth table for the $\rightarrow$ connective (implication) is, assuming $p \rightarrow q$

| p    | q    | $p \rightarrow q$ |
| ---- | ---- | ----------------- |
| F    | F    | T                 |
| F    | T    | T                 |
| T    | F    | F                 |
| T    | T    | T                 |

* The negation of $p \rightarrow q$
  * $\neg (p \rightarrow q)$ is $p \land \neg q$

---

## Lecture 4: First-Order Logic 1

### First-Order Logic

* Logical system for reasoning about properties of objects
* Augments connectives from propositional logic with
  * **predicates** that describe properties of objects
  * **functions** that map objects to one another
  * **quantifiers** that allow us to reason about multiple objects

### Predicates

* Example

  * Likes(You, Eggs) $\land$ Likes(You, Tomato) $\rightarrow$ Likes(You, Shakshuka)
    * Read as "if you like eggs and you like tomatoes, then you like shakshuka"

  ![image-20230218170531939](image-20230218170531939.png)

  * Blue are constant symbols. They refer to objects.
  * The red are predicates. They take in objects and return true or false.

* We can connect the truth values of predicates using normal propositional connectives (e.g. $\land$, $\lor$, $\rightarrow$), because the predicates evaluate to true and false.

* To reason about objects, first-order logic uses predicates.
* Applying a predicate to arguments produce a proposition, which is either true or false.
* Predicate can take any number of arguments, but always returns a either true or false.

### First-Order Sentences

* Sentences in FOL can be constructed from predicates applied to objects
* Math relational symbols are also predicates

![image-20230218170626552](image-20230218170626552.png)

* The less than function above can also be written as $<(x, 8)$

### Equality

* The predicate $=$ says whether two objects are equal to one another
* Equality is part of FOL

![image-20230218170642504](image-20230218170642504.png)

### Functions

![image-20230218170725439](image-20230218170725439.png)

* The purple terms are not predicates because they do not evaluate to true or false. They are functions, taking an object as input and returning an object.
* The predicate in the term is the equal sign and the not equal sign.
* **Functions** evaluate to objects, not propositions. They can take any number of arguments, but always return a single value.

![image-20230218170751644](image-20230218170751644.png)

### Objects and Predicates

![image-20230218170802448](image-20230218170802448.png)

### The Type-Checking Table

![image-20230218170815029](image-20230218170815029.png)

### Variables and Quantifiers

* Each quantifier has two parts:
  * the variable that is introduced
  * the statement that's being quantified
* The variable introduced is scoped just to the statement being quantified

![image-20230218170836412](image-20230218170836412.png)

### Existential Quantifier

* A statement of the form: "$\exists x.$ `some-formula`" 
  * Is true if there exists some choice of $x$ where `some-formula` is true when that $x$ is plugged into it.

![image-20230218170844225](image-20230218170844225.png)

* The first example is spoken as "there exists a number $x$ where $x$ is even and $x$ is prime"
* The third example is spoken as "if there exists a will, there exists a way"

#### Example with Implies

* Suppose the statement is if there exists an $x$ where $x$ is smiling, then there exists a $y$ where $y$ is wearing a hat.
* We first check the antecedent of the implication

![image-20230218170927105](image-20230218170927105.png)

* The overall statement is false. There exists someone smiling but there doesn't exist anyone wearing a hat.

### Operator Precedence

* When writing our formulas in FOL, quantifiers have precedence just below $\neg$.
* The existential quantifier binds only the statement immediately following the period.

![image-20230218171000821](image-20230218171000821.png)

### Universal Quantifiers

* A statement of the form: "$\forall x.$ `some-formula`" 
  * Is true if, for every choice of $x$, the statement `some-formula` is true when that $x$ is plugged into it.

![image-20230218171008574](image-20230218171008574.png)

![image-20230218171012632](image-20230218171012632.png)

#### Edge Case

![image-20230218171032130](image-20230218171032130.png)

### Translating into Logic

* FOL can be useful tool for manipulating definitions and theorems.
* If we need to take a negation, we can translate the statement into FOL, negate it, then translate it back.
* If we want to prove something by contrapositive, translate the implication into FOL, then take the contrapositive, and translate it back.
* When translating English into first-order-logic, **think of first-order logic as a mathematical programming language**.
  * Goal is to combine basic concepts (quantifiers, connectives, etc) to say what you mean.

#### Example with Existential

![image-20230218171052202](image-20230218171052202.png)

Below is our answer:
$$
\exists x. (Smiling(x) \land WearingHat(x))
$$
### Summary

#### Existential Quantifier

![image-20230218171139081](image-20230218171139081.png)

![image-20230218171157512](image-20230218171157512.png)

#### Universal Quantifier

![image-20230218171203352](image-20230218171203352.png)

![image-20230218171207244](image-20230218171207244.png)

#### Good Pairings

![image-20230218171215339](image-20230218171215339.png)

### Set Theory Proofs

* Consider the following theorem:

> **Theorem**: For all sets $A$, $B$, $C$, $D$, and $E$, if $A \subseteq B \cup C$, $B \subseteq D$, and $C \subseteq E$, then $A\subseteq D \cup E$.

There is a clear **if** and **then** here. We can then write the first two sentences.

> **Proof:** Pick arbitrary sets $A$, $B$, $C$, $D$, and $E$, where $A \subseteq B \cup C$, $B \subseteq D$, and $C \subseteq E$. We want to show that $A \subseteq D \cup E$.

Here, make sure to not just restate the definitions without any new info. Use them and make the new sentences more load-bearing.

> **Incorrect**: Because $B\subseteq D$, we know that for all $x \in B$, $x \in D$.

When showing a subset relationship, do element analysis. Pick an arbitrary element of the set of the left, and show that it is an element of the set on the right.

> Pick an arbitrary $x \in A$. We want to shower that $x \in D\cup E$.

We can use what we know of subsets. Here, although we are stating a definition, it is actually load bearing.

> Since $x \in A$ and $A \subseteq B \cup C$, we know $x \in B\cup C$.

We can now use the definition of union.

> This means that $x \in B$ or $x \in C$. 

From here, we can continue the steps to get the completed proof below.

>**Theorem**: For all sets $A$, $B$, $C$, $D$, and $E$, if $A \subseteq B \cup C$, $B \subseteq D$, and $C \subseteq E$, then $A\subseteq D \cup E$.
>
>**Proof:** Pick arbitrary sets $A$, $B$, $C$, $D$, and $E$, where $A \subseteq B \cup C$, $B \subseteq D$, and $C \subseteq E$. We want to show that $A \subseteq D \cup E$. To do so, pick an arbitrary $x \in A$. We want to show that $x \in D\cup E$.
>
>Since $x \in A$ and $A \subseteq B \cup C$, we know $x \in B\cup C$. This means that $x \in B$ or $x \in C$. We will therefore proceed by cases:
>
>**Case 1: ** $x \in B$. Since $x \in B$, and $B \subseteq D$, we know that $x \in D$.
>
>**Case 1: ** $x \in C$. Since $x \in C$, and $C \subseteq E$, we know that $x \in E$.
>
>Collectively, these cases show that $x \in D$ or that $x \in E$. Therefore, we see that $x \in D \cup U$, as required.

---

## Lecture 5: First-Order Logic 2

> Some rabbit is cute
>
> $\exists m. (Rabbit(m) \land Cute(m))$

### Aristotelian Forms

![image-20230218171234631](image-20230218171234631.png)

* Generally, a universal quantifier is paired with an implies.
* Generally, an existential quantifier is paired with an and.

### Translating from English to FOL

Every person loves someone else.

> 1. Translate into a more logical english statement.
>
> Every person loves some other person. (gets us the predicate person)
>
> Every person $p$ loves some other person. (adds variables)
>
> 2. Connect to Aristotelian forms
>
> "All As are Bs"
>
> All persons are a person who loves someone else
>
> 3. Write it out one by one.
>
> $\forall p. (Person (p) \rightarrow \text{p loves some other person)}$
>
> $\forall p. (Person (p) \rightarrow \text{there is some other person other than p that p loves)}$
>
> $\forall p. (Person (p) \rightarrow \text{there a person q, other than p, where p loves q)}$
>
> $\forall p. (Person(p) \rightarrow \exists q. (Person(q) \text{, other than p, where p loves q})$
>
> $\forall p. (Person(p) \rightarrow \exists q. (Person(q) \land p \neq q \land Loves(p, q))$

There is a person that everyone else loves.

> There is a person p where everyone else loves p
>
> There is a person p where for all people q, other than p, q loves p
>
> There is a person p where for all q, if q is a person and q is not p, q loves p
>
> $\exists p. (Person(p) \land \text{everyone else loves p})$
>
> $\exists p. (Person(p) \land \forall q. (Person(q) \land p \neq q \rightarrow Loves(q, p)))$

* For the statements above, the $p \neq q$ comes from the fact that the original statement specifies "everyone **else**" and "someone **else**".

### Combining Quantifiers

![image-20230218171304347](image-20230218171304347.png)

![image-20230218171315801](image-20230218171315801.png)

### Set Translations

* For set translations, assume that we have the following predicates
  * $Set(S)$, which states that $S$ is a set
  * $x \in Y$, which states that $x$ is an element of $Y$
* First order logic does not have set operators or symbols built in. We can only use the connectives and the given predicates.

> Write a statement that means "the empty set exists"
>
> There is some set S that is empty.
>
> There is some set S and there are no elements in S.
>
> There is some set S and not (there is an element x in S)
>
> $\exists S. (Set(S) \land \neg \exists x. (x \in S))$
>
> There is some set S and every object x does not belong in S.
>
> $\exists S. (Set(S) \land \forall x. (x \notin S))$

### Useful Negations

![image-20230218171414491](image-20230218171414491.png)

![image-20230218171445505](image-20230218171445505.png)

* Examples

  > Find the negation of "There is a cute puppy"
  >
  > 1. The original statement is $\exists x. (Puppy(x) \land Cute(x))$
  >
  > $\neg \exists x. (Puppy(x) \land Cute(x))$
  >
  > $\forall x. \neg(Puppy(x) \land Cute(x))$
  >
  > $\forall x. (Puppy(x) \rightarrow \neg Cute(x))$
  >
  > 2. This says "No puppy is cute"


![image-20230218171451911](image-20230218171451911.png)

### Quantifying over Sets

![image-20230218171504318](image-20230218171504318.png)

* To quantify over sets, only use the ones below. Don't use variants of them.

![image-20230218171526222](image-20230218171526222.png)

### Expressing Uniqueness

* For this, we are given the following predicate
  * $WayToFindOut(w)$, which states that $w$ is a way to find out.

> Write a statement that says "There is only one way to find out."
>
> -> There is only one way to find out.
>
> -> Something is a way to find out, and nothing else is.
>
> -> Some thing $w$ is a way to find out, and nothing else is.
>
> -> Some thing $w$ is a way to find out, and nothing besides $w$ is a way to find out.
>
> $\exists w. (WayToFindOut(w) \land \text{nothing besides w is a way to find out})$
>
> $\exists w. (WayToFindOut(w) \land \text{anything that isn't w isn't a way to find out})$
>
> $\exists w. (WayToFindOut(w) \land \forall x. (x\neq w \rightarrow \neg WayToFindOut(x)))$
>
> You can take the contrapositive of the inside statement to get rid of the negations. Both statements are equal.
>
> $\exists w. (WayToFindOut(w) \land \forall x. (WayToFindOut(x) \rightarrow x = w))$

![image-20230218171552559](image-20230218171552559.png)

* Use this template whenever we want to express that this thing is unique. In other words, there is only one of this thing that satisfies the predicate.

---

## Lecture 6: Functions 1

### Functions

* Functions take input and give an output.
* In logic, functions are **deterministic**
  * Given the same input, the function must always produce the same output.

### Domains and Codomains

* Every function $f$ has two sets associated with it: the domain and the codomain.
* A function can only be applied to elements of its domain.
* For any x in the domain, $f(x)$ belongs to the codomain.
  * The codomain can be any superset of the actual codomain. For example,  think of mapping rational numbers to rational numbers. The codomain can be rational numbers, or real numbers, since rational numbers are a subset of real numbers.

![image-20230218172634576](image-20230218172634576.png)

#### Formal Definition of (Co)domains

* If $f$ is a function whoes domain is $A$ and whose codomain is $B$, we write $f: A \rightarrow B$.
  * A function $f$ that maps from domain $A$ to codomain $B$.
* Think of it like a function prototype in C++.

![image-20230218172727706](image-20230218172727706.png)

### Function Definition

* Functions $f: A \rightarrow B$ must follow the two rules below.

  1. $f$ must obey its domain/codomain rules

     ![image-20230218172813958](image-20230218172813958.png)

  2. $f$ must be deterministic

  ![image-20230218172817948](image-20230218172817948.png)

* These rules essentially state that there must be at least one output for some input, and that there must be at most one output for some input.

* Functions can have an empty domain.

* Functions can only have an empty codomain if the domain is also empty.


### Defining Functions

* To define a function, you need to 
  * specify the domain
  * specify the codomain
  * give a **rule** used to evaluate the function

#### Functions can be defined as a picture

![image-20230218172913393](image-20230218172913393.png)

#### Functions can be defined as a rule

$$
f: \Z \rightarrow \Z \text{, where} \\
f(x) = x^2 + 3x - 15
$$

* Use the $:$ notation to name the domain and codomain.
* Use the $f(x) = $ notation to define the function's action.

#### Rules can be given as piecewise

$$
f: \Z \rightarrow \N \text{, where} \\
f(n) = \begin{cases}
n & \text{if }  n \geq 0 \\
-n & \text{if }  n \leq 0
\end{cases}
$$

* Again, both parts of the rule ($:$ and $f(x)$) are necessary.
* Make sure at least one condition applies to each element of domain.
* Make sure that if more than one condition applies to the same element, they give the same answer.

### Involution

![image-20230218173137190](image-20230218173137190.png)

#### Examples of Involutions

![image-20230218173156340](image-20230218173156340.png)

#### Visually

| ![image-20230218173228736](image-20230218173228736.png) | ![image-20230218173233968](image-20230218173233968.png) |
| ------------------------------------------------------------ | ------------------------------------------------------------ |



* Check that all the mappings constitute a loop

#### Proving Involutions

![image-20230218173300395](image-20230218173300395.png)

* What does it mean to be an involution?
  * $\forall n \in \Z. f(f(n)) = n$
  * Therefore, we have the reader pick some $n \in \Z$, then argue that $f(f(n)) = n$
* Since the rule of the function is piecewise, it makes sense to do cases.

![image-20230218173315440](image-20230218173315440.png)

#### Proving not Involution

![image-20230218173334204](image-20230218173334204.png)

### Injection

![image-20230218173343665](image-20230218173343665.png)

* Every single element of the input maps to a different element in the output.

![image-20230218173359866](image-20230218173359866.png)

* Note that this is the reverse direction of our second rule for functions.
  * The rule for functions said $a_1 = a_2 \rightarrow f(a_1) = f(a_2)$
    * This means if same input then same output.
  * This one is the reverse of that.
    * This says if same output then same input.

#### Example

![image-20230218173449552](image-20230218173449552.png)

#### Proving injection

![image-20230218173511227](image-20230218173511227.png)

#### Proving not injection

![image-20230218173613037](image-20230218173613037.png)

### Surjection

#### Definition

![image-20230218173811515](image-20230218173811515.png)

#### Proving Surjection

![image-20230218173823823](image-20230218173823823.png)

#### Proving not Surjection

![image-20230218173837088](image-20230218173837088.png)

---

## Lecture 7: Functions 2

### Proof about Birds

![image-20230218173916300](image-20230218173916300.png)

* This problem above is an implication problem, of the form $A \to B$.
* To show this, assume $A$ and show that $B$ is true.
* To show that $B$ is true, since its a universal quantifier, we pick an arbitrary heron $h$.

![image-20230218173937588](image-20230218173937588.png)

### Proving vs. Assuming

![image-20230218173958649](image-20230218173958649.png)

![image-20230218174004722](image-20230218174004722.png)

### Proving and Assuming Table

![image-20230218174015864](image-20230218174015864.png)

### Connecting Functions

#### Involution and Surjection

> **Theorem:** For any function $f: A \to F$, if $f$ is an involution then $f$ is surjective.

1. Use the definitions of both.

   ![image-20230218174114473](image-20230218174114473.png)

   1. Note that this first order logic does not cover the "for any function $f$."
   2. Also note that the sets for $\forall b \in A$ and $\exists a \in A$ are the same sets in the surjective definition, even though its usually two sets. This is because to be an involution, $f$ maps $A$ to $A$, so both domain and codomain are same.

2. Assume that $f$ is an involution.

   1. Since we’re assuming this, we aren’t going to pick a specific choice of x right now. Instead, we’re going to keep an eye out for something to apply this fact to.

3. We now prove that $f$ is surjective.

   1. Firstly, we satisfy the universal quantifier. To do so, pick an arbitrary $b \in A$.
   2. Now we do the existential. We need to give a choice of $a \in A$ where $f(a) = b$.

![image-20230218174125054](image-20230218174125054.png)

* Notice that we assume the reader knows the definition of involution and surjection.

#### Involution and Injective

![image-20230218174202982](image-20230218174202982.png)

1. We first look at the definition.

![image-20230218174159786](image-20230218174159786.png)

2. We assume $P$ and prove that $Q$ is true. Thus, we assume that $f$ is an involution and prove that $f$ is injective.
3. Therefore, we first assume $f$ is an involution.
4. Now, we prove that $f$ is injective.
   1. To do so, pick arbitrary $a_1, a_2 \in A$.
   2. If we look at the inside of the quantifier, we see another implication. To prove if $p$ then $q$, assume $p$ is true then show $q$ is true.
   3. Therefore, assume $a_1 \neq a_2$. We can combine this with our pick to get the following sentence: Pick $a_1, a_2 \in A$ such that $a_1 \neq a_2$.
   4. Now, prove that $f(a_1) \neq f(a_2)$.

![image-20230218174223682](image-20230218174223682.png)

* This is a diagram of the proof.

  ![image-20230218174234178](image-20230218174234178.png)

  * Notice that since it's an involution, it must map back to itself. However, since both go to that same thing, it doesn't know what to map back to. For a function, an input can't map to two different things.

### Function Compositions

#### Codomain and Domains

* The codomain of $f$ is the domain of $g$.

![image-20230218174326923](image-20230218174326923.png)

#### Definition

![image-20230218174331762](image-20230218174331762.png)

#### Two Column Approach to Proofwriting

* Put everything we're assuming in the left column.
* Put everything we need to prove (our want-to-shows) in the right column.

#### Composition with Injection

##### Theorem

![image-20230218174415381](image-20230218174415381.png)

* Our arbitrary chosen values go in assumptions. Furthermore, the assumption in the want-to-show where $a_1 \neq a_2$ is also an assumption.

![image-20230218174455704](image-20230218174455704.png)

* Since we assume the antecedent and prove the consequent, we can separate it out.

![image-20230218174505449](image-20230218174505449.png)

##### Proof

![image-20230218174513305](image-20230218174513305.png)

#### Composition with Surjection

![image-20230218174529264](image-20230218174529264.png)

## Lecture 8: Functions 3

### Bijection

* Injective function associates **at most** one element of the domain with each element of the codomain.
* Surjective function associates **at least** one element of the domain with each element of the codomain.
* If we put these together, we have a function that maps exactly one element of domain with each element of the codomain.

![image-20230218174747858](image-20230218174747858.png)

* A function that is both injective and surjective. A proof for bijection would be a combination of two proofs: showing its injective and its surjective.

* It depends on the input domain and the output codomain (look at the last two).
* If you can define a bijection, then the domain and codomain have the same size.

![image-20230218174755486](image-20230218174755486.png)

### Cardinality

* Cardinality of a set is the number of elements that a set contains.
* Cardinalities are natural numbers for finite sets.
* For infinite sets, they have infinite cardinals (aleph nought)

![image-20230218174829191](image-20230218174829191.png)

* The intuition above is the definition of equal for infinite cardinalities.

![image-20230218174908965](image-20230218174908965.png)

* We only need to show that there exists a function that is a bijection.


### Terminology

![image-20230218174922555](image-20230218174922555.png)

### Example

* Consider the sets $[0, 1]$ and $[0, 2]$, how do their cardinalities compare?

![image-20230218174952737](image-20230218174952737.png)

* We define the function $f(x) = 2x$. We now prove that it is a bijection.

#### Theorem (Proof for Bijection and Cardinality)

![image-20230218175022093](image-20230218175022093.png)

##### Proving Functions

![image-20230218175046048](image-20230218175046048.png)

* Note that this proof can generalize to any $k$.

![image-20230218175058709](image-20230218175058709.png)

### Properties of Cardinality

#### Theorem 1 (Cardinality of same set):

![image-20230218175149024](image-20230218175149024.png)

#### Theorem 2 (Transitive property):

![image-20230218175153576](image-20230218175153576.png)

### Proving unequal cardinalities

![image-20230218175257757](image-20230218175257757.png)

### Cantor's Theorem

![image-20230218175319466](image-20230218175319466.png)

* We will now formally prove this statement.
* The goal is start with the picture and turn it into a rigorous proof.

#### Roadmap for Proof

![image-20230218175353292](image-20230218175353292.png)

* To show that a function is not a bijection, we simply have to show it is not injective or not surjective.

#### Diagonal Argument

Assume we are picking an arbitrary function $f$.

1. The items in the blue are the domain. The ones in the yellow are the codomain. Thus, we have that $f(x_i)$ be mapped to a certain subset of $S$.

   <img src="cs103.assets/image-20230218175438862.png" alt="image-20230218175438862" style="zoom: 67%;" />

2. <img src="cs103.assets/image-20230218175542690.png" alt="image-20230218175542690" style="zoom:67%;" />

4. Construct a new subset by looking at the diagonal. If the set that $x_i$ maps to contains $x_i$, then we include it. Otherwise, we don't include it.

   <img src="cs103.assets/image-20230218175614654.png" alt="image-20230218175614654" style="zoom:67%;" />

   * Suppose $x_6$ mapped to a set containing every element. Then, we would include $x_6$ in our new set, because the set that $x_6$ maps to contains $x_6$.

5. We now create a new subset by flipping the set. This is still a subset of $S$, so it is an element of the power set. To show that the function is surjective, there has to be some $x_i$ that points to this set.

   <img src="cs103.assets/image-20230218175636581.png" alt="image-20230218175636581" style="zoom:67%;" />

6. We can go down one by one and look at the diagonal.

   * If the diagonal is empty, it is included in our set. In other words, if the set mapped to $x_i$ does not contain $x_i$, include that in our set.

     * Therefore, this function can not map to any $x_i$ that is included in the set because we know that $x_i$ maps to a set that does not contain $x_i$.

     <img src="cs103.assets/image-20230218175651228.png" alt="image-20230218175651228" style="zoom:67%;" />

   * If the diagonal is non-empty, it is excluded from our set. In other words, the set mapped to $x_j$ contains $x_j$, exclude that from our set.

     * Therefore, this function can not map to any $x_j$ that is excluded from the set because we know that $x_j$ maps to a set that contains $x_j$.

     ![image-20230218175720629](image-20230218175720629.png)

7. We can define this set as the diagonal set.

   ![image-20230218175726775](image-20230218175726775.png)

8. This diagonal set is guaranteed to not be mapped to any $x_i$.

### The Diagonal Set

![image-20230218175733136](image-20230218175733136.png)

### Theorem (Cantor's Theorem)

![image-20230218175747125](image-20230218175747125.png)

---

## Lecture 9: Graph Theory 1

### Graphs

* A mathematical structure for representing relationships.
* A graph consists of a set of nodes (or vertices) connected by edges (or arcs)

| ![image-20230218215620858](image-20230218215620858.png) | ![image-20230218215631172](image-20230218215631172.png) |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

* Some graphs are directed. They're represented in a picture by arrow heads.
  * Also known as digraph. Edges have an associated direction.
* Some graphs undirected. Every edge shows a relationship between both vertices.
  * Edges link nodes, with no endpoint preferred over the other.
* In this class, graphs usually mean undirected graph.

| Directed                                                     | Undirected                                                   |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![image-20230218215643796](image-20230218215643796.png) | ![image-20230218215647201](image-20230218215647201.png) |

### Formalizing Graph

![image-20230218215719791](image-20230218215719791.png)

* Since it's an ordered pair, we use the parentheses instead of brackets.

#### Self Loops

![image-20230218215813806](image-20230218215813806.png)

### Graphs and FOL

1. Universal and Existential

   ![image-20230218215852160](image-20230218215852160.png)

   * The formula above is true. In English, it states that for every vertex u, there exists a vertex v such that u and v share an edge.
     * If we look at the graph above, we see that every vertex has at least one other vertex that it shares an edge with.

2. Existential and Universal

   ![image-20230218215858452](image-20230218215858452.png)

   * The formula above is not true. In English, it states that there exists a vertex u such that for every vertex v, u and v share an edge.
     * The statement is not possible because a vertex can't share an edge with itself. Therefore, $\{u, u\} \notin E$.

3. Negation of (2)

   ![image-20230218215949198](image-20230218215949198.png)

   * The formula above is true. In English, it states that for all u, there exists v such that u and v do not share an edge.
     * This satisfies the self-loop. Since no vector is connected to itself, it satisfies this.

### Vertex Covers

![image-20230218220125071](image-20230218220125071.png)

### Independent Sets

![image-20230218220233133](image-20230218220233133.png)

### Connection between IS and VC

#### Theorem

![image-20230218220319551](image-20230218220319551.png)

* To prove the biconditional above, we have to separately prove the forward and reverse implications.

![image-20230218220859345](image-20230218220859345.png)

* We first prove Lemma 1

![image-20230218220335907](image-20230218220335907.png)

![image-20230218220341045](image-20230218220341045.png)

![image-20230218220344792](image-20230218220344792.png)

* We've proved the forwards direction. We now have to prove the backwards direction. This is easier to prove in its contrapositive form.

![image-20230218220421576](image-20230218220421576.png)

![image-20230218220432491](image-20230218220432491.png)

![image-20230218220436484](image-20230218220436484.png)

### Recap

![image-20230218221047952](image-20230218221047952.png)

---

## Lecture 10: Graph Theory 2

### Adjacency

![image-20230218221119034](image-20230218221119034.png)

![image-20230218221124803](image-20230218221124803.png)

### Walk

![image-20230218221141042](image-20230218221141042.png)

* Sequences are written as a comma separated list
  * The order matters, so it's not a set

### Length

* The length of a walk is the number of edges traversed.

![image-20230218221151415](image-20230218221151415.png)

* A walk can have a length of 0. It would just have a single node with no edges.

### Closed Walk

![image-20230218221221481](image-20230218221221481.png)

* In a closed walk, the first item in a list and the last item in the list are the same.

### Path

![image-20230218221235834](image-20230218221235834.png)

* All paths are walks, but not all walks are paths.
* In other words, the path has no cycles.

### Cycle

![image-20230218221258428](image-20230218221258428.png)

### Reachable

![image-20230218221356335](image-20230218221356335.png)

### Connected

![image-20230218221403786](image-20230218221403786.png)

* The graph below is not connected.

![image-20230218221420194](image-20230218221420194.png)

#### Connected Components

![image-20230218221427628](image-20230218221427628.png)

* The two yellow chunks above are individual connected components.

### Given Theorems

![image-20230218221442442](image-20230218221442442.png)

### Graph Complements

![image-20230218221525146](image-20230218221525146.png)

* We basically flip all the edges. If there was an edge, make it not an edge. If there wasn't an edge, make it an edge.

#### Theorem

![image-20230218221534988](image-20230218221534988.png)

#### Work

* Here, we are proving a disjunction.

![image-20230218221543151](image-20230218221543151.png)

* Consider the graph below. It is not connected.

![image-20230218221548773](image-20230218221548773.png)

* Look at the picture below. You see that nodes in the two different connected components end up connecting to each other in the complement.

![image-20230218221601212](image-20230218221601212.png)

#### Proof

![image-20230218221616200](image-20230218221616200.png)

### The Pigeonhole Principle

![image-20230218221635479](image-20230218221635479.png)

#### Examples with Functions

![image-20230218221702526](image-20230218221702526.png)

* (1) is false. It is not injective.
* (2) is true. Since $|A| > |B|$, by the Pigeonhole principle, at least one output will have at least two inputs map to it.
* (3) is false. Even though $|A| > |B|$, every single input in $|A|$ could point to the same bin.
* (4) is false. It is possible for $f$ to be surjective. There are more inputs than outputs.

#### Proving the Pigeonhole

![image-20230218221709444](image-20230218221709444.png)

### Degrees

![image-20230218221825081](image-20230218221825081.png)

#### Theorem with Degrees

![image-20230218221829080](image-20230218221829080.png)

* Consider the sample graph below. For the stuff below, if a letter is in the bucket, it is that degree.

![image-20230218221840042](image-20230218221840042.png)

* Note that with $n$ nodes, there are $n$ possible degrees $(0, 1, 2, \dots, n-1)$
* In our example, we have 6 nodes and 6 possible degrees.
* Question: will will ever be able to use bin 0 and bin 5 at the same time? (not necessarily with the same vertex)
  * No, we won't. If the node is in bin 5, it means the node is connected to every other node. However, that means there can't be anything in bin 0, since every other node has at least one connection to it: the node in bin 5.

![image-20230218221850495](image-20230218221850495.png)

* We can combine the 0 and 5 bin into one. Now, we have 5 bins and 6 nodes. We can now invoke the Pigeonhole principle.

#### Proof 1

* This proof uses the Pigeonhole principle.

![image-20230218221901924](image-20230218221901924.png)

#### Proof 2

* This proof doesn't use the Pigeonhole principle.

![image-20230218221906907](image-20230218221906907.png)

### Generalized Pigeonhole Principle

* If several times more birds than bins, can you say that at least one bit has at least three, etc?

![image-20230218221956477](image-20230218221956477.png)

* For the example above, there are 11 birds. Note that $11 / 5 = 2.2$
* Some bin will have at least ceiling ceiling m / n objects in it. This means the number would have to round up.

#### Proof

![image-20230218222018749](image-20230218222018749.png)

### Application: Friends and Strangers

* Suppose you have a party of six people. Each pair of people are either friends (they know each other) or strangers (they do not).

#### Theorem

![image-20230218222030926](image-20230218222030926.png)

#### Diagrams

* ![image-20230218222045873](image-20230218222045873.png)

##### Clique

* A clique is a graph where every possible adjacency is present.

![image-20230218222055490](image-20230218222055490.png)

* Consider the clique above, we will color the edges.
  * Blue means the people know each other.
  * Red means the people don't know each other.

![image-20230218222109996](image-20230218222109996.png)

* Does there exist a red triangle or a blue triangle? This means there's either 3 strangers or 3 friends.

* Pick an arbitrary node and consider its edges. Arbitrarily color the edges.

  ![image-20230218222208302](image-20230218222208302.png)

* One observation we see here is

  ![image-20230218222242882](image-20230218222242882.png)

* The 5 comes from the number of adjacent neighbors. The 2 comes from the 2 colors, red and blue.

* Pick any three node that is connected to our node.

![image-20230218222305433](image-20230218222305433.png)

* These three nodes make multiple different triangles.

* We now consider the possibilities.

  * If there is a blue edge in the middle, we've found our triangle.

    ![image-20230218222310856](image-20230218222310856.png)

  * If there is a red edge there, we consider the next edge. If that one is blue, we've found our triangle.

    ![image-20230218222316879](image-20230218222316879.png)

  * If that edge is also red, we keep looking at the next one.

    ![image-20230218222329588](image-20230218222329588.png)

    * If that edge is blue, we've found a triangle. If it's red, there's also a triangle there.

    ![image-20230218222333368](image-20230218222333368.png)

#### Proof

![image-20230218222341230](image-20230218222341230.png)

### Ramsey Theory

![image-20230218222409414](image-20230218222409414.png)

### More Pigeonhole Principle Stuff

![image-20230218222432127](image-20230218222432127.png)

---

## Lecture 12: Induction 1

* Suppose we want to prove a predicate over the set of all natural numbers, we can use this.
  * E.g. prove some equation is true for all inputs

![image-20230218222705069](image-20230218222705069.png)

* Intuitively, induction is like an infinite sequence of implications, showing that is true for all numbers.

![image-20230218222714558](image-20230218222714558.png)

### Proof by Induction

![image-20230218222934325](image-20230218222934325.png)

* Assume $P(k)$ is true, then prove that $P(k+1)$ is true

### Example: Sums of Powers of Twos

![image-20230218222947735](image-20230218222947735.png)

#### Step-by-Step

* In a proof by induction, we have to show two things:

  * That $P(0)$ is true.

    * State that we need to show that $P(0)$ is true, then prove that $P(0)$ is true.

  * That if $P(k)$ is true, then $P(k+1)$ is true for some arbitrary $k$.

    * We assume arbitrary $k \in \N$ because we want to show that is is true for all $\N$.

    * Now we choose an arbitrary $k$ and say we assume $P(k)$ holds.

    * Now we want to show that $P(k+1)$ is true.

    * We now prove $P(k+1)$ by building from our inductive hypothesis.


#### Theorem & Proof

![image-20230218223100359](image-20230218223100359.png)

#### Result

![image-20230218223110819](image-20230218223110819.png)

### Structure of Proof by Induction

![image-20230218223117258](image-20230218223117258.png)

### Example: Counterfeit Coins Problem

#### 3 Counterfeit Coins

![image-20230218223128112](image-20230218223128112.png)

* If we pick two coins and weigh it, and we see that it tips one way over the other, then we know that the coin its tipping towards is counterfeit.

  * Two real coins would have a balanced scale. So if its balanced, coin 3 is counterfeit.

    ![image-20230218223154196](image-20230218223154196.png)

  * In the case below, we know coin 1 is the counterfeit coin.

    ![image-20230218223134985](image-20230218223134985.png)

#### 9 Counterfeit Coins

![image-20230218223236040](image-20230218223236040.png)

* We can do this by weighing 6 coins, and leaving 3 coins on the side.

  * If the scale tips towards one side, we know the counterfeit coin is on that side. We do the weighing again for those three coins like the problem above.

    ![image-20230218223243610](image-20230218223243610.png)

  * If the scale is balanced, we know the counterfeit coin is one of the three left out on the side.

    ![image-20230218223249326](image-20230218223249326.png)

#### Generalize

![image-20230218223319359](image-20230218223319359.png)

![image-20230218223331794](image-20230218223331794.png)

### Common errors with Induction

#### Example 1

![image-20230218223349090](image-20230218223349090.png)

* The proof above skips the base case. Because of that, we managed to create a convincing proof for an incorrect theorem.

#### Example 2

![image-20230218223450931](image-20230218223450931.png)

![image-20230218223504500](image-20230218223504500.png)

* In the proof above, there is an error in paragraph 3. The whole argument relies on the fact that there are horses in the middle. Since we pick an arbitrary k, that could be any natural number. Thus if k equals one, there is no horse in the middle, so our argument falls apart.

![image-20230218223514676](image-20230218223514676.png)

### The MU Puzzle

![image-20230218223542550](image-20230218223542550.png)

![image-20230218223549718](image-20230218223549718.png)

![image-20230218223556093](image-20230218223556093.png)

![image-20230218223622722](image-20230218223622722.png)

![image-20230218223625915](image-20230218223625915.png)

---

## Lecture 13: Induction 2

### Induction Debugging Tips

![image-20230218223701189](image-20230218223701189.png)

### Variations on Induction

#### Starting Later

* Ordinarily, induction starts at 0. We can also have induction starting at a number.

![image-20230218223710551](image-20230218223710551.png)

![image-20230218223714320](image-20230218223714320.png)

#### Bigger Steps

* We can take bigger steps by one.
  * As example, suppose we want to subdivide a square into smaller squares.

| ![image-20230218223723301](image-20230218223723301.png) | ![image-20230218223740577](image-20230218223740577.png) |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![image-20230218223747024](image-20230218223747024.png) | ![image-20230218223755762](image-20230218223755762.png) |

* For values of $n$ can a square be subdivided into $n$ squares?

![image-20230214130858593](/Users/jack/Library/Application Support/typora-user-images/image-20230214130858593.png)

* Consider the case of $n = 2, 3$. We can't have these because it wouldn't make a square.

![image-20230218223824954](image-20230218223824954.png)

* Similarly $n =5$ would not make squares.

![image-20230218223835466](image-20230218223835466.png)

* Insight:

  ![image-20230218223935807](image-20230218223935807.png)

  * Given any square, we can always subdivide it into 4 squares. Then using those four, we can subdivide that smaller one into 4 more squares. 

  ![image-20230218223853389](image-20230218223853389.png)

* We can keep repeating this to have an infinite number of squares.

![image-20230218224005713](image-20230218224005713.png)

* Note that in the proof above, the inductive step just requires us to have one square. Thus, it would also work for $k \geq 1$. However, we do $k \geq 6$ here because we would not be able to do the base cases with numbers below 6.

### Generalizing Induction

![image-20230218224014395](image-20230218224014395.png)

### Revisiting Ramsey Theory

![image-20230218224028941](image-20230218224028941.png)

![image-20230218224038927](image-20230218224038927.png)

![image-20230218224136304](image-20230218224136304.png)

#### Observation

* Look at this problem in relation to the friends and strangers proof from before.

![image-20230218224101998](image-20230218224101998.png)

### Build up with existential

![image-20230218224111217](image-20230218224111217.png)

### Build down with universal

![image-20230218224122122](image-20230218224122122.png)

### Complete Induction

* This is also known as strong induction.
* In regular induction, we assume $P(0)$ is true and $P(k)$ is true, then prove $P(k+1)$.
* Here, we assume $P(0), P(1), \dots, P(k)$ is true. Then we prove $P(k+1)$.
* Our want to show is still the same, we just assume more now.

![image-20230218224159365](image-20230218224159365.png)

![image-20230218224206159](image-20230218224206159.png)

![image-20230218224211780](image-20230218224211780.png)

* Note that the conclusion is also the same. The only thing that changes is our assumption.
* It uses the reasoning of regular induction and takes advantage of how if we assume $P(k)$ and prove $P(k+1)$ is true then its all true to make proofs.
* Takes advantage of the $P(1), P(2), \dots, P(k-1)$ instead of just vacuously assuming it and disregarding it.

#### Example: Eating a chocolate bar

![image-20230218224348930](image-20230218224348930.png)

![image-20230218224355314](image-20230218224355314.png)

![image-20230218224404433](image-20230218224404433.png)

* For this problem, our base case is $P(1)$ because we start with a $1\times1$ chocolate bar.

![image-20230218224429887](image-20230218224429887.png)

![image-20230218224444254](image-20230218224444254.png)

* Note for the inductive step that it says $k \geq 1$. This means that it is possible for $k = 1$. Thus, the line $P(1), \dots\, P(k)$ could just have one item, that being $P(k) = P(1)$.
* The equation we want to show is that $P(n) = 2^{n-1}$.
* We have a $k+1$ length bar. If we eat a $1\times1$ piece, the number of ways we can eat the remaining pieces is $P(k-1)$. If we eat a $1 \times 2$ piece, the number of ways we can eat the remaining pieces is $P(k-2)$.
* The equation at the bottom essentially states that the ways to eat this chocolate bar is $P(1) + P(2) + \dots + P(k-1) + P(k) + 1$, where the 1 comes from the fact that we can eat the whole bar.

### Induction vs. Complete Induction

![image-20230218224234996](image-20230218224234996.png)

![image-20230218224239665](image-20230218224239665.png)

* If we don't know how far back we need to reach with our assumption, then complete induction is good over regular induction.

  * E.g. for the chocolate, the person took a bite of size $r$. We don't know what $r$ is, so we don't know how far back to go.

  ![image-20230218224306284](image-20230218224306284.png)

* If you know the exact step size forwards and back, then you can use regular induction.

  ![image-20230218224259630](image-20230218224259630.png)

---

## Lecture 14: Finite Automata 1

### Automata

* An ==automaton== is a mathematical model of a computing device.
  * It's an abstraction of a real computer.

#### Example

![image-20230221225456570](image-20230221225456570.png)

### Computing with Finite Memory

![image-20230221225546500](image-20230221225546500.png)

### Modeling Finite Computation

![image-20230221225738685](image-20230221225738685.png)

<img src="cs103.assets/image-20230221225933930.png" alt="image-20230221225933930" style="zoom:50%;" />

| ![image-20230221225841332](image-20230221225841332.png) | ![image-20230221225847690](image-20230221225847690.png) | ![image-20230221225851058](image-20230221225851058.png) |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![image-20230221225854669](image-20230221225854669.png) | ![image-20230221225858384](image-20230221225858384.png) | ![image-20230221225901473](image-20230221225901473.png) |

![image-20230221230027952](image-20230221230027952.png)

![image-20230221230112622](image-20230221230112622.png)

### Alphabets, Strings, and Languages

#### Alphabets and Strings

![image-20230221230210629](image-20230221230210629.png)

* It needs to be finite because we must know where to end.
* Strings are a sequence, not a set. This is because duplicates are allowed and order matters in strings.

#### Languages

![image-20230221230322041](image-20230221230322041.png)

* The powerset of $\Sigma^*$ is the set of all subsets of $\Sigma^*$. Since every language $L$ is defined as $L \subseteq \Sigma^*$, the powerset of $\Sigma^*$ is the set of all languages over $\Sigma$.
* The set $\Sigma^*$ has infinite cardinality, for any $\Sigma$.

#### Summary

![image-20230221230556638](image-20230221230556638.png)

![image-20230222222439649](image-20230222222439649.png)

### Automata and Language

![image-20230221230625781](image-20230221230625781.png)

#### Examples

![image-20230221230703246](image-20230221230703246.png)

![image-20230221230951368](image-20230221230951368.png)

* Note that self-loops are allowed.

#### Summary

![image-20230221230833703](image-20230221230833703.png)

### Deterministic Finite Automata

* There can be a few issues with what we have designed so far.

| ![image-20230221231045381](image-20230221231045381.png) | ![image-20230221231050607](image-20230221231050607.png) |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

* DFAs serve to mitigate these issues.

![image-20230221231127689](image-20230221231127689.png)

![image-20230221231232801](image-20230221231232801.png)

#### Modulo Example

![image-20230221231347815](image-20230221231347815.png)

* Getting to an `a` does not change our state. Only when we reach `b` do we care, since we want to find its count modulo three.

#### Substring Example

![image-20230221232509071](image-20230221232509071.png)

![image-20230221231358338](image-20230221231358338.png)

* Once we find an `aa` substring, we can just keep staying at the accepted state.

#### Comments Example

![image-20230221231514706](image-20230221231514706.png)

![image-20230221231519260](image-20230221231519260.png)

* Note that the above creates a failure state, that stays there as soon as you reach it. This is similar to like returning false.

## Lecture 15: Finite Automata 2

### Formal Language Theory

![image-20230221231838208](image-20230221231838208.png)

![image-20230221232150055](image-20230221232150055.png)

![image-20230221232307644](image-20230221232307644.png)

* The language of a DFA where the set of accepting states is an empty set is the empty set.

### Tabular DFAs

* We can represent DFAs as a table.

![image-20230221232719191](image-20230221232719191.png)

* The leftmost column is the current state. The corresponding entry in the `0` and `1` column is where to go if we read a `0` or a `1`.
* The ==first row is the start state==.
* Note that `q3` is a $\Sigma$, both transitions go back to itself.

### Regular Languages

![image-20230221233010555](image-20230221233010555.png)

* A language $L$ is a regular language if there exists a DFA $D$ such that $L$ is the language of $D$.
* A DFA **accepts** strings, but **recognizes** languages



### Complement of a Language

![image-20230221233246353](image-20230221233246353.png)

* To build a DFA that is the complement of L, build the DFA for L and then swap the accepting and rejecting states.

#### Example 1

![image-20230222002546029](image-20230222002546029.png)

#### Example 2

![image-20230222002628546](image-20230222002628546.png)

![image-20230222002635210](image-20230222002635210.png)

### Closure Properties

![image-20230222002807423](image-20230222002807423.png)

* To prove the question, we have that if L-complement is not regular, then L is not a regular language. Thus, the non-regular languages is closed under complementation.

  ![image-20230222003250500](image-20230222003250500.png)

* For any single string, we can always find a DFA for that string.

  ![image-20230222003010573](image-20230222003010573.png)

  * The first one also needs a garbage state. It's not shown in the image. If it doesn't follow our specified path it goes straight to the garbage state.
  * The second one is the DFA for $\Sigma^*$. It accepts every string.

### NFAs

* We revisit the problem from last lecture

![image-20230222004140072](image-20230222004140072.png)

* This problem breaks DFAs because when you're at $q_0$, and you reach a $1$, you don't know which one to go to.
* That's why we made DFAs. It made it so that at every state that you're in, for every character that you read, there is exactly one destination state.

![image-20230222004753055](image-20230222004753055.png)

* NFAs lift the limitation that we had with DFAs
  * Every DFA is an NFA.
  * The notation for the transition functions is:
    * For DFA, the transition is $\delta$. For each transition, the cross product of $S$ and $\Sigma$ goes to another state in $S$. In other words, for each state and for each letter of of the alphabet, it goes to exactly one state.
    * For NFA, the transition is $\delta$. For each transition, the cross product of $S$ and $\Sigma$ goes to a subset of $S$. In other words, for each state and for each letter of of the alphabet, it had a set of destinations, each of which are states in $S$.
      * You could go to many destinations or no destinations, because the empty set is a subset of $S$.

![image-20230222005154588](image-20230222005154588.png)

* In a DFA, we can process a given string 20 times and always end up in the same state.
* In an NFA, we can process the same string twice and end up different states.
* An NFA accepts a string is there exists a choice of string that leads to an accepting state.
  * For a given string, if there are 20 different paths through the NFA, but 19 end up in a non-accepting state and only one ends up in an accepting state, that string is still accepted.

#### Example of NFAs

![image-20230222005511703](image-20230222005511703.png)

* There are multiple ways to go through this NFA with a given string.

| ![](image-20230222005549859.png) | ![image-20230222005606294](image-20230222005606294.png) | ![image-20230222005621457](image-20230222005621457.png) |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![image-20230222005633119](image-20230222005633119.png) | ![image-20230222005639632](image-20230222005639632.png) | This is way possible traversal of this NFA. For every 1, we take the path where we stay at $q_0$. |

| ![image-20230222005748979](image-20230222005748979.png) | ![image-20230222005758026](image-20230222005758026.png) | ![image-20230222005805546](image-20230222005805546.png) |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![image-20230222005813840](image-20230222005813840.png) | ![image-20230222005820418](image-20230222005820418.png) | This is another traversal of the same NFA with the same string, It succeeds now. |

* For the above, since there existed a path that got us to the accepted state, the NFA accepts the string.

### Dead Automatons in NFA

![image-20230222005959551](image-20230222005959551.png)

* The string `01011` is accepted. A possible traversal that dies is below. When we're at $q_1$ we reach a $0$, but there is not $0$ path from $q_1$.

<img src="cs103.assets/image-20230222010407809.png" alt="image-20230222010407809" style="zoom:50%;" />

#### Example

| ![image-20230222010056392](image-20230222010056392.png) | ![image-20230222010103670](image-20230222010103670.png) |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

* With NFAs, you don't need a garbage state. If it reaches a character that doesn't have a transition it just dies at that point.

![image-20230222010210726](image-20230222010210726.png)

* Because it's an NFA, the "ends in `aaa`" does not work. The string `abaa` would be accepted.

### ε-Transitions

* NFAs have a special transition called the ==ε-transition==.
* An NFA may follow any number of ε-transitions at any time without consuming any input.

<img src="cs103.assets/image-20230222010746677.png" alt="image-20230222010746677" style="zoom:50%;" />

* For the diagram above, the string `baabb` is accepted. it would follow the path below

  <img src="cs103.assets/image-20230222011130875.png" alt="image-20230222011130875" style="zoom:50%;" />

* NFAs are not required to follow ε-transitions. It's simply another option at the machine's disposal.

### Intuiting Nondeterminism

![image-20230222011332909](image-20230222011332909.png)

#### Perfect positive guessing

![image-20230222011420974](image-20230222011420974.png)

* For example, if it's at a state with multiple transitions with the same character label or epsilon transitions, the machine is able to perfectly guess the correct choice to the to the accepting state.

#### Massive parallelism

| ![image-20230222011527574](image-20230222011527574.png) | ![image-20230222011535327](image-20230222011535327.png) |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![image-20230222011542256](image-20230222011542256.png) | ![image-20230222011549839](image-20230222011549839.png) |
| ![image-20230222011556771](image-20230222011556771.png) | ![image-20230222011607425](image-20230222011607425.png) |
| ![image-20230222011614647](image-20230222011614647.png) | ![image-20230222011621595](image-20230222011621595.png) |
| ![image-20230222011630347](image-20230222011630347.png) | ![image-20230222011640368](image-20230222011640368.png) |

* Essentially every time we get to a junction, we split off and explore each junction. If we find one that reaches an accepting state, we end early and let the computer know that the string is accepted.

![image-20230222011840483](image-20230222011840483.png)

### Designing NFAs

![image-20230222011921060](image-20230222011921060.png)

#### Example 1

<img src="cs103.assets/image-20230223003550391.png" alt="image-20230223003550391" style="zoom: 67%;" />

![image-20230223003637202](image-20230223003637202.png)

* The two NFAs above are each for finding if a string ends with a `010` or a `101`.

![image-20230222011932501](image-20230222011932501.png)

* Now, we just guess that the end of the string is coming up by connecting these two together.

![image-20230223004556789](image-20230223004556789.png)

![image-20230223004728635](image-20230223004728635.png)

* For reference, below is the DFA for this language.

![image-20230223004820510](image-20230223004820510.png)

#### Example 2

![image-20230223004857275](image-20230223004857275.png)

* We first consider a few examples of this.
  * `abababab` and `bcbcbcbc` are some examples of this.
  * Each string in this language is using at most two of the letters in this alphabet.

<img src="cs103.assets/image-20230223005026673.png" alt="image-20230223005026673" style="zoom:80%;" />

<img src="cs103.assets/image-20230223005040114.png" alt="image-20230223005040114" style="zoom:50%;" />

* Note that the empty string falls under all three of these sub-languages

![image-20230223005244083](image-20230223005244083.png)

* For reference this is the DFA for this.

![image-20230223005326107](image-20230223005326107.png)

---

## Lecture 16: Finite Automata 3

### NFAs and DFAs

![image-20230223005630150](image-20230223005630150.png)

![image-20230223005715434](image-20230223005715434.png)

### Translating an NFA into a DFA

![image-20230223010042508](image-20230223010042508.png)

| ![image-20230223010112887](image-20230223010112887.png) | ![image-20230223010151300](image-20230223010151300.png) | The blue arrows are possible states that we can go to with "a". |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |

<img src="cs103.assets/image-20230223010258429.png" alt="image-20230223010258429" style="zoom:50%;" />

* The above also applies for an "a" located anywhere in the sequence.
  * If we see an "a" and we're at $q_0$, our possible choices are to stay in $q_0$ or go to $q_1$.

* We can build a table with each of these possibilities.

![image-20230223010615146](image-20230223010615146.png)

* We now take these possible states for $q_0$ and add it to our row label as a state we can be in.

| ![image-20230223011032288](image-20230223011032288-7143432.png)![image-20230223011045100](image-20230223011045100.png) | We union these possible states. From $q_1$ if we see an $a$ we just die. From $q_0$, if we see an $a$ we can get to $q_0$ and $q_1$. |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

| ![image-20230223011126600](image-20230223011126600.png)![image-20230223011138125](image-20230223011138125.png) | Similarly we union these possible states. From $q_0$ if we see a $b$ we can get to $q_0$. From $q_1$ if we see a $b$ we can get to $q_2$. |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

* If we continue the steps above, we can get the following table and the resulting DFA. The labels on each state are sets of states.

![image-20230223011310029](image-20230223011310029.png)

* Our accepted state is where at least one element of the row is the accepted state.

![image-20230223011530836](image-20230223011530836.png)

* We now look at how a string would move through this below. The top is the NFA. The bottom one is the DFA.

| ![image-20230223011836184](image-20230223011836184.png) | ![image-20230223011844862](image-20230223011844862.png) |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![image-20230223011854088](image-20230223011854088.png) | ![image-20230223011912811](image-20230223011912811.png) |
| ![image-20230223011921273](image-20230223011921273.png) | ![image-20230223011929152](image-20230223011929152.png) |

* We see that this string is accepted, because it reaches the accepted state.

![image-20230223011957423](image-20230223011957423.png)

### The Subset Construction

![image-20230223012116762](image-20230223012116762.png)

![image-20230223012152847](image-20230223012152847.png)

### Regular Languages

* From before, we know the following fact.

![image-20230223012231687](image-20230223012231687.png)

* We now extend this to an NFA.

![image-20230223012430181](image-20230223012430181.png)

![image-20230223012457382](image-20230223012457382.png)

### Properties of Regular Languages

#### Union of Two Languages

![image-20230223012643250](image-20230223012643250.png)

* We saw this idea at the end of last lecture.

* Yes, $L_1 \cup L_2$ is a regular language.

  * Pick two arbitrary regular languages $L_1$ and $L_2$.
  * Since $L_1$ is regular, there exists an NFA or a DFA for it.
  * Since $L_2$ is regular, there exists an NFA or DFA for it.
  * We now have to show there exists a machine (NFA or DFA) for the union.
  * We just make a start state and hook up epsilon transitions to each of the machines or $L_1$ and $L_2$.

* This machine is the machine for $L_1 \cup L_2$.

* Note that this is not biconditional. Breaking a language into two parts does not guarantee that the two parts are regular.

  * Consider the empty language $\emptyset$ (the empty set is the empty language because languages are sets).

    * This is a regular language. We can make a DFA as follows.

      ![image-20230223013519724](image-20230223013519724.png)

    * The language above has every character going from the start state to itself without an accept state. This language does not accept any strings.

  * Consider the language $\Sigma^*$. This is also a regular language.

    ![image-20230223013829381](image-20230223013829381.png)

    * This language accepts every string.
    * Since $\Sigma^*$ is a regular language, we see that obviously if we break it into two parts we're not guaranteed to have two regular languages.

#### Intersection of Two Languages

![image-20230223014526539](image-20230223014526539.png)

* Pick arbitrary languages $L_1$ and $L_2$. Is their intersection regular?

<img src="cs103.assets/image-20230223014237252.png" alt="image-20230223014237252" style="zoom:50%;" />

* We talked last lecture that regular languages are closed under complement. The complement of $L_1$ and $L_2$ are as follows.

<img src="cs103.assets/image-20230223014346034.png" alt="image-20230223014346034" style="zoom:50%;" />

* We know that the two languages above are regular because they are the complement of regular languages.

* We now take the union of them. We know regular languages are closed under union.

  <img src="cs103.assets/image-20230223014432822.png" alt="image-20230223014432822" style="zoom:50%;" />

* We know take the complement of the union of the complements.

![image-20230223014511278](image-20230223014511278.png)

* This is the same as the intersection of the two languages. We know that this is a regular language because it was the complement of a regular language.
* Therefore, the intersection of the two regular languages is a regular language.

### Concatenation

* Regular languages are closed under concatenation.

#### String Concatenation

![image-20230223014814485](image-20230223014814485.png)

* In the above, $w$ and $x$ are strings.

#### Language Concatenation

![image-20230223015005573](image-20230223015005573.png)

* The concatenation of languages is the string concatenation of every pair of strings in the two languages.
* All strings $w$ drawn from $L_1$ concatenated with all strings $x$ from $L_2$.

![image-20230223015212932](image-20230223015212932.png)

* Concatenation is ==not commutative==.

![image-20230223015645020](image-20230223015645020.png)

### Concatenating Regular Languages

![image-20230223015846149](image-20230223015846149.png)

![image-20230223015904315](image-20230223015904315.png)

| ![image-20230223015936747](image-20230223015936747.png) | ![image-20230223015948853](image-20230223015948853.png) |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

* There are many possible strings that reach the accepted state of $L_1$. From each of those, we connect to the start state of $L_2$.

### Language Exponentiation

![image-20230223020123045](image-20230223020123045.png)

![image-20230223020251844](image-20230223020251844.png)

* $L^0 = \{\varepsilon\}$ because if we put zero stamps on a piece of paper, we have exactly one string that I've made which is the blank piece of paper itself. A language concatenated with itself zero times is a language containing the empty string.

### Kleene Star

![image-20230223020647146](image-20230223020647146.png)

* The union of all the $L^0, L^1, L^2, \dots$

![image-20230223020805949](image-20230223020805949.png)

* Each line above corresponds to the strings in $L^0, L^1, L^2, L^3$
* This is where $\Sigma^*$ comes from.

### Reasoning about Infinity

![image-20230223021018057](image-20230223021018057.png)

* Regular languages are closed under Kleene Star, but the ==reasoning above is bad==.

![image-20230223021126444](image-20230223021126444.png)

* Just cause it works in the individual discrete steps, does not mean it works in the infinite case.
* Think of the following steps. Each discrete step always has length $2x$.

| ![image-20230223021318355](image-20230223021318355.png) | ![image-20230223021327948](image-20230223021327948.png) | ![image-20230223021337511](image-20230223021337511.png) |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |

* However notice that when we reach the infinite case, by Pythagorean's Theorem, the length of the diagonal is not $2x$.

<img src="cs103.assets/image-20230223021421951.png" alt="image-20230223021421951" style="zoom:50%;" />

![image-20230223021452149](image-20230223021452149.png)

![image-20230223021537944](image-20230223021537944.png)

* Process a string in the language, then jump back to the beginning and process another string in the language. 
* The start state is pulled out front to avoid possible self loops.

### Closure Properties

![image-20230223021912699](image-20230223021912699.png)

---

## Lecture 17: Regular Expressions

![image-20230226143510890](image-20230226143510890.png)

* To prove that a language is regular, draw a DFA or NFA for it.

### Closure Properties

![image-20230226143654941](image-20230226143654941.png)

### Constructing Regular Languages

![image-20230226143737127](image-20230226143737127.png)

![image-20230226143759683](image-20230226143759683.png)

* The simple languages are languages that consist of strings of length 0 or 1.

### Regular Expressions

![image-20230226143912318](image-20230226143912318.png)

### Atomic Regular Expressions

![image-20230226143957180](image-20230226143957180.png)

### Compound Regular Expression

![image-20230226144110141](image-20230226144110141.png)

### Operator Precedence for Regex

![image-20230226144122312](image-20230226144122312.png)

### Formal Definition

![image-20230226144231949](image-20230226144231949.png)

### Regex Shorthand

![image-20230226144253186](image-20230226144253186.png)

* $R^*$ means zero or more copies of $R$.

### Examples

#### Simple Example

![image-20230226144159904](image-20230226144159904.png)

#### Substring Example

![image-20230226144357996](image-20230226144357996.png)

  <img src="cs103.assets/image-20230226144527170.png" alt="image-20230226144527170" style="zoom:33%;" />

#### Length Example

![image-20230226144448882](image-20230226144448882.png)

  <img src="cs103.assets/image-20230226144505965.png" alt="image-20230226144505965" style="zoom:33%;" />

#### Contains Example

![image-20230226144621715](image-20230226144621715.png)

<img src="cs103.assets/image-20230226144633555.png" alt="image-20230226144633555" style="zoom:30%;" />

#### Emails Example

![image-20230226144716730](image-20230226144716730.png)

![image-20230226144921525](image-20230226144921525.png)

![image-20230226144927221](image-20230226144927221.png)

* The DFA for this language is as follows:

![image-20230226145000139](image-20230226145000139.png)

### Regular Expressions and Languages

![image-20230226182728663](image-20230226182728663.png)

* You can make a regular expression for every regular language.

#### Thompson's Algorithm

![image-20230226182656748](image-20230226182656748.png)

#### Forwards Direction

* Below is the theorem for the forwards direction of this statement.

![image-20230226182209073](image-20230226182209073.png)

#### Backwards Direction

![image-20230226183002709](image-20230226183002709.png)

### Generalizing NFAs

* Below is an arbitrary NFA

![image-20230226183351215](image-20230226183351215.png)

* Each of the labels are arbitrary atomic regular expressions.

![image-20230226185302902](image-20230226185302902.png)

* What if we label transitions of NFAs with a regular expression? An example is below.

![image-20230226183458967](image-20230226183458967.png)

* To go from one state to another, we pay however many characters we need to match the label to move to the next state.

![image-20230226190050153](image-20230226190050153.png)

* If we have a simple generalized NFA with a start state, and accept state, and single transition, what is the regular expression for it?

![image-20230226185340010](image-20230226185340010.png)

* The regex is just that label of the transition.

### The State-Elimination Algorithm

* We want to convert an arbitrary generalized NFA into one of the form above. Then, we would have our expression.

![image-20230226190203184](image-20230226190203184.png)

* Here, $R_{11}$, $R_{12}$, $R_{21}$, and $R_{22}$ are arbitrary regular expressions.
* Notice that there are two states, but there's self-loop transitions and a backwards transition.
* For our first step, we temporarily make it worse by adding more states connected by epsilon transitions.

![image-20230226190341838](image-20230226190341838.png)

* We now try to eliminate states, replacing them with more complicated transition labels.

![image-20230226190410025](image-20230226190410025.png)

![image-20230226190633580](image-20230226190633580.png)

* The label above is the one to go from $q_s$ to $q_2$. We don't have to go through $q_1$ anymore.

![image-20230226190641617](image-20230226190641617.png)

* Similarly, starting from $q_2$, if we took the $R_{21}$ back to $q_1$, we could still get back to $q_2$.

![image-20230226190730231](image-20230226190730231.png)

* We combine the self loops with union.

![image-20230226190800295](image-20230226190800295.png)

* We now want to eliminate $q_2$.

![image-20230226190817506](image-20230226190817506.png)

![image-20230226190837635](image-20230226190837635.png)

* Thus we have our result. Notice that self loops are often paired with the Kleene closure.

#### Algorithm Summary

![image-20230226191010508](image-20230226191010508.png)

![image-20230226191125911](image-20230226191125911.png)

### Summary so far

* Each transition above is a way to go from one type to the other.

![image-20230226191141958](image-20230226191141958.png)

![image-20230227125259427](image-20230227125259427.png)

---

## Lecture 18: Nonregular Languages

* Computers are finite machines. They do not have infinite memory.

![image-20230227125429810](image-20230227125429810.png)

![image-20230227125457725](image-20230227125457725.png)

### Finding Nonregular Languages

![image-20230227125607165](image-20230227125607165.png)

### Example Nonregular Language

* Consider the language below. This is a nonregular language because it is infinite.

![image-20230227125657272](image-20230227125657272.png)

* We can't create a regular expression or an NFA/DFA for this language.
* Suppose we try to make a DFA for this language. We would get this.

![image-20230227130101919](image-20230227130101919.png)

* Notice that the states for `aaaa` and `aa` must be different states. This is because the string `aabbbb` needs to be rejected, while the string `aaaabbbb` needs to be accepted. If they were at the same state, we can't differentiate this.

![image-20230227130205209](image-20230227130205209.png)

* This result can generalize into more branches, such as `aaa` and `a`, etc.

![image-20230227130506247](image-20230227130506247.png)

### Distinguishability

![image-20230227131018219](image-20230227131018219.png)

* `x` and `y` are two different prefixes, and `w` is one suffix. Only one of `xw` and `yw` is in the language, and the other is not.
  * e.g. let `x = a^2` and `y = a^4`, and let `w = b^4`. We see that `xw` is not in the language and `yw` is in the language.
* In practice, this means these two strings have to end up in different states of the DFA.

![image-20230227131254517](image-20230227131254517.png)

![image-20230227131344041](image-20230227131344041.png)

* Notice that there are three different branches, where the accept and reject states for the `b`'s are different.
* If we expand this, we see that there is an infinite number of branches for the `a`'s. Therefore, no DFA is possible for this.

### Proof 1

* Notice that this proof is not the simplest proof for this. A better one is later on.

![image-20230227131506106](image-20230227131506106.png) ![image-20230227131631823](image-20230227131631823.png)

![image-20230227131805955](image-20230227131805955.png)

![image-20230227131921517](image-20230227131921517.png)

### Generalized

![image-20230227132059528](image-20230227132059528.png)

* For any number of states $k$, we need a way to find $k+1$ strings so two of them get in the same state.
* We need to show that all of those strings are distinguishable, so we get a contradiction.

### Distinguishing Set

![image-20230227133357554](image-20230227133357554.png)

* The set $S$ is not a subset of $L$. Think of $S$ as a collection of all your prefixes.
* Notice that $S$ is still an infinite set.
* The distinguishing set is not necessarily regular.

### Myhill-Nerode

![image-20230227133541515](image-20230227133541515.png)

![image-20230227133657334](image-20230227133657334.png)

### Using the Myhill-Nerode Theorem

![image-20230227133811308](image-20230227133811308.png)

#### Example 2

![image-20230227134204613](image-20230227134204613.png)

![image-20230227134211993](image-20230227134211993.png)

![image-20230227134248914](image-20230227134248914.png)

#### Example 2

![image-20230227134448780](image-20230227134448780.png)

![image-20230227134527572](image-20230227134527572.png)

### Approaching Myhill-Nerode

![image-20230227134336191](image-20230227134336191.png)

---

## Lecture 19: Context-Free Grammars

![image-20230304163825626](image-20230304163825626.png)

![image-20230304163838103](image-20230304163838103.png)

* The CFG is the box on the left.
  * All CFGs have a start symbol. In this case, the start symbol is E.
  * Then, we can use the CFG to recursively replace the symbol with more symbols based on the CFG.
  * We can replace in any order.

![image-20230304164018304](image-20230304164018304.png)

* The nonterminal symbols is like scaffolding. We need to replace all these nonterminal symbols with terminal symbols in the finished string.

### CFG Notation

![image-20230304164118131](image-20230304164118131.png)

* You can shorthand notation as follows

| ![image-20230304164159342](image-20230304164159342.png) | ![image-20230304164203638](image-20230304164203638.png) |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

### Derivations

![image-20230304164258664](image-20230304164258664.png)

* Notice that the double arrow (as seen in the left) means exactly one step.
* We can use the double arrow with a start to show that it is possible to get from the left side to the right side.

### The Language of a Grammar

![image-20230304164357073](image-20230304164357073.png)

* All the strings that can be made from the start symbol.

![image-20230304164511096](image-20230304164511096.png)

* In the example above, the string `dca` is in the language. The string `dc` is also in the language.

### Context-Free Languages

![image-20230304164706680](image-20230304164706680.png)

### From Regex to CFGs

![image-20230304164803695](image-20230304164803695.png)

* However, we can convert regular expressions to CFGs as follows:

| ![image-20230304164903831](image-20230304164903831.png) | ![image-20230304164847058](image-20230304164847058.png) |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![image-20230304164850370](image-20230304164850370.png) | ![image-20230304164920011](image-20230304164920011.png) |

* Notice that $A \to A\mathtt{a} | \varepsilon$ is how you would represent a Kleene-star as a CFG.

| ![image-20230304165028320](image-20230304165028320.png) | ![image-20230304165031710](image-20230304165031710.png) |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![image-20230304165035365](image-20230304165035365.png) | ![image-20230304165040824](image-20230304165040824.png) |
| ![image-20230304165044996](image-20230304165044996.png) | ![image-20230304165049101](image-20230304165049101.png) |
| ![image-20230304165054539](image-20230304165054539.png) |                                                              |

* Notice that we can replace the operations in the regex with CFG rules.

![image-20230304165332036](image-20230304165332036.png)

![image-20230304165340047](image-20230304165340047.png)

![image-20230304165357594](image-20230304165357594.png)

* We know that there does not exist a regex for $\mathtt{a}^n\mathtt{b}^n$. Therefore, since we showed that regexes could be turned into CFLs, but not all CFLs can be turned into regex, the regexes are a subset of CFLs.

![image-20230304165424864](image-20230304165424864.png)

* Thus, regexes are a strict subset of CFLs

![image-20230304165433289](image-20230304165433289.png)

![image-20230304165647893](image-20230304165647893.png)

* CFGs have unlimited memory, as compared to regexs or finite automata which have finite memory.
* For regular languages, the regexes were the way of describing the languages and NFAs and DFAs were its computational devices.
* For CFLs, the grammars are the way of describing the language and the computation device is a push-down automata.
  * It's basically a DFA with an unbounded stack next to it. Not relevant to this class.

### Designing CFGs

![image-20230304171023917](image-20230304171023917.png)

* Think of the nonterminals like how states were in DFA and NFA; they correspond to a piece of information or a state to store.

#### Palindromes

![image-20230304171203761](image-20230304171203761.png)

* Have the nonterminal be a palindrome itself, and build palindromes recursively.
* The recursive case is the $\mathtt{a}w\mathtt{a}$ and $\mathtt{b}w\mathtt{b}$.

#### Parenthesis

![image-20230304171337263](image-20230304171337263.png)

![image-20230304171351065](image-20230304171351065.png)

* Cut our string at the closing parenthesis that matches the first open one, and remove that pair of parenthesis.

![image-20230304171418925](image-20230304171418925.png)

![image-20230304171429821](image-20230304171429821.png)

* $S$ is represents balanced parenthesis. The expression basically says you can have a balanced thing inside parenthesis and optionally more sets of balanced parenthesis.

#### Same number

![image-20230304171646341](image-20230304171646341.png)

* None of these CFGs have language L.
* For the top left, the string `abba` is in $L$ but is not accepted by the CFG.
* For the top right, the string `bbaa` is in $L$ but is not accepted by the CFG.
* For the bottom left, the string `ab` is in $L$ but is not accepted by the CFG.
* For the bottom right, the string `aaabbb` is in $L$ but is not accepted by the CFG.

### CFG Caveats

#### Check all false positive and negatives

![image-20230304172424511](image-20230304172424511.png)

#### Make sure it has a base case

![image-20230304172506836](image-20230304172506836.png)

* The $S$ above will never end, because it's not possible to create a string with just terminals. The nonterminal will continuously duplicate.

#### Nonterminals are independent

![image-20230304172622857](image-20230304172622857.png)

* The nonterminals don't coordinate in any way. The CFG above is not a valid CFG for $L$.

### Finding a build order

![image-20230304172736685](image-20230304172736685.png)

### Applications of CFGS

#### Function Prototypes

![image-20230304172807633](image-20230304172807633.png)

![image-20230304172818776](image-20230304172818776.png)

#### Programming Languages

* Most modern programming languages are defined in terms of CFGs

![image-20230304172917505](image-20230304172917505.png)

![image-20230304172950087](image-20230304172950087.png)

![image-20230304173008686](image-20230304173008686.png)

### CFG Design Tips

![image-20230304173039837](image-20230304173039837.png)

---

## Lecture 20: Turing Machines 1

![image-20230305223630044](image-20230305223630044.png)

### The Problem

![image-20230305223647707](image-20230305223647707.png)

### Key Idea

* Even if you need **huge amounts** of scratch space to perform a calculation, at each point in the calculation you only need access to a ==small amount== of that scratch space.
* Basically you only need enough memory to perform a small calculation in the scale of the whole calculation.

| ![image-20230305224401822](image-20230305224401822.png) | ![image-20230305224407786](image-20230305224407786.png) |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![image-20230305224421848](image-20230305224421848.png) | Only need to keep track of one column at a time.             |

### Turing Machines

![image-20230305224454807](image-20230305224454807.png)

* This is essentially an infinite memory, where each cell is a memory address. You consider the memory one byte at a time.
* The Turing machine can read one character at a time.

![image-20230305230620726](image-20230305230620726.png)

* Each transition label corresponds to an action. It has what we're gonna write for the current tape head position, and where we move.

### Definition

![image-20230305231018072](image-20230305231018072.png)

* Loops and function calls are implemented by Goto with labels
* Blank can never be a label in the alphabet $\Sigma$
* The input string can't have Blank in the middle
  * The machine knows it has reached the end of its input if it reaches a Blank

#### Start

![image-20230305231137973](image-20230305231137973.png)

#### Statements

![image-20230305231148226](image-20230305231148226.png)

* The `If` only checks either Blank or the symbol of some character in the alphabet $\Sigma$.

![image-20230305231731970](image-20230305231731970.png)

![image-20230305231746066](image-20230305231746066.png)

![image-20230305231806487](image-20230305231806487.png)

![image-20230305231822093](image-20230305231822093.png)

* Note that `Move` moves our cursor (the black arrow). The `Goto` moves where we are in the code (the yellow highlight)

![image-20230305232058245](image-20230305232058245.png)

* The regular expression for this Turing machine is $(ab)*$

![image-20230305232347001](image-20230305232347001.png)

* The string we accepted is the input string, not the string that is there when we return.
* We can write letters that aren't in $\Sigma$.

#### Summary

![image-20230305233051703](image-20230305233051703.png)

![image-20230305234546132](image-20230305234546132.png)

### Nonregular Language

* As we saw in previous example, Turing Machines can represent regular languages.
* They can also represent non-regular languages.

![image-20230305233307180](image-20230305233307180.png)

![image-20230305233358061](image-20230305233358061.png)

* The Turing Machine always starts at the leftmost character of the input. In the case of an empty string, it just points at a blank box, which it also accepts.

![image-20230305233515720](image-20230305233515720.png)

* We basically just strip away the starting `a` and ending `b` and keeping checking inwards.

![image-20230305233614871](image-20230305233614871.png)

* We erase the starting `a`, then zip to the right and erase the ending `b`, then zip back to the start and run it again.
* Notice that for the zips, it moves one past the end, then moves back. This is because it doesn't know what is in front of it, only where the tape head is currently.

### Another Nonregular Language

![image-20230305234330983](image-20230305234330983.png)

 ![image-20230305234807505](image-20230305234807505.png)

* The `FoundA` is for when you start with an `a`. You find an `a` and replace a corresponding `b`. Then start again from the beginning.
* The `FoundB` is if you start with a `b`. It replaces the corresponding `a` and starts again from the beginning.

#### Another Idea

![image-20230305235013008](image-20230305235013008.png)

![image-20230305235048985](image-20230305235048985.png)

![image-20230305235056830](image-20230305235056830.png)

![image-20230305235111042](image-20230305235111042.png)

* When you find a `ba` chunk, just replace their order.

### Key Idea: Abstraction

![image-20230305235213686](image-20230305235213686.png)

---

## Lecture 21: Turing Machines 2

### Real and "Ideal Computers"

![image-20230307151546596](image-20230307151546596.png)

### Theorem

![image-20230307151610148](image-20230307151610148.png)

* **Key Idea**: Two models of computation are equally powerful if they can simulate each other.

### Simulating a TM

![image-20230307151713268](image-20230307151713268.png)

* The "core" logic is referring to the testing framework of the pset. We were able to write code to run a Turing Machine.

![image-20230307151729574](image-20230307151729574.png)

### Simulating a Computer

![image-20230307151856679](image-20230307151856679.png)

#### Loops

![image-20230307151938025](image-20230307151938025.png)

#### Arithmetic

![image-20230307151951127](image-20230307151951127.png)

#### Variables

![image-20230307152010698](image-20230307152010698.png)

#### Helper Functions

![image-20230307152028102](image-20230307152028102.png)

![image-20230307152059377](image-20230307152059377.png)

#### Claim

![image-20230307152125900](image-20230307152125900.png)

### Other Types of Data

![image-20230307152224548](image-20230307152224548.png)

![image-20230307152230229](image-20230307152230229.png)

![image-20230307152236901](image-20230307152236901.png)

### Effective Computation

![image-20230307152315477](image-20230307152315477.png)

### Church-Turing Thesis

![image-20230307152342495](image-20230307152342495.png)

* Note that this is not a theorem. It's a hypothesis. However, it has been thoroughly tested so it's still considered true.

![image-20230307154421695](image-20230307154421695.png)

### Turing Machine Behavior

* Below is a simple Turing Machine.

![image-20230307154742025](image-20230307154742025.png)

* The Turing Machine above accepts strings that start with a letter `a`.
* If you drop below the last line of the Turing Machine, we consider that as returning false. This happens in the case of `bb`.
* Note that in the case of `baaa`, it will loop forever. The blank is still considered as not `b`, so it will keep running `Goto Loop`

![image-20230307155539522](image-20230307155539522.png)

### Terminology

![image-20230307155608860](image-20230307155608860.png)

* To be in the language of $M$, it must be accepted by $M$.
  * No answer or looping is the same as rejection.

### Recognizability

![image-20230307155844995](image-20230307155844995.png)

* It's a recognizer for a language if it accepts all the strings in that language.
* Looping isn't conclusive. We don't know if it just never gives an answer or if it just takes a really long time to get the answer.

![image-20230307160107494](image-20230307160107494.png)

* The top left is a recognizer for the empty language $\emptyset$. It always returns false.
* The top right is also a recognizer for the empty language. However, this is because it always runs an infinite loop on every string.
* The bottom left is a recognizer for the language $L = \{w \in \Sigma^* \text{ | } |w| \geq 1 \text{ and } |w| \text{ is a power of 2}\}$. It recognizes all strings with a length greater than or equal to 1 and is a power of two. It will infinite loop on all other strings.
* The bottom right recognizes strings that are even length and are in chunks of two identical letters (e.g. `aabb` and `aabbccdd`).

### Deciders and Decidability

![image-20230307160756657](image-20230307160756657.png)

![image-20230307160840604](image-20230307160840604.png)

![image-20230307160920515](image-20230307160920515.png)

* The top left and bottom right are deciders. The other two infinite loop on certain inputs.
* Note that the Turing Machines are not written as actual Turing Machines. They're just written in C++. This is something we're allowed to do in our proofs because we know Turing Machines are equivalent to computers.
* When writing as C++ code, made sure it is a `bool` function and it takes in a string as input.

### Hailstone Sequence

![image-20230307161349731](image-20230307161349731.png)

* If we let $n = 11$, we get the following hailstone sequence.

![image-20230307161435172](image-20230307161435172.png)

* It's not known if it terminates. However, we can write a Turing Machine for this.

![image-20230307161532859](image-20230307161532859.png)

* Think of it like a unary input, where the length of the input is our starting number.

![image-20230307161619630](image-20230307161619630.png)

* If the string is `a`, we've reached $n = 1$.

#### The Collatz Conjecture

![image-20230307161714091](image-20230307161714091.png)

#### Decider

![image-20230307161852327](image-20230307161852327.png)

* We don't know if it's a decider or not.

### RE Language Class

* RE stands for recursively enumerable.

![image-20230308004816936](image-20230308004816936.png)

* Since all Turing Machines are recognizers, you could say this as there exists a Turing Machine for that language.

### R Language Class

* R stands for recursive.

![image-20230308005011124](image-20230308005011124.png)

* There exists a decider Turing Machine for the language.

### Recognizable/Decidable

![image-20230313131953072](image-20230313131953072.png)

![image-20230308005138146](image-20230308005138146.png)

![image-20230308005341093](image-20230308005341093.png)

---

## Lecture 22: Turing Machines 3

* What problems can we solve with a computer?

### Decision Problems

![image-20230313132227745](image-20230313132227745.png)

![image-20230313132635995](image-20230313132635995.png)

### Strings and Objects

![image-20230313132643439](image-20230313132643439.png)

![image-20230313132747367](image-20230313132747367.png)

* It's somewhat hard to model the types of input of the functions above, because Turing Machines are modeled as just taking in a string.
* **Everything on your computer is a string over {0, 1}**

![image-20230313132858109](image-20230313132858109.png)

### Object Encodings

![image-20230313132930139](image-20230313132930139.png)

![image-20230313133007254](image-20230313133007254.png)

![image-20230313133030638](image-20230313133030638.png)

* We can represent a DFA because it is a finite automaton. It doesn't have infinite states.
  * CFGS, Turing Machines, NFAs, DFAs, Regex can all be represented as strings. Their language is not necessarily finite, however.
* We can represent the regular expression as a string. We can just save the regular expression as a text file, because it has finite length.
  * The language of the regular expression might be infinite, but the expression itself is finite.
* The set of $\{\mathtt{a}, \mathtt{b}\}^*$ is a set of infinite cardinality. It contains some subsets that also have infinite cardinality.
* The function $f$ can be represented as a string, because there is a limit that states $k < n$. Thus, it is not necessarily infinite. 
* A graph can always be represented as a string, because it has a finite number of nodes.

### Encoding Groups of Objects

![image-20230313133754720](image-20230313133754720.png)

![image-20230313133810519](image-20230313133810519.png)

### Summary

![image-20230313133903429](image-20230313133903429.png)

### Properties of Problems

![image-20230313133955121](image-20230313133955121.png)

### Universal Turing Machine

#### Computer vs TM

![image-20230313134027071](image-20230313134027071.png)

* Can we make a reprogrammable Turing machine?

#### TM Simulator

![image-20230313134140089](image-20230313134140089.png)

![image-20230313134205131](image-20230313134205131.png)

#### Theorem for U_TM

![image-20230313134248812](image-20230313134248812.png)

#### Recognizer

![image-20230313134448481](image-20230313134448481.png)

* $\mathtt{U_{TM}}$ is not a decider.
* $\langle M, w \rangle$ is the object encoding of the Turing machine and the string. This 'string' is in the language recognized by the universal Turing machine.
* The language contains all pairs of Turing machines and the strings that the Turing machine accepts.
  * It is essentially the language of all zips files of two things, where one is the Turing machine and the other is a string that is accepted by the Turing machine.

>$M_2 = $ TM that accepts inputs with odd length
>
>$M_1 = $ TM that does $\mathtt{a}^n \mathtt{b}^n$.
>
>Then, we have
>
>$\langle M_1, \mathtt{aabb} \rangle \in L(\mathtt{U_tm})$
>
>$\langle M_1, \mathtt{abb} \rangle \notin L(\mathtt{U_tm})$
>
>$\langle M_2, \mathtt{aabb} \rangle \notin L(\mathtt{U_tm})$
>
>$\langle M_2, \mathtt{aab} \rangle \in L(\mathtt{U_tm})$

![image-20230313164904701](image-20230313164904701.png)

* Thus, $\mathtt{U_{tm}}$ is the orange ellipse above.

#### Summary

![image-20230313134720416](image-20230313134720416.png)

![image-20230313135609417](image-20230313135609417.png)

* The interpreter and virtual machine employing the concept of the universal Turing Machine. It's a piece of software that wraps other pieces of software.

### Self-Reference

![image-20230313135732603](image-20230313135732603.png)

#### AmIEven

![image-20230313135858146](image-20230313135858146.png)

* The above is a helper function to read the file as a string, to be used in the Turing machine.

![image-20230313140029292](image-20230313140029292.png)

* This is the main function of `AmIEven.cpp`. It reads in its own source code and checks if the length of itself is even.
* For the above function, it will accept, because the length of 346.

![image-20230313140144929](image-20230313140144929.png)

* If we add 3 `s`'s, we see that it rejects, because the length is now 349.

#### EqualsMe

![image-20230313140800661](image-20230313140800661.png)

* This is the same as before. It checks if two files are equal.

| ![image-20230313140851691](image-20230313140851691.png) | ![image-20230313140858740](image-20230313140858740.png) |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

---

## Lecture 23: Unsolvable Problems 1

### Recap

#### R and RE Languages

![image-20230313165510126](image-20230313165510126.png)

![image-20230313165516694](image-20230313165516694.png)

![image-20230313165117842](image-20230313165117842.png)

* We know that $\mathtt{A_{tm}}$ is contained in $RE$, because there exists a Turing Machine that recognizes that language.

#### The Universal TM

![image-20230313165554808](image-20230313165554808.png)

#### Self-Referential Programs

![image-20230313165619363](image-20230313165619363.png)

### More on Self-Reference

#### Self-Reference in Propositions

![image-20230313165903912](image-20230313165903912.png)

* Self-references can lead to paradoxical statements. 
  * If we assume that sentence above is false, then we're saying the sentence is true. But the sentence states that its false. Contradiction.
  * If we assume the sentence is true, the sentence states that its false. Contradiction.

![image-20230313170220293](image-20230313170220293.png)

* This is another paradoxical statement, which self-references the gardener. The iff leads to a contradiction either way.

#### Self-Reference in Set Theory

![image-20230313170457720](image-20230313170457720.png)

* This is another paradox, in the realm of set theory.
* `SAFE_LIST` contains all sets that don't contain themselves.
  * If `SAFE_LIST` does not contain itself, then it is included in `SAFE_LIST`. However, we then have that `SAFE_LIST` contains itself, which is a contradiction.
  * If `SAFE_LIST` does contain itself, this means that `SAFE_LIST` doesn't contain itself. This is a contradiction.

### Self-Defeating Objects

* An object whose essential properties ensure it doesn't exist.

![image-20230313170924974](image-20230313170924974.png)

![image-20230314153935714](image-20230314153935714.png)

* Note that the above proof is incorrect. We can't assume for the sake of contradiction and show that there is no contradiction.

* The $n+1$ is chosen in advance, to show that $n$ can't exist.

![image-20230313170956590](image-20230313170956590.png)

#### Proof by Contradiction

![image-20230313171043561](image-20230313171043561.png)

### A_tm is undecidable

![image-20230314154039746](image-20230314154039746.png)

![image-20230313171446490](image-20230313171446490.png)

![image-20230313171504535](image-20230313171504535.png)

* Suppose for the sake of contradiction that a decider exists

![image-20230313171655696](image-20230313171655696.png)

![image-20230313171716700](image-20230313171716700.png)

* This is a Turing Machine paradox. It does the opposite of what `willAccept` says.
* We've shown that `willAccept` is self-defeating.

![image-20230313171738626](image-20230313171738626.png)

![image-20230313172026995](image-20230313172026995.png)

* If a decider existed, it would solve a lot of very hard problems.

#### Proof

![image-20230313172239020](image-20230313172239020.png)

![image-20230313172313174](image-20230313172313174.png)

### Summary

* Thus, we have shown that the following diagram is correct.

![image-20230313172406588](image-20230313172406588.png)

![image-20230313172424098](image-20230313172424098.png)

![image-20230313172508989](image-20230313172508989.png)

![image-20230314154253858](image-20230314154253858.png)

### Undecidability Results

![image-20230313172646630](image-20230313172646630.png)

![image-20230314154422834](image-20230314154422834.png)

![image-20230313172755080](image-20230313172755080.png)

![image-20230313172825058](image-20230313172825058.png)

* This is a Turing Machine Paradox.

![image-20230314154458371](image-20230314154458371.png)

![image-20230313172946707](image-20230313172946707.png)

![image-20230313172953711](image-20230313172953711.png)

---

## Lecture 24: Unsolvable Problems 2

* We can use the idea from the halting problem to show that some problems are impossible to solve.

### Secure Voting Example

![image-20230314154714129](image-20230314154714129.png)

![image-20230314154727558](image-20230314154727558.png)

![image-20230314154742130](image-20230314154742130.png)

![image-20230314154918936](image-20230314154918936.png)

### Beyond R and RE

![image-20230314155031738](image-20230314155031738.png)

#### RE, Formally

![image-20230314155055667](image-20230314155055667.png)

![image-20230314155136288](image-20230314155136288.png)

### Verifiers

![image-20230314155313194](image-20230314155313194.png)

![image-20230314155358634](image-20230314155358634.png)

![image-20230314155420912](image-20230314155420912.png)

* The certificate is like the way to prove that $w \in L$.

![image-20230314155217468](image-20230314155217468.png)

### Example Verifier

![image-20230314155453026](image-20230314155453026.png)

![image-20230314155503230](image-20230314155503230.png)

* The certificate is the three numbers, and it checks that that certificate is valid.

### Verifiable Languages

![image-20230314155545546](image-20230314155545546.png)

* This idea is similar to the relationship between NFAs and Regex

| ![image-20230314155620558](image-20230314155620558.png) | ![image-20230314155624778](image-20230314155624778.png) |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

#### Forwards Proof

![image-20230314155704523](image-20230314155704523.png)

![image-20230314155715019](image-20230314155715019.png)

#### Backwards Proof

![image-20230314155850597](image-20230314155850597.png)

![image-20230314155951811](image-20230314155951811.png)

### RE and Proofs

![image-20230314160029123](image-20230314160029123.png)

### Non-RE Languages

![image-20230314160131873](image-20230314160131873.png)

![image-20230314160301570](image-20230314160301570.png)

| ![image-20230314160314786](image-20230314160314786.png) | ![image-20230314160324715](image-20230314160324715.png) |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![image-20230314160336642](image-20230314160336642.png) | ![image-20230314160344459](image-20230314160344459.png) |
| ![image-20230314160352455](image-20230314160352455.png) | ![image-20230314160423687](image-20230314160423687.png) |

![image-20230314161125308](image-20230314161125308.png)

* Note that $M_3$ and $M_5$ are in this language.
* Note that this is very similar to the proof for Cantor's Theorem

#### Diagonalization

![image-20230314160458236](image-20230314160458236.png)

![image-20230314160728033](image-20230314160728033.png)

### Summary

![image-20230314161246578](image-20230314161246578.png)

![image-20230314161322219](image-20230314161322219.png)

![image-20230314161338836](image-20230314161338836.png)

### Computability Summary Reference

![image-20230314161354459](image-20230314161354459.png)

![image-20230314161414327](image-20230314161414327.png)

![image-20230314161421310](image-20230314161421310.png)

---

## Lecture 25: Complexity Theory 1

![image-20230314161435530](image-20230314161435530.png)



---

## Lecture 26: Complexity Theory 2

blah blah blah

---

## Lecture 27: The Big Picture

blah blah blah
