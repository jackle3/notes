---
Week: Week 2
---
# Vulnerabilities

- Vulnerabilities are inevitable! There will always be bugs, and they might not be found for decades.
    - Any single buffer overflow, use-after-free, or null pointer dereference might allow an attacker to run malicious code.
- Even safe languages that are built off unsafe languages have bugs!
    - Python is written in C, and has itself had multiple vulnerabilities.

> [!important]  
> Systems must be designed to be resilient given both software vulnerabilities and malicious users.  

# Principles

![[attachments/Untitled 88.png|Untitled 88.png]]

# 1. Defense in Depth

- There should be security in many layers, making it so that one small bug can’t propagate to bigger processes.

![[attachments/Untitled 1 55.png|Untitled 1 55.png]]

# 2. Principle of least privilege

- Users should only have access to the data and resources needed to perform routine, authorized tasks → don’t want users to do anything more than what they need to do.
    - E.g. teachers can only change grades for classes they teach.
    - E.g. only employees with background checks have access to classified documents.
- This protects from both outside bad attackers, as well as the user themself being malicious.

![[attachments/Untitled 2 55.png|Untitled 2 55.png]]

# 3. Privilege Separation

- To have the principle of least privilege, we need to divide the system into parts
    - Limit access to each part, based on privilege.
- This is known as _privilege separation._
    - Segmenting system into components with least privilege can prevent attacker from taking over the entire system.

## Security Subjects

![[attachments/Untitled 3 55.png|Untitled 3 55.png]]

## Security Policies

- We create policies with Subject, Object, and Operation → defines what each subject can do to each object.

![[attachments/Untitled 4 54.png|Untitled 4 54.png]]

# 3a. UNIX Security Model

- UNIX only has two primary subjects → users and processes.
    - These subjects are how we grant permission to things.
- The only object that exists are files (directories are basically files).
    - Everything you do on UNIX, you do it through a file descriptor.
- There are three operations allowed → read, write, execute

![[attachments/Untitled 5 54.png|Untitled 5 54.png]]

- For every file (object), we decide which users/processes (who) can read/write/execute (how).

# 3a.1 Users

- Every process has to belong to some user.
    - However, some processes like `ssh` don’t have a user → it will use a service account called `sshd` that lets the user run processes

![[attachments/Untitled 6 53.png|Untitled 6 53.png]]

- You can view the list of users via `/etc/passwd`
    
    - The red chunk is the super user (root)
    - The blue chunk is the service accounts (generally accounts between 1 and 1000)
    - The green chunk is the user accounts (starts at 1000)
    
    ![[attachments/Untitled 7 53.png|Untitled 7 53.png]]
    

## Groups

- For every file, it knows what user can access it and also what group can access it.

![[attachments/Untitled 8 53.png|Untitled 8 53.png]]

## File ownership

- Every file has one user owner and one group owner.

![[attachments/Untitled 9 52.png|Untitled 9 52.png]]

## Access control

- There are also permissions when you run `ls -l`
    - If there is the `x` bit in a directory, they can enter the directory.
    - The `r` and `w` bit tells us that they can read and write in the directory.

![[attachments/Untitled 10 51.png|Untitled 10 51.png]]

- If Drew is a member of `cs155-tas`, what can they do to `homework`?
    - They can read the directory, write to the directory, and enter the directory
- If a student has access to the server, what can they do?
    - The student falls under the `other` category.
    - They can read `lectures` and go into the `lectures` directory.
    - They can read `test.py`, but they can’t execute it.

## Access Control Lists (ACLs)

![[attachments/Untitled 11 51.png|Untitled 11 51.png]]

## Role Based Access Control (RBAC)

- The ACL can get very large. As such, we can do control based on the role/group.

![[attachments/Untitled 12 51.png|Untitled 12 51.png]]

# 3a.2 Processes

- Processes are isolated
    - Processes cannot access each other’s memory
- Processes run as a specific user
    - When you run a process, it runs with your UID’s permissions
    - Process can access any files that the UID has access to
        - Processes run by the same UID have the same permissions
- Processes started by root can reduce their privileges by changing their UID to a less privileged UID

![[attachments/Untitled 13 49.png|Untitled 13 49.png]]

- When you run `ls`, it is ran as a child process of `bash`.
    - We know that `bash` is running as you, so it has your UID.
    - As such, `ls` also inherits your UID.

## User IDs

- The most important user ID is the effective user ID → used to figure out permissions
    
    ![[attachments/Untitled 14 47.png|Untitled 14 47.png]]
    
- However, you can manipulate these to change user IDs.
    
    - Note that once `setuid` is called, we can never go back. If `root` changes to another ID, it can’t go back to root.
    
    ![[attachments/Untitled 15 45.png|Untitled 15 45.png]]
    

## Reducing privilege

- Processes that require privilege to start, but not to run, can reduce their privilege.

![[attachments/Untitled 16 43.png|Untitled 16 43.png]]

## Temporarily changing UID

- `setuid` is safe because once you change it, you can’t go back to the previous.
- However, `seteuid` is not → allows unprivileged users to go back to the previous UID.
    - If `root` calls `seteuid`, an unprivileged user can return it back to `root` to get access.

![[attachments/Untitled 17 40.png|Untitled 17 40.png]]

- This can be exploited by an unprivileged user. The saved UID is still root.
    
    ![[attachments/Untitled 18 38.png|Untitled 18 38.png]]
    
    ![[attachments/Untitled 19 35.png|Untitled 19 35.png]]
    

## Process Tree

- You can see the process tree for a system with `pstree -u`
- The first process that’s ran is `systemd`.
    - This then spawns a bunch of child processes.
    - One of the processes is `sshd`.
        - This process forks for each user connected to the machine.
        - It then forks again to get a `ssh` process that belongs to the child.
    - Another process is `lighttpd`, which is a web server.
        - It starts as root in `systemd` to get port 80. Then, it instantly drops down to lower privilege.

![[attachments/Untitled 20 34.png|Untitled 20 34.png]]

## Elevating privileges (`setuid` bit)

![[attachments/Untitled 21 31.png|Untitled 21 31.png]]

- Some processes may require you to access a file only accessible by `root`.
    - E.g. The `passwd` utility allows you to change your password by updating the password in `/etc/shadow` — a file that only root can read/write
    - The `passwd` utility would not work normally → it’s ran with the privilege of the user, so it wouldn’t be able to access `/etc/shadow`
- UNIX allows you to set EUID of an executable to be the file owner rather than the existing user. This is the `s` bit in the below.
    
    ![[attachments/Untitled 22 27.png|Untitled 22 27.png]]
    
    - This effectively means that `passwd` will always run as root.
- How does `passwd` know which user it should allow the caller to change the password for?
    - It will use the `Real UID` → the EUID will be root, but the RUID will still be the user.

## Becoming Root User

![[attachments/Untitled 23 25.png|Untitled 23 25.png]]

# 3a.3 Summary of Unix

![[attachments/Untitled 24 24.png|Untitled 24 24.png]]

## Linux Capabilities

- Programs like `ping` does not need the capability to bypass permission checks. As such, we can compartmentalize it.

![[attachments/Untitled 25 21.png|Untitled 25 21.png]]

## Pros and Cons

![[attachments/Untitled 26 18.png|Untitled 26 18.png]]

# 3b. Windows Security Model

## Flexible ACLs

- Windows has very complex control options

![[attachments/Untitled 27 16.png|Untitled 27 16.png]]

## Object Security Descriptors

![[attachments/Untitled 28 15.png|Untitled 28 15.png]]

## Tokens

- To let someone else act as you, you can temporarily share your token with them.

![[attachments/Untitled 29 14.png|Untitled 29 14.png]]

## Access Request

![[attachments/Untitled 30 14.png|Untitled 30 14.png]]

## Capabilities vs. ACLs

- These are two different ways of security.
    - Windows uses a capabilities model. It does not care who you are, just that your ticket lets you access it.
        
        ![[attachments/Untitled 31 12.png|Untitled 31 12.png]]
        
    - UNIX uses an ACL model. It cares about who you are, and has a list of access.
        
        ![[attachments/Untitled 32 12.png|Untitled 32 12.png]]
        
- Windows does not really know who has access to which file → depends on the ticket of the user.

# 3c. Weak protection on Desktops

- On desktops, every application is ran as the user → if the user is corrupted, they can’t use the machine anymore.
    - The home directory of the user can be access by any application that the user runs.

![[attachments/Untitled 33 12.png|Untitled 33 12.png]]

# 3d. Mac OS App Sandbox

![[attachments/Untitled 34 10.png|Untitled 34 10.png]]

# 3e. Android Process Isolation

- On Android, every application you install runs as its own user.

![[attachments/Untitled 35 10.png|Untitled 35 10.png]]

# 3f. Chrome Security Architecture

- Before security was an issue, applications were just one giant process, with multiple threads doing different things.
- Now, each functionality is its own process, with different privileges.
    - If one process is compromised, it won’t compromise the whole tab.

![[attachments/Untitled 36 9.png|Untitled 36 9.png]]

## Chrome Processes

![[attachments/Untitled 37 9.png|Untitled 37 9.png]]

## Process-Based Site Isolation

- `iframes` are essentially rendering other websites into the current site.
    - Each frame has its own renderer process, so that if the site is compromised, it does not compromise the other processes.

![[attachments/Untitled 38 9.png|Untitled 38 9.png]]

## Chrome Architecture

- It uses a `Broker` (parent process) that has the most privileges, where we try to do the least amount of work in.
    - This process supervises the other sandboxed processes.
- Chrome essentially makes child processes owned by “Nobody”, which is a user that can only run code → no access to files or anything.
    - It gradually adds in more privileges as necessary.

![[attachments/Untitled 39 8.png|Untitled 39 8.png]]

# 3g. Chrome on Windows

## Restricted Security Context (Windows)

![[attachments/Untitled 40 8.png|Untitled 40 8.png]]

## Windows Job Object

![[attachments/Untitled 41 6.png|Untitled 41 6.png]]

## Alternate Windows Desktop

- One issue with the above was that processes still had access to the clipboard, which belonged to the windows desktop.
    - To fix, create an alternate desktop to further sandbox processes.

![[attachments/Untitled 42 6.png|Untitled 42 6.png]]

## Windows Integrity Levels

- Windows Vista introduced concept of integrity levels to ease development
    - untrusted, low, medium, high, system
- Most processes run at medium level.
    - Low-integrity level has limited scope, e.g., can read but cannot write files

# 4. Open Design

- The security of a mechanism should not depend on the secrecy of its design or implementation
- If the details of the mechanism leaks (through reverse engineering, dumpster diving or social engineering), then it is a catastrophic failure for all the users at once.
- If the secrets are abstracted from the mechanism, e.g., inside a key, then leakage of a key only affects one user.

> [!important]  
> Kerckhoff’s Principle: A crypto system should be secure even if everything about the system, except the key, is public knowledge.  

- It’s quite easy to fix bugs and change the key. It’s very difficult to overhaul the security system because it was leaked.

# 5. Keep it simple

- The more complex a system is, the more room there are for bugs.