---
Week: Week 2
---
![[attachments/Untitled 92.png|Untitled 92.png]]

# Section Outline

![[attachments/Untitled 1 59.png|Untitled 1 59.png]]

# 1. Principles of Secure Systems

![[attachments/Untitled 2 59.png|Untitled 2 59.png]]

## Defense in Depth

- There should be defenses at multiple layers → failure on one layer should not compromise other things.
    - Multiple layers has to fail in order for something to go catastrophically wrong.

![[attachments/Untitled 3 59.png|Untitled 3 59.png]]

## Principle of least privilege

- A user should only have access to the data and resources they need to perform routine and authorized tasks.
    - E.g. professors should only be able to change grades for courses they are currently teaching.
    - E.g. on a UNIX system, a user can only change their own password.

## Privilege Separation

- This is how you operationalize the idea of least privilege.
- Segment security-sensitive actions within the system into separate chunks that require authorization to use.

### Authorization vs. Authentication

- Authentication is like “who are you?”
- Authorization is like “what actions are you able to perform?”

## Open design

![[attachments/Untitled 4 58.png|Untitled 4 58.png]]

# 2. Shadow Stack Defenses

- Downgrades the vulnerability/exploit into just a denial of service.

![[attachments/Untitled 5 58.png|Untitled 5 58.png]]

## Shadow Stack on Android

- On Android, it doesn’t detect attacks → but it prevents attacks by restoring RA from shadow stack.

![[attachments/Untitled 6 57.png|Untitled 6 57.png]]

# 3. Unix Permissions Model

![[attachments/Untitled 7 57.png|Untitled 7 57.png]]

## EUID

![[attachments/Untitled 8 56.png|Untitled 8 56.png]]

## RUID

![[attachments/Untitled 9 55.png|Untitled 9 55.png]]

- To get the real `uid`, we can use the `getuid()` system call.

## SUID

![[attachments/Untitled 10 53.png|Untitled 10 53.png]]

## `setuid` and `seteuid`

![[attachments/Untitled 11 53.png|Untitled 11 53.png]]

- **Privilege** depends on the user that spawned the process → the RUID.
- `setuid` is a permanent change → once you downgrade, you can’t go back.
- `seteuid` is for a temporary change → once you downgrade, you can return.

## `setuid` binaries

- This bit lets you have a difference between EUID and RUID with execution, but you don’t actually need to be root with EUID root.

![[attachments/Untitled 12 53.png|Untitled 12 53.png]]

- This can be exploited. Below is an example program that has the `setuid` bit set on it.
    
    - Notice that the `RUID`, the user that called the code, is not root. However, the program has EUID of root.
    
    ![[attachments/Untitled 13 51.png|Untitled 13 51.png]]
    
    - Since it has EUID of zero, it can call `setuid`, which changes both EUID and RUID.
    
    ![[attachments/Untitled 14 49.png|Untitled 14 49.png]]
    
    - After we call `setuid(0)`, everything we are running from here on down is running with root privileges.
        - E.g. `foo` is running as root → if it has an exploit, we can exploit the control flow to run your own shell code, giving us a root shell.

## Example 1

- Recall that `seteuid` will set EUID to any of RUID or SUID.

![[attachments/Untitled 15 47.png|Untitled 15 47.png]]

## Example 2

![[attachments/Untitled 16 45.png|Untitled 16 45.png]]

- There is an error in the above. All three of these should be 3.

## Example 3

- The first call works because you are privileged (RUID = 3). As such, you can change the EUID to anything less privileged (EUID → 4)
- In the second call, since you are privileged (RUID = 3), you change all three values.

![[attachments/Untitled 17 42.png|Untitled 17 42.png]]

# 4. ROP

![[attachments/Untitled 18 40.png|Untitled 18 40.png]]

## Return Oriented Programming Attack

![[attachments/Untitled 19 37.png|Untitled 19 37.png]]

- Take gadgets that already exists within the compiled code to run some action.
    - Gadgets are pieces of assembly code that end in `ret`.
    - When assembly calls `ret`, it will move the next thing on the stack into the instruction pointer, allowing us to continue execution without using `call`.

![[attachments/Untitled 20 36.png|Untitled 20 36.png]]

- `dup2` is only necessary when you're attacking a remote machine.
    - If you want to be able to use the shell that results from your exploit, you need to redirect the `stdin` and `stdout` file descriptors to the file descriptor for the socket that the remote machine is using to connect to you.
- If the exploits are running locally, we don't need to worry about `dup2`.

![[attachments/Untitled 21 33.png|Untitled 21 33.png]]

## Randomization

- Prevents attackers from knowing the location of gadgets in code, because its randomized on every execution of the executable.

![[attachments/Untitled 22 29.png|Untitled 22 29.png]]