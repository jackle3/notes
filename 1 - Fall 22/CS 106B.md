# CS 106B

## Programming Abstractions

---

---

## Monday, September 26

Today, we're covering logistics and a little bit of C++.

---

### Grading

| Percentage | Type                    | Date                 |
| ---------- | ----------------------- | -------------------- |
| 55%        | Programming assignments | Weekly               |
| 15%        | Mid-quarter exam        | Nov. 1, 7-9pm        |
| 20%        | End-quarter final exam  | Dec 12, 8:30-11:30am |
| 5%         | Section participation   |                      |
| 5%         | Lecture participation   |                      |

Assignments are submitted and graded on Gradescope. They're graded based on a few criteria.
* 50% of the grade is based on correctness (does code have the correct output)
* 50% of the grade is based on style (code review)
  * Are functions well-named
  * Are indents and spacing correct
  * Are there thoughtful comments
  * Are functions broken down into well-designed helper functions

---

### Expectations

Do your own work. Don't share or look at other people's code.

---

### Content

```cpp
#include <iostream>
#include "console.h"
using namespace std;

int main() {
    cout << "Hello, world!" << endl;
    return 0;
}
```
* Every program has a main function. Main will always return 0. A non-zero return value is an error code, but we will always return 0 for this class.
* Use `#include <libraryname>` for standard C++ libraries
* Use `#include "libraryname.h"` for local project libraries

---

---

## Wednesday, September 28

Today, we're covering common C++ libraries with some example code.

---

### C++ Math Functions

To use common math functions, add `#include <cmath>` to the top of the program.

---

### Hamilton Code Example

```cpp
#include <iostream>
#include <string>
#include "console.h"
#include "SimpleTest.h"
using namespace std;

string generateLyrics(int daAmount); // this is a function prototype

int main()
{
    // call generateLyrics function here
    cout << "King George says: " << generateLyrics(12) << "!" << endl;
    return 0;
}

string generateLyrics(int daAmount) {
    string lyrics = "";
    for (int i = 1; i <= daAmount; i++) {
        if (i % 3 == 0) {
            lyrics += "Dat ";
        }
        else if (i % 8 == 0) {
            lyrics += "Ya Da ";
        }
        else {
            lyrics += "Da ";
        }
    }
    return lyrics
}
```

There are a few things that we can see from this:

* You must use function prototypes for your helper functions, since you want to keep **main** on top for good style.
  * If you make a function prototype, you must define that function.
* You can use **const int** to make int constants. This is good style, and can also be used for other types.

---

### Strings

```cpp
int main() {
    string s = "ab";
    s = s + "cd";
    cout << s << endl;
    return 0;
}
```

This piece of code will work. It will print "abcd", and the + operator concatenates strings in the way you'd expect.

```cpp
int main() {
    string s = "ab" + "cd";
    cout << s << endl;
    return 0;
}
```

This will not work, due to some backwards compability issues with C and string literals.

**String Literals** are just hard-coded string values.

* E.g. "hello" "1234" "hardcode"
* They have <u>no methods</u>. You won't be able to concatenate them with plus signs.

**String Objects** are objects with lots of helpful methods and operators. Some examples of string objects are:

* string s;
* string piece = s.substr(0, 3);
* s.append(t);
* s += t;

String object methods can be imported using `#include <string>`

| Method Name                                | Description                                                  |
| ------------------------------------------ | ------------------------------------------------------------ |
| s.append(str)                              | add text to the end of the string                            |
| s.compare(str)                             | returns *-1, 0, or 1* depending on ordering of the string    |
| s.erase(index, length)                     | deletes text from the string starting at given index         |
| s.find(str)                                | returns the first of index where the start of *str* appears in the string (returns **string:npos** if not found) |
| s.rfind(str)                               | same as find but returns the last index                      |
| s.insert(index, str)                       | inserts text into string at a given index                    |
| s.length() or s.size()                     | returns the number of characters in this string              |
| s.replace(index, len, str)                 | replaces *len* chars at given index with new text            |
| s.substr(start, length) or s.substr(start) | the next *length* chars beginning at start (inclusive); if length is omitted, grabs till the end of the string |

```cpp
string name = "Bob the Builder";
if (name.find("Bui") != string::npos) {
    name.erase()
}
```

---

---

## Friday, September 30

Today, we're covering parameters in C++.

---

### String Review

* s.substr(start, length)
  * Start denotes the 0-indexed starting position of the substring, length denotes the length of the substring
    * If length > s.length(), it uses all of the characters. I.e. length is the maximum length of the substring.

---

### Hamiltonian Code Example

We will focus on improving the style.

```cpp
// bad example
string generateLyrics(int daAmount) {
    string lyrics = "";
    for (int i = 1; i <= daAmount; i++) {
        if (i % 3 == 0) {
            lyrics += "Dat ";
        } else if (i % 8 == 0) {`
            lyrics += "Ya Da ";
        } else {
            lyrics += "Da ";
        }
    }
    return lyrics
}

// good example
static const int DAT_FREQ = 3;
static const int  YA_FREQ = 8;

string generateLyrics(int daAmount) {
    string lyrics = "";
    for (int i = 1; i <= daAmount; i++) {
        if (i % DAT_FREQ == 0) {
            lyrics += "Dat ";
        } else if (i % YA_FREQ == 0) {
            lyrics += "Ya Da ";
        } else {
            lyrics += "Da ";
        }
    }
    return lyrics
}
```

* Avoid "magic numbers": numbers that are just in the code without a descriptive name, something that others would be able to understand.
* If you have multiple static constants, try to make the equal signs line up.
  * E.g. with the `DAT_FREQ` and `YA_FREQ`.

**Style Notes**

* Descriptive function and variable names
* Proper indentation
  * In Qt Creator, if you select all and press **cmd + i**, it will fix the indentation for you.
* One space between operators and variables
  * Write `i < 3` instead of `i<3`
* Define constants at the top of your file for any special values
  * Example: `const int DAT_FREQ = 3`

---

### Testing

We must also test our code to ensure changes do not break the code. These are called regression tests, as they make sure our code does not regress over time.

* We want the tests to be thorough: covers all code paths and cases
  * Don't just add loads of tests for the sake of having many, each should have a purpose
* Be extra attentive to unusual circumstances (edge cases)
* Tests will vary, specific to the function you are testing. Common examples include:
  * For programs with integer inputs, testing negative numbers, zero, and very large numbers
  * For programs with string inputs, very short strings (length 0 or 1) and very long strings

**CS 106B Testing Framework**

* In `main()`, write `runSimpleTests(SELECTED_TESTS)`.
* You should write tests as
  * `EXPECT_EQUAL(functionBeingTested(input), expectedOutput);`
  * `EXPECT_EQUAL(generateLyrics(2), "Da Da ");`

```cpp
int main()
{
    if (runSimpleTests(SELECTED_TESTS)) {
        return 0;
    }

    cout << "All done, exiting" << endl;
    return 0;
}

/* * * * * * Test Cases * * * * * */

PROVIDED_TEST("Basic short lyric generation") {
    EXPECT_EQUAL(generateLyrics(1), "Da ");
    EXPECT_EQUAL(generateLyrics(2), "Da Da ");
}

STUDENT_TEST("test additional cases not covered by the provided tests") {
    EXPECT_EQUAL(generateLyrics(3), "Da Da Dat "); // test "Dat" syllable
    EXPECT_EQUAL(generateLyrics(8), "Da Da Dat Da Da Dat Da Ya Da "); // test "Ya Da" syllable
    EXPECT_EQUAL(generateLyrics(0), ""); // special case: no generation
    EXPECT_EQUAL(generateLyrics(-10), ""); // special case: make sure it doesn't crash
}
```

We don't need to test different types (e.g. passing `generateLyrics("hello")`) because it won't compile.

* Our tests need to cover runtime problems, not compile problems.

---

### Parameter Passing

**"Pass by value"**

* The default behavior of parameters

```cpp
#include <iostream>
void foo(int n);

int main() {
    int num = 5;
    foo(num);
    cout << num << endl;
    return 0;
}

void foo(int n) {
    n++;
}
```

This will print `5`. The `num` passed into `foo()` is just the value `5`, not the pointer to the variable `num` in main. The change in `foo` only happens to the local copy of `num` named `n`.

* The name of the local copy does not matter. If it's passing by value, it will only change the value of the local copy.

**"Pass by reference"**

```cpp
#include <iostream>
void foo(int &n);

int main() {
    int num = 5;
    foo(num);
    cout << num << endl;
    return 0;
}

void foo(int &n) {
    n++;
}
```

This will print `6`.  The `&` means that the variable will be passed by reference. It will pass the reference to the box holding the value of num, so you can change the value of num outside.

* Picture `&` as a rope lasso that grabs the input parameter and drags it into the function call directly, rather than making a copy of its value and then leaving it in place.

**Example**

```cpp
void mystery(int c, int& a,int b) {
    cout << b << " + " << c << " = " << a << endl;
    a++;
    b--;
}
int main() {
    int a = 4;
    int b = 7;
    int c = -2;
    
    mystery(b, a, c); // prints "-2 + 7 = 4"
    mystery(c, b, 3); // prints "3 + -2 = 7"
    mystery(b, c, b + a); // prints "13 + 8 = -2"
    return 0;
}
```

---

---

## Monday, October 3

Today, we'll cover abstract data types (ADTs).

---

**Note**

* Do <u>not</u> use STL classes like vector, map, etc. for any assignment in this class
  * Use the Stanford library ADTs. Assignments are made to be able to be solved by them.

---

### ADTs = "Abstract Data Types"

* Language-independent models of common containers
* They encompass both the nature of the data and ways of accessing it
* They form many different nouns (nature of the data) and verbs (ways of accessing it), often drawing on analogies to make their use intuitive.
* The use of ADTs can add readability.

---

### Types of ADTs

* When we say "nature of the data," we mean questions like:
  * Is the data **ordered** in some way?
  * Is the data **paired or matched** in some way?
* When we say "ways of accessing it," we mean questions like:
  * Should you be able to **add and remove data** as the program is running, or will we have the whole collection from the beginning?
  * Do we need to **search for any piece of data** in the collection, or is enough to always take the first available one.

---

### Vectors

* Similar to an array or list. It is denoted by `Vector`. **Remember to not use the str `vector`**.

```cpp
#include "vector.h" // quotes mean to use Stanford version
Vector<string> nums {42, 17, -6, 0, 28}; // note uppercase V
```

| index | 0    | 1    | 2    | 3    | 4    |
| ----- | ---- | ---- | ---- | ---- | ---- |
| value | 42   | 17   | -6   | 0    | 28   |

* The `<>` is called **template syntax**
  * In C++, template containers must be homogenous (all items are the same type)
  * The type goes in `<>` after the class name `Vector`
* Common methods in vectors include `.add(value)`, `.insert(index, value)`, and `.size()`. The documentation can be found [here](https://web.stanford.edu/dept/cs_edu/resources/cslib_docs/Vector.html).

---

### Vector Performance

```cpp
Vector<int> v;
for (int i = 0; i < 100; i++) {
    v.insert(0, i); // OPTION 1
}
```

This one produces `[99, 98, 97, ..., 1, 0]`.

```cpp
Vector<int> v;
for (int i = 0; i < 100; i++) {
    v.add(i); // OPTION 2
}
```

This one produces `[0, 1, 2, ..., 98, 99]`.

However, the first one is $O(n^2)$ while the second is $O(n)$. Every time OPTION 1 adds an element, it needs to shift every element in the vector to the right to make space at index 0.

<img src="/Users/jack/Library/Application Support/typora-user-images/image-20221003140009868.png" alt="image-20221003140009868" style="zoom:50%;" />

We can test the runtime of programs using the Stanford library.

```cpp
void runInsert(int size)
{
    Vector<int> v;
    for (int i = 0; i < size; i++) {
        v.insert(0, i);
    }
}
void runAdd(int size)
{
    Vector<int> v;
    for (int i = 0; i < size; i++) {
        v.add(i);
    }
}

/* * * * * * Test Cases * * * * * */
PROVIDED_TEST("Timing comparison")
{
    int size = 500000;
    TIME_OPERATION(size, runInsert(size)); // runs in about 35.287 seconds
    TIME_OPERATION(size, runAdd(size)); // runs in about 0.049 seconds
}
```

**Note**: For the sake of performance, always use "pass-by-reference" for containers like `Vector` and `Grid`. If we used "pass-by-value", we would be making a new copy every time which can be very resource expensive.

```cpp
void printFirst(Vector<int>& input) {
    cout << input[0] << endl;
}
void printFirst100Times(Vector<int>& input) {
	for (int i = 0; i < input.size(); i++) {
    	printFirst(input); // very expensive if not for &
    }
}
```

---

### Grid

* ADT abstraction similar to an array of arrays (matrix)

```cpp
#include "grid.h"

Grid<int> chessboard;
Grid<int> image;
Grid<double> realMatrix;
```

To iterate through a `Grid`, we can use for loops

```cpp
void printMe(Grid<int>& grid, int row, int col) {
    for (int r = row - 1; r <= row + 1; r++) {
        for (int c = col - 1; c <= col + 1; c++) {
            if (grid.inBounds(r, c)) {
            	cout << grid[r][c] << " ";
            }
        }
        cout << endl;
    }
}
```

This program prints the numbers in the $3 \times 3$ grid around `row` and `col`, if it is in bounds.

<img src="/Users/jack/Library/Application Support/typora-user-images/image-20221003141341304.png" alt="image-20221003141341304" style="zoom:50%;" />

If we pass this grid with `row = 2` and `col = 3`, we will print all numbers in the following grid by row, starting from the top left corner. Therefore, it will print `2 1 2 0 1 1 2 2 2`.

<img src="/Users/jack/Library/Application Support/typora-user-images/image-20221003141557364.png" alt="image-20221003141557364" style="zoom:50%;" />

---

---

## Wednesday, October 5

Today, we're covering more ADTs. Specifically, we're covering stacks, queues, and applications of stacks.

---

### Stack

To use the Stanford stack, you can add `#include "stack.h"` to the top of the file.

Stacks are FILO, or first-in-last-out. You can only add to the top of the stack, and you can only examine the topmost element.

Stack functionality can be replicated using a vector. However, the vector code is harder to read quickly and more error prone.

* Stacks are can be good for buffering input and giving them back in reverse order.

---

### Queues

To use the Stanford queue, you can add `#include "queue.h"` to the top of the file.

Queues are FIFO, or first-in-first-out. You can only add to the back of the queue, and you can only examine the frontmost element.

* Enqueue: add an element to the back
* Dequeue: remove the front element
* Peek: examine the front element

---

### Application of Stacks: Reverse Polish Notation

If we ignore operator precedence, the expression `3*3+3*3` can produce 18, 36 and 54.

Using reverse Polish notation, or "postfix", there aren't ambiguities.

Postfix: `4 3 * 4 3 * +`

Infix: `(4 * 3) + (4 * 3)`

We can evaluate postfix notation using stacks.

When we encounter a number, we push it into the stack.

When we encounter an operator, we pop two numbers and push the result.

Assuming that the expression is valid, there should not be any errors, such as there only being one number in the stack when an operator shows up.

At the end of the expression, the remaining number in the stack is our final answer.

Here is the code for the RPN parser.

```cpp
void printWelcome();
void doOneCalc(string expression);
bool calculate(string expression, int& result);
bool isSupportedOperator(char op);
int  applyOperator(int lhs, char op, int rhs);

/*
 * This program asks user for an input file, in which each line is an
 * arithmetic expression in RPN format, and performs the calculations. After
 * each calculation, the user is asked if they would like to continue.
 */
int main()
{
    if (runSimpleTests(SELECTED_TESTS)) {
        return 0;
    }

    printWelcome();
    bool calcAgain = true;
    while (calcAgain) {
        string expression = getLine("Enter an expression: ");
        doOneCalc(expression);
        calcAgain = getYesOrNo("Do you want another calculation (Y/N)? ");
    }
    return 0;
}

/*
 * Prints out an initial greeting message for the program.
 */
void printWelcome()
{
    cout << "Welcome to the CS106B RPN Calculator!" << endl;
    cout << endl;
    cout << "This program takes arithmetic expressions in RPN " << endl;
    cout << "format, and performs the calculations." << endl;
    cout << endl;
}

/*
 * Parses an arithmetic expression and prints the result.
 * @param expression is an arithmetic expression in RPN form
 * Side effect: prints out the result of the calculation, or an error
 *        if the expression could not be parsed.
 */
void doOneCalc(string expression) {
    int result;
    if (calculate(expression, result)) {
        cout << expression << " = " << result << endl;
    } else {
        cout << "Could not parse expression: " << expression << endl;
    }
}

/*
 * Demonstrates use of a Stack to calculate an RPN arithmetic expression.
 * @param expression is an arithmetic expression in RPN form
 * @param result "returns" the result of the calculation
 * @return true if expression could be parsed and result was set
 *        successfully, else false.
 */
bool calculate(string expression, int& result)
{
    Stack<int> memory;
    // Examine each character of input, left to right
    for (size_t i = 0; i < expression.length(); i++) { // size_t is a type of int that can't be negative
        // if digit, store it
        if (isdigit(expression[i])) {
            int value = charToInteger(expression[i]);
            memory.push(value);
        // if operator, perform operation
        } else if (isSupportedOperator(expression[i]) && memory.size() >= 2) {
            int rhs = memory.pop();
            int lhs = memory.pop();
            memory.push(applyOperator(lhs, expression[i], rhs));
        // otherwise parse error
        } else {
            return false;
        }
    }
    // should be single number in memory, that's our answer
    if (memory.size() != 1) {
        return false;
    }
    result = memory.pop();

    return true;
}

/*
 * Performs a check to make sure we support the arithmetic operator.
 * @param op is a character representation of the operator
 * @return true if op is one of * / + -, otherwise false
 */
bool isSupportedOperator(char op) {
    return op == '*' || op == '/' || op == '+' || op == '-';
}

/*
 * Performs a single arithmetic operator computation.
 * @pre op must be a valid operator (else throws exception)
 * @param lhs is the first or left-hand-side operand
 * @param op is a character representation of the operator
 * @param rhs is the second or right-hand-side operand
 * @return the result of the calculation
 */
int applyOperator(int lhs, char op, int rhs)
{
    switch (op) {
    case '*' :
        return lhs * rhs;
    case '/':
        return lhs / rhs;
    case '+':
        return lhs + rhs;
    case '-':
        return lhs - rhs;
    default:
        error("Invalid operator"); // we should have already checked for this
    }
}
```

---

### Aside: Commenting

All files should start with a header comment that has basic information about you and a quick overview of what is happening in the file.

```cpp
/*
 * calculator.cpp
 *
 * @author Jack Le
 * @version 2022-Aut
 *
 * Demonstrates use of Stack ADT to implement a very simple Reverse Polish
 * Notation (RPN) calculator.
 *
 */
```

---

---

## Friday, October 7

Today, we're covering associative containers and ADTs. These include Maps, Sets, and Lexicon. They're not as concerned with order but more with association.

---

### Maps

Maps associates keys to values. For example, mapping names to phone numbers. In this case, names are keys, and phone numbers are values.

Some general member functions include

* `void put(KeyType& key, ValueType& value)`
* `void containsKey(KeyType & key)`
* `ValueType get(KeyType& key)`
* `ValueType operator [](KeyType& key)`

To use a map, add `#include "map.h"`

Keys and value are homogenous in type. You can choose any type, as long as every key and every value are the same type respectively.

```cpp
Map<string, string> phone;
phone["Cynthia"] = "321-101-0000";
phone.put("Julie", "878-333-1234");

if (phone.containsKey("Cynthia") && phone.containsKey("Julie")) {
    cout << phone["Cynthia"] << endl; // prints "321-101-0000"
    cout << phone.get("Julie") << endl; // prints "878-333-1234"
    cout << phone["MTL"] << endl; // prints ""
}
```

When accessing a key that's not in the map using the Stanford library, it will first insert that key into the map with a default value.

* With a string value type, its an empty string. 
* With an int type, it would be 0. 
* With a vector value type, it would be an empty vector.

---

### Map Programming Exercise

Write a program to count the number of occurrences of each unique word in a text file. The user will then give a word and we report how many times that word appeared in the text file.

We can do this by using a `Map<string, int> wordCounts;`

If we wanted to do the reverse of this, we might use a `Map<int, Vector<String>> countWords;` to represent all the words that appear `n` times in the text file.

If the text file is given in the form of `Vector<string> words`, the following code will achieve the task that we want:

```cpp
const int FREQUENCY_THRESHOLD = 100;

/*
 * Takes vector containing full text (tokenized), and populates a map
 * of words -> word counts.
 * @param words is a Vector of tokens (words) to be counted.
 * @param wordCounts should be initially empty, and will be filled with
 *   associations of words with the count of that word's occurrences in
 *   the file.
 */
void countUniqueWords(Vector<string>& words, Map<string, int>& wordCounts)
{
    for (string word : words) {
        wordCounts[word]++;
    }
}

/*
 * Print all words that appeared in the file at least
 * FREQUENCY_THRESHOLD times, in alphabetical order.
 */
void printCommonWords() {
    Vector<string> allWords = readWordsFromBook();
    Map<string, int> wordCounts;
    countUniqueWords(allWords, wordCounts);
    for (string word : wordCounts) {
        if (wordCounts[word] >= FREQUENCY_THRESHOLD) {
            cout << word << " appeared " << wordCounts[word] << "times." << endl;
        }
    }
}

/*
 * Give us a word and we report how many times that word
 *  appeared in the book.
 * @param wordCounts associates words with the conut of that word's
 *  occurences in the file.
 * @param word is a word we want to query
 */
int getOccurencesCountFromWord(Map<String, int>& wordCounts, string word) {
    // we have to if statement to avoid overpopulating our map. Since each time we try to access wordCounts with a key that's not in the map, it will insert that key with the default value
    if (wordCounts.containsKey(word)) {
        return wordCounts[word];
    }
    return 0;
}
 
```

The Stanford library map will return keys to you in sorted order (if the type's comparison function is defined).

---

### Sets

Generally sets of numbers. It associates keys with membership (whether an element is in the set or not in the set).

---

### Lexicon

Basically just a set of strings, with special internal optimizations for that.

---

### Big-O: Performance Analysis

* A way of counting the number of steps to complete a task
  * Doesn't consider how big each step is
  * Doesn't consider how fast the computer's CPU or hardware components are
  * Doesn't involve any actual measurements of the time elapse for any real code
* Useful for making broad comparisons between different approaches and algorithms

---

---

## Monday, October 10

Today we're covering recursion and recursive analysis. 

---

### Factorials

$n! = n(n-1)(n-2)(n-3)\dots(3)(2)(1)$

This could be a really long expression if you wanted to type it all out. You can tackle it using recursion, which tackles large or complicated problems by taking one "bite" of the problem at a time.

You can represent factorials as a piecewise function
$$
\begin{equation*}
n!=
    \begin{cases}
        1 & \text{if } n=1\\
        n(n-1)! & \text{otherwise}
    \end{cases}
\end{equation*}
$$
To translate this function to code, we can use recursion

```cpp
int factorial(int n) {
    if (n == 1) {
        return 1;
    } else {
        return n * factorial(n-1);
    }
}
```

---

### The recursive function pattern

* Recursive functions always have two parts

1. **Base Case**
   * This problem is so tiny, it's hardly a problem. Just give the answer of that problem at the base case.
2. **Recursive Case**
   * This problem is still large. Let's bite off one piece and delegate the remaining work to recursion.
     * In factory, `n *` is the one piece, and the delegated work is `factorial(n-1)`.

---

### Recursion in memory

A computer's memory is like a giant vector/array. It starts counting at index 0.

* It is typically drawn vertically with index 0 at the bottom. A typical laptop's memory has billions of these indexed slots.

Memory is generally divided into three regions:

1. Text: the program's ow code (needs to be in memory so it can be run)
2. Heap: we'll learn about this later in around week 6
3. Stack: this is where local variables for each function are stored

Every time `main()` is called, a "stack frame" is opened in the memory. Main is at the top of the memory. Once main calls the recursive function, main is still in memory and my function goes right below main in the memory.

![image-20221012200212195](/Users/jack/Library/Application Support/typora-user-images/image-20221012200212195.png)

The factorial function will keep returning upwards and remove itself from the stack.

![image-20221012200407528](/Users/jack/Library/Application Support/typora-user-images/image-20221012200407528.png)

The "stack" part of memory is itself a stack

* Function **call** = **push** a stack frame
* Function **return** = **pop** a stack frame

In the diagram, the arrow pointing down is the top of the stack.

The top of the stack is at the highest memory address. As the stack grows, the stack grows down towards memory address zero.

```
Enter an integer > 0: 6
6 is stored at memory address: 0x8855bff840
5 is stored at memory address: 0x8855bff810
4 is stored at memory address: 0x8855bff7e0
3 is stored at memory address: 0x8855bff7b0
2 is stored at memory address: 0x8855bff780
1 is stored at memory address: 0x8855bff750
The answer is: 720
```

```
Enter an integer > 0: 8
8 is stored at memory address: 0x8855bff840
7 is stored at memory address: 0x8855bff810
6 is stored at memory address: 0x8855bff7e0
5 is stored at memory address: 0x8855bff7b0
4 is stored at memory address: 0x8855bff780
3 is stored at memory address: 0x8855bff750
2 is stored at memory address: 0x8855bff720
1 is stored at memory address: 0x8855bff6f0
The answer is: 40320
```

---

### Iterative

* Sometimes, iterative can be much faster because it doesn't have to push and pop stack frames.
  * Method calls generally have overhead in terms of space *and* time (to set up and tear down).

```cpp
int factorial(int n) {
    int f = 1;
    while (n > 1) {
        f = f * n;
        n--;
    }
    return f;
}
```

---

---

## Wednesday, October 12

Today we're covering more recursion and Big-O analysis.

---

### Binary Search

Suppose you have a collection of numbers in sorted order stored in a vector. You want to find a particular number.

**Basic approach**: start from the front and proceed forward until you find X (answer yes) or a number greater than X or the end of the list (answer no)

**Efficient approach**: jump to the middle of the vector to find

* X (answer yes)
* A number greater than X (you can rule out the entire second half of the vector)
* A number less than X (you can rule out the entire first half of the vector)

Then, you can proceed from that point forwards. This is like the basic approach but you take half the time.

**Extreme efficient approach**: just keep jumping to the middle of the remaining vector, and you can keep ruling out half of that remaining bit until you find X

---

### Fibonacci

```cpp
int fib(int n) {
    if (n == 0) {
        return 0;
    } else if (n == 1) {
        return 1;
    } else {
        return fib(n - 1) + fib(n - 2);
    }
}
```

If you think about it, a lot of work is duplicated while the recursion is called. There are 15 function calls for `fib(5)`.

| N    | fib(N) | # of calls to fib(2) |
| ---- | ------ | -------------------- |
| 2    | 1      | 1 calls              |
| 3    | 2      | 1 calls              |
| 4    | 3      | 2 calls              |
| 5    | 5      | 3 calls              |
| 6    | 8      | 5 calls              |
| 7    | 13     | 8 calls              |
| 8    | 21     | 13 calls             |
| 9    | 34     | 21 calls             |
| 10   | 55     | 34 calls             |

For each increase in N, the number of times we call `fib(2`) is 1.6 times the previous. To predict how much time it will take to compute fibonacci for arbitrary N, it would be $(1.6)^N$.

---

### Big-O Analysis

* We ignore constant coefficients in Big-O analysis.
* We care about huge datasets and inputs of N, since the performance doesn't matter too much for small N.

Big-O is a way of categorizing amount of work to be done in general terms, with focus on:

* **Rate of growth** as a function of the problem size N
* What that rate looks like **on the horizon** (i.e., for large N)

Therefore, $O(3n-3)$ is represented as $O(n)$. This means that it grows linearly.

If the rate is a polynomial, we just look at the largest degree for Big-O analysis.

---

**Big-O of binary search**

Since we keep jumping to the middle, of the vector, we're essentially diving the vector by two every time until there is nothing left.

The worse case is the number of times we can divide the length of the vector in half. This can be represented as $O(log_2N)$.

The best case for binary search is $O(1)$. This means that number we first visit is the number we want.

---

### Extrapolating Big-O

Support for the traveling salesman problem, we made a $O(2^n)$ algorithm. To calculate it for 50 state capitals, it took 4 days. To extend this problem and calculate it for 52 cities, it would take roughly 16 days using the following calculation: $\frac{2^{50}}{4} = \frac{2^{52}}{x}$. Where x is the number of days to calculate it for 52 cities.

---

---

## Friday, October 14

Today, we're covering more recursion, particularly binary search and generating sequences.

---

### Design tip: wrapper functions:

If you have a function that needs more book-keeping data than an outsider user would want to worry about, you can do this:

1. Write the function as you need for correctness, using any extra book-keeping parameters you like, in whatever way you like.
2. Make a second function that the outside world sees, using only the minimum number of parameters, and have it do nothing but call the recursive one.
   * This is called a "wrapper" function because it's like pretty outer packaging.

---

### Binary Search

We will write C++ code for binary search.

```cpp
// this is the wrapper function
bool binarySearch(Vector<int>& data, int key) {
    return binarySearch(data, key, 0, data.size() - 1);
}

// using the start and end, we can "cut down" out vector without copying it
bool binarySearch(Vector<int>& data, int key, int start, int end) {
    if (start > end) {
        return false;
    }
    int mid = (start + end) / 2;
    if (key == data[mid])  {
        return true;
    } else if (key < data[mid]) {
        return binarySearch(data, key, start, mid - 1);
    } else {
        return binarySearch(data, key, mid + 1, end);
    }
}
```

Remember that binary search needs to have a sorted array of numbers.

---

### Big-O Key Take-Aways

**NOT worth doing**

* Optimization of your code that just trims a bit. Just write clean and easy-to-read code, instead of slightly optimized but unclean code.

**MAY be worth doing**

* Optimization of your code that changes the algorithm's Big-O
  * If the performance of a particular function is important, focus on this
  * If the performance isn't important (e.g. it will only run on small inputs), focus on writing clean and easy-to-read code.

---

### Generating Sequences

* We want to write a program to fill a vector with strings representing possible sequences of coin flips (e.g. HHHTT, TTHHT, THTHT, etc.)

```cpp
void generateAllSequences(int length, Vector<string>& allSequences) {
    string sequence;
    generateAllSequences(length, allSequences, sequence);
}
void generateAllSequences(int length, Vector<string>& allSequences, string sequence) {
    // base case:
    //  this problem is so tiny, it's hardly a problem anymore
    //  -> this sequence is full-length and ready to add
    if (sequence.size() == length) {
        allSequences.add(sequence);
        return;
    }
    // recursive cases:
    //  This problem is still a bit large, lets
    
    // (1) bit off just one piece
    // -> add a single H or T to the sequence
    
    // and (2) delegate the remaining work to recursion
    // -> recursively generate more flips
    
    // either add heads
    sequence += "H";
    generateAllSequences(length, allSequences, sequence);
    
    // need to undo last step by removing last character
    sequence.erase(sequence.size() - 1);
    
    // or add tails
    sequence += "T";
    generateAllSequences(length, allSequences, sequence);
}
```

---

---

## Monday, October 17

Today, we're covering recursion for generating sequences and combinations.

---

### Mental models for Recursion

![image-20221017162533728](/Users/jack/Library/Application Support/typora-user-images/image-20221017162533728.png)

* When a function returns, that's how you move up the stack frame. 

![image-20221017163115070](/Users/jack/Library/Application Support/typora-user-images/image-20221017163115070.png)

Since the code from last lecture adds "H" before "T", we'll essentially be moving along the left of the tree first, then right. It's like post-order traversal except we only take the nodes where the length of sequence is exactly 4.

---

### Roll the Dice

Suppose you roll a single die 5 times. What are the possible $1/2/3/4/5/6$ sequences you could observe?

We want to write a program to fill a vector with strings representing each of the possible sequences. We can reuse the code from the coin flip for this. To adapt it to dice rolls, we change it from 2 options (H/T) to 6 options (1-6).

```cpp
void generateAllSequences(int length, Vector<string>& allSequences) {
    string sequence;
    generateAllSequences(length, allSequences, sequence);
}
void generateAllSequences(int length, Vector<string>& allSequences, string sequence) {
    // base case:
    //  this problem is so tiny, it's hardly a problem anymore
    //  -> this sequence is full-length and ready to add
    if (sequence.size() == length) {
        allSequences.add(sequence);
        return;
    }
    // recursive cases:
    //  This problem is still a bit large, lets
    
    // (1) bit off just one piece
    // -> add a number from 1 to 6 for the dice roll
    
    // and (2) delegate the remaining work to recursion
    // -> recursively generate more dice rolls
    
    for (int i = 1; i <= 6; i++) {
        // we add one of the numbers and run recursion
        sequence += integerToString(i);
        generateAllSequences(length, allSequences, sequence);
        // undo last step by removing last character
        sequence.erase(sequence.size() - 1);
    }
}
```

The code in the for loop can be simplified into just `generateAllSequences(length, allSequences, sequence + integerToString(i))`.

However, the way we do it is useful for recursive backtracking, where you will need to make an explicit choice, explore that choice, and undo it. This is called "choose-explore-unchoose."

* Note: The loop does not replace the recursion. It just controls how many times the recursion launches.

---

---

## Wednesday, October 19

Today we cover more recursion, focusing on generating sequences and recursive backtracking.

---

You can use loops to control how many times the recursion launches from a single function. 

---

### Combo Lock

If you forgot the combination to your locker, you have to try every possible combination of numbers.

* When we find the combo, we save the combo, and return true (true means we found the lock, false means we found no combination that works).
* To do so, we follow a few steps
  1. Write the function signature: `bool findCombo(Vector<int>& combo)`
  2. Base case: check when the combination is the correct length (4), check if that combo is the correct combination
  3. Recursive case: try all possible digits for the next entry of the combo and recurse (choose-unchoose)

```cpp
const int COMBO_LENGTH = 4;
const int COMBO_START = 1, COMBO_END = 9;

bool findCombo(Vector<int>& combo) {
    // base case: this sequence is full-length and ready to try on the lock
	if (combo.size() == COMBO_LENGTH) {
        return tryCombo(combo); // true if correct combo, false if incorrect (ends the recursion)
    }
    
    for (int i = COMBO_START; i<= COMBO_END; i++) {
        combo.add(i); // step 1. choose
        if (findCombo(combo)) { // step 2. explore
            return true; // if we find a working combo, we achieved our task. Exit early.
        }
        combo.remove(combo.size() - 1); // step 3. unchoose
    }
    return false; // return false here because there are no combinations starting with `combo` that work
}
```

The `Vector<int>& combo` parameter in the function signature will eventually report back the final combo solution. However, while running the recursion, it represents a tentative guess of the combo **so far**.

* If the function is called with `combo = {1, 9}`, it is saying "Please explore all the combinations with start with `1, 9` and tell me if there is a working combo with that beginning."
  * This call then delegates to recursion the task of finding combos starting with `{1, 9, 1}` . If it finds one, it returns true and ends, If not, it checks combos starting`{1, 9, 2}`, and so on until it finds a combo that works.

When we find a working combination, the recursive calls in the stack that are still there waiting will cascade and also return true.

---

### Backtracking Template

This is a general template for recursive backtracking problems. We use this when we hope to find one working possibility.

```
bool backtrackingRecursiveFunction(args) {
    > base case test for success:
    	return true
    > base case test for failure:
    	return false
    > loop over several options for "what to do next":
    	1. tentatively "choose" one option
    	2. if ("explore" with recursive call returns true):
    		return true
    	3. else That tentative idea didn't work so "un-choose" that option
    		- don't return false yet, let the loop explore all the other options first
    > none of the options we tried in the loop worked:
    	return false
}
```

---

---

## Friday, October 21

Today we're covering more recursive backtracking examples.

---

### Gift Card Spending Target

Suppose we got a gift card. However, we are only allowed to use the gift card in a single trip through the store, and any remaining balance is gone. We wish to spend as much of the gift card as possible, so that we do not have any unused balance.

Given:
\> `int giftCardAmt`: the amount of the gift card
\> `Vector<Item> itemsForSale`: a vector of prices of items for sale (each has a `name` and `price`)
		-> Assume only one of each item is in stock)

Task: Can you find a collection of items to buy that will sum to exactly the amount on the gift card?

Return:
\> `bool`: true if you can find such a collection, otherwise false

#### Example Test Cases

1. 4, {1, 2, 5} = false
2. 0, {1, 1, 1} = true
   * You can just not buy anything and you can buy exactly the amount on the gift card
3. 10, {} = false
   * You don't have any items to buy to use your gift card

#### Logic

Imagine lining up all the items for sale. Our task would be to make a binary yes/no decision for purchasing each item.

* The yes and no can come in any combination or order, we just have to find a combination that sums to our gift card amount

![image-20221031153438055](/Users/jack/Library/Application Support/typora-user-images/image-20221031153438055.png)

If the recursion comes back with the answer that no combination for this set and the remaining funds, we reconsider our Y on buying the banana.

Therefore, each step/decision has two options to "loop" over: Yes and No (for one item)

#### Code

If we only want to see if it is possible to use the full gift card, the code below suffices.

```cpp
// wrapper function
bool canUseFullGiftCard(int giftCardAmt, Vector<Item>& itemsForSale) {
    return canUseFullGiftCard(giftCardAmt, itemsForSale, 0);
}
// recursive helper function
bool canUseFullGiftCard(int giftCardAmt, Vector<Item>& itemsForSale, int index) {
    // base case success: card amount is spent down to 0 exactly
    if (giftCardAmt == 0) {
        return true;
    }
    // base case failure: we either overspent, or we need to spend more but no more items to consider
    if (giftCardAmt < 0 || index == itemsForSale.size()) {
        return false;
    }
    
    // recursive case: consider 1 next item (at `index`)
    Item item = itemsForSale[index];
    
    // our two choices are that we can either buy the item and go on to the next items
    // 		or not buy the item and go on to the next items
    // if neither option works, we return false
    return canUseFullGiftCard(giftCardAmt - item.price, itemsForSale, index + 1) ||
       canUseFullGiftCard(giftCardAmt, itemsForSale, itemsToBuy, index + 1);
}
```

If we wanted to know exactly what items to buy, we can use the code below.

```cpp
// wrapper function
bool canUseFullGiftCard(int giftCardAmt, Vector<Item>& itemsForSale, Vector<Item>& itemsToBuy) {
    return canUseFullGiftCard(giftCardAmt, itemsForSale, itemsToBuy, 0);
}
// recursive helper function
bool canUseFullGiftCard(int giftCardAmt, Vector<Item>& itemsForSale, Vector<Item>& itemsToBuy, int index) {
    // base case success: card amount is spent down to 0 exactly
    if (giftCardAmt == 0) {
        return true;
    }
    // base case failure: we either overspent, or we need to spend more but no more items to consider
    if (giftCardAmt < 0 || index == itemsForSale.size()) {
        return false;
    }
    
    // recursive case: consider 1 next item (at `index`)
    Item item = itemsForSale[index];
    
    // our two choices are that we can either buy the item and go on to the next items
    itemsToBuy.add(item);
    if (canUseFullGiftCard(giftCardAmt - item.price, itemsForSale, itemsToBuy, index + 1)) {
        return true;
    }
    
    // or not buy the item and go on to the next items
    itemsToBuy.remove(itemsToBuy.size() - 1);
    if (canUseFullGiftCard(giftCardAmt, itemsForSale, itemsToBuy, index + 1)) {
        return true;
    }
    
    // neither option worked, so we return false for this branch
    return false;
}
```

---

---

## Monday, October 24

Today we cover sorting algorithms. We also cover divide and conquer algorithms (e.g. Merge sort and Quicksort)

---

### Selection Sort

At any position, it finds the smallest/largest element in the remaining vector and swaps it.

```cpp
void selectionSort(Vector<int>& vec) {
    int n = vec.size();
    // already-fully-sorted section grows 1 at a time from left to right
    for (int lh = 0; lh < n; lh++) {
        int rh = lh;
        // find the min element in the entire unsorted section
        for (int i = lh + 1; i < n; i++) {
            // found new min?
            if (vec[i] < vec[rh]) rh = i;
        }
        // swap min into sorted section
        int tmp = vec[lh];
        vec[lh] = vec[rh];
        vec[rh] = tmp;
    }
}
```

The best-case and worse-cast costs of this algorithm are both $O(n^2)$. Even if the vector is fully sorted, it will still run through the entire vector to "search" for the next minimum. In that case however, the swap will just swap the element with itself.

---

### Bubble Sort

Bubble sort works continuously swapping elements with its adjacent one until it reaches a position where it can no longer be swapped in order. In other words, an element that is larger than an element to the right will keep swapping with the element to its direct right until the element on the right is bigger than itself. Then, it swaps that element and continues the process.

The best case of bubble sort is $O(n)$. The worst case of bubble sort is $O(n^2)$.

---

### Insertion Sort

Insertion sorts by moving each element to the left until it reaches a position where the next element is smaller than itself. It essentially shifts each element backwards to its correct position, building a sorted array as it goes.

```cpp
void insertionSort(Vector<int>& vec) {
    int n = vec.size();
    // already sorted section grows 1 at a time from left to right
    for (int i = 1; i < n; i++) {
        int j = i;
        while (j > 0 && vec[j - 1] > vec[j]) {
            // keep swapping this item with its left neighbor if it is
            // smaller than the left neighbor
            int tmp = vec[j - 1];
            vec[j - 1]; = vec[j];
            vec[j] = tmp;
            j--;
        }
    }
}
```

The best case of this algorithm is $O(n)$. The worst case is $O(n^2)$. For an already sorted array, the while-loop inside the for-loop will not run since the left neighbor is already less than itself.

---

### Mergesort

This is an example of the divide & conquer class of sorting algorithms.

#### Preliminary Step:

You have two piles, each of which is sorted (this is `binaryMerge()` from assignment 3)

* You take the overall sorted element (in either pile) and add that element to the combined-sorted pile.
* Repeat until the two starting piles are empty and the combined-sorted pile is complete.
* If one pile is empty, just move from non-empty pile into combined-sorted pile.

We only need to examine **two** elements to find the overall smallest element.

* Therefore, to merge two sorted sub-piles, A and B, we would need $O(|A| + |B|)$ steps, where $|A|$ is the number of elements in A.

#### Logic:

1. Imagine we have a large stack of exams, and we want to sort them alphabetically by name of the test-taker.
2. We break the stack of paper into two unsorted piles. 
3. We have one person sort the first pile, and another person sort the second pile. 
4. Then, we take those two piles and combine them using our combine algorithm from the preliminary step.
5. Our file pile is now sorted!

If we use this same logic but continue repeating steps 2 and 3, we can keep splitting the stack of paper into smaller unsorted piles and taking two more people to sort each of the stacks.

If we keep repeating this and splitting the pile into two, eventually we will have a pile that has zero or one exam in it. This is our base case, and we can just return that pile as it is already sorted.

#### Analysis:

A single exam will pass through the merge algorithm $O(log(n))$ times, since the number of times we can divide the stack of n papers by two before we can't divide anymore is $O(log(n))$.

Since there are $n$ papers to sort, the Big-O of merge-sort is always $O(nlog(n))$. The best-case and the worse-case are both equal.

---

### Quicksort

* We pick a middle element, called a "pivot" in the vector.
* Every element less than middle element goes to the left of the pivot, and every element greater than that middle element goes to the right.
* We now recursively sort each half.
  * We pick a middle element in the first group on the left and continue sorting.
  * We pick a middle element in the second group on the right and continue sorting.
* We continue recursively sorting each half until the group only has one person. That one person is already sorted. Base case.

---

---

## Wednesday, October 26

Today we're covering classes and object-orientated programming. We will practice making our own classes.

---

### Classes and Objects

**Class**: Allows us to add new types to the language. A template what the type holds and how it works (`vector.h`)

**Object**: One instance of a class type (`Vector<int> a`)

**Object-orientated programming (OOP)**: Programs that perform their behavior as interactions between objects.

**Abstraction**: Separation between concepts and details.

---

### Elements of a class

**Member variables**: *state* inside each object

* Also called instance variables or fields
* Each object has a copy of each member variable

**Member functions**: *behavior* each object can perform

* Also called methods
* The method can interact with the data inside that object

---

### Abstraction: Interface vs. Code

C++ separates classes into two kinds of code files

* .h: A "header" file containing the interface (declarations)
  * Essentially a collection of function prototypes for the class methods
* .cpp: A "source" file containing definitions (method bodies)
  * The actual function definitions.

The content of .h files is #included inside .cpp files

* Makes them aware of the blueprint plans for the class and its members

---

### C++ class definition

**Class Declaration (.h)**

```cpp
#ifndef _classname_h // provides protectoin in case multiple .cpp files
#define _classname_h // include this .h file, so that it won't get declared twice

class ClassName {
    public:
    	ClassName(parameters); // constructor
    
    	returnType name(parameters); // member functions
        returnType name(parameters);
        returnType name(parameters);
    
    private:
    	type _name; // member variables
    	type _name; // underscore is convention, put in front of member variables in class
}; // must put a semicolon at end of class declaration

#endif
```

**Class Example (v1)**

```cpp
// BankAccount.h
#ifndef _bankaccount_h
#define _bankaccount_h
class BankAccount {
    public:
        BankAccount(string n); // constructor
    	BankAccount(string n, double initialBalance);
    
        void deposit(double amount); // methods
        void withdraw(double amount);
        void setName(string name);
    private:
        string _name; // each BankAccount object
        double _balance; // has a name and balance
};
#endif
```

*Client code for bank account*

```cpp
BankAccount ba1("Cynthia");
ba1.deposit(2.00);

BankAccount ba2("Julie");
ba2.deposit(20.00);
```

*C++ file*

```cpp
#include "bankaccount."

BankAccount::BankAccount(string name) {
    _name = name;
    _balance = 0.00;
}

BankAccount::BankAccount(string name, double initialBalance) {
    _name = name;
    if (initialBalance < 0) {
        error("Initial balance can't be negative.");
    }
    _balance = initialBalance;
}

void BankAccount::deposit(double money) {
    if (money >= 0) {
        _balance += money;
    } else {
        error("Cant' deposit negative money.");
    }
}

void BankAccount::withdraw(double money) {
    if (_balance >= money) {
        _balance -= money;
    } else {
        error("Can't withdraw more than balance.");
    }
}

double BankAccount::getBalance() {
    return _balance;
}
```

---

### Constructors

Initializes state of new objects as they are created.

* No return type is specified; they implicitly return the new object

### Private Data

Data is private and not accessible by the client. We can provide methods to get and/or set a data field's value.

* Methods that change a data field's value is "mutators"
* Methods that only view the data field's value is "accessors"

---

---

## Friday, October 28

Today, we'll implement a Stack ADT with unlimited capacity, as well as dynamic memory allocation.

---

### Implementing a classic ADT :Stack

* For simplicity, it will only hold integers
* The stack will use an array to store its elements
* The capacity will grow as needed
* Basic stack operations: *push, pop, peek*

### Inside a stack

* Inside a stack is an **array** storing the elements you have added.
  * The array is typically larger than the data added so far, so it has extra slots to put new elements in.

![image-20221107102203349](/Users/jack/Library/Application Support/typora-user-images/image-20221107102203349.png)

* The top of the stack is the end with 17, at index 2. The stack will add to the end, and pop from the end. LIFO.
  * You can have the top at either index 0 or two. However, it is more efficient to put it at index 2 because we don't have to shift all the elements of the array.

### Class details

* It will have member variables `size` and `capacity`. It will store the variables in a C/C++ array.
  * Size is how many items are in the stack right now, capacity is the total amount of room to grow in the array.

---

### Arrays in C/C++

`type name[length];`

* Basic array (AKA statically allocated or stack allocated)
* Stored in the stack frame alongside other local variables

* Has enough space for multiple values of a type. It's similar to a vector but it's much more basic.
  * Arrays can't be resized and have no methods.

```cpp
int homeworkGrades[7];
homeworkGrades[0] = 90;
homeworkGrades[3] = 95;
// arrays are really just several adjacent spaces of the same type
// [7] allocates 7 spaces in the stack frame to store 7 ints. The whole block is referred by the array.
```

* **Note**: spaces in memory are not 'empty', they're filled with a garbage value

![image-20221107103444583](/Users/jack/Library/Application Support/typora-user-images/image-20221107103444583.png)

* When myFunction returns, the whole stack frame is removed and the space is reclaimed. The whole stack is available for use again.

---

### A second kind of array in C/C++

`type* name = new type[length]`

* Dynamically allocated array (AKA heap allocated)
* The variables that refers to the array is called a pointer, and it is on the stack. However, the actual array is stored in the heap.

```cpp
int* homeworkGrades = new int[7];
homeworkGrades[0] = 90;
homeworkGrades[3] = 95;
```

* The pointer to the array is stored in the stack. The array itself is stored in the heap.

![image-20221107104035657](/Users/jack/Library/Application Support/typora-user-images/image-20221107104035657.png)

* When myFunction returns, the whole stack frame is popped off and the space is reclaimed. The whole stack is available for use again. **However, the array in the heap is still there.** The pointer is gone, so we won't be able to use the array, but the array is still stored there in the heap.

  <img src="/Users/jack/Library/Application Support/typora-user-images/image-20221107104109453.png" alt="image-20221107104109453" style="zoom:50%;" />

---

### Array Stack implementation

Header file

```cpp
class ArrayStack {
public:
    /* Constructs a new empty stack. */
    ArrayStack();

    /* Destructor; called when stack is thrown out. */
    ~ArrayStack();

    /* Adds the given value to the top of the stack. */
    void push(int value);

    /* Removes and returns the element on top of the stack.
     * Throws a string exception if stack is empty.
     */
    int pop();

    /* Returns the element on top of the stack without removing it.
     * Throws a string exception if stack is empty.
     */
    int peek();

    /* Returns true if the stack does not contain any elements. */
    bool isEmpty();

    /* Prints the contents of a stack to an output stream such as cout. */
    friend ostream& operator <<(ostream& out, ArrayStack& stack);

private:
    int* _elements;   // array of elements
    int _size;        // number of elements on stack
    int _capacity;    // array length

    /* Makes the stack's internal array twice as large. */
    void enlargeArray();
};

#endif
```

C++ file

```cpp
/*
 * arraystack.cpp
 *
 * This file implements the members of the ArrayStack class.
 * See ArrayStack.h for declarations and documentation.
 */

#include "arraystack.h"
#include "error.h"

static const int INITIAL_CAPACITY = 10;

ArrayStack::ArrayStack()
{
    // initialize all members including our array
    _size = 0;
    _capacity = INITIAL_CAPACITY;
    _elements = new int[_capacity];
}

ArrayStack::~ArrayStack() {
    // free up the memory used by our array
    delete [] _elements;
}

void ArrayStack::push(int value)
{
    if (_size == _capacity) {
        // resize to an array twice as large
        enlargeArray();
    }

    // convention: index 0 = bottom of stack;  index (size-1) = top.
    // add to end and increase size by 1
    _elements[_size] = value; // add to place after top
    _size++; // size-1 now reflects top element of stack again
}

int ArrayStack::pop()
{
    // grab last element and decrease size by 1
    int top = peek(); // don't need to check error bc this will error if empty
    
    // _elements[_size - 1] = 0;   // don't need this really, we change size 
    							   // so the element here is no longer relevant
    _size--;
    return top;
}

int ArrayStack::peek()
{
    if (isEmpty()) {
        error("Cannot access empty stack!");
    }
    return _elements[_size - 1];
}

bool ArrayStack::isEmpty()
{
    return _size == 0;
}

void ArrayStack::enlargeArray()
{
    int* bigger = new int[2 * _capacity]();
    for (int i = 0; i < _size; i++) {
        bigger[i] = _elements[i];
    }
    delete [] _elements;
    _elements = bigger;
    _capacity = _capacity * 2;
}

ostream& operator <<(ostream& out, ArrayStack& stack)
{
    // << operator code is able to view the private data (size and elements)
    // because it is declared as a 'friend' of the class
    out << "{";
    for (int i = 0; i < stack._size; i++) {
        out << stack._elements[i] << " ";
    }
    out << "}";
    return out;
}

```

---

---

## Monday, October 31

Today we're covering midterm review.

---

### Logistics

The exam is two hours. You have to write your SUID (the number) on every page.

You should plan for 20 minutes per problem, which leaves 20 minutes at the end to check your work. 

### Topics

1. C++ Fundamentals
2. ADTs
3. Big-O
4. Recursion
5. Recursive backtracking

Pay close attention to the problem. Some problems have limits on whether ADTs are allowed or not.

---

---

## Wednesday, November 2

Today we're covering memory and pointers.

---

### Memory

![image-20221107144839909](/Users/jack/Library/Application Support/typora-user-images/image-20221107144839909.png)

* Memory in the heap is not automatically released.
* **Memory Leaks**: the pointer variable that points to heap allocated memory is lost, and the heap memory is never accessible again
  * Imagine the pointer as the string to a balloon. If you let go of the string, the balloon still exists but you can never get it again.

---

### Dynamic Memory Allocation

**New and Delete**

* Think of `new` as making a hotel room reservation
* `new int[5]`
  * "5 connecting rooms, each big enough for 1 int value"
* Think of `delete` as checking out of the hotel room.
  * `delete [] arr`
  * "My trip is done. Stop charging me for these rooms and you can give them to other guests."

In hotels, you can't check out of the room and go back into it. This is the same in C++.

```cpp
int* arr = new int[5];
arr[0] = 10;
delete [] arr;
arr[1] = 11;
```

* Another value might be using the memory space. **After you call delete, don't use that memory again**.
* C/C++ is a unsafe memory language: you can still access the array through the pointer even after it is deleted.
  * The delete only designates the space in the heap as "available" to other things

---

### Classes

For all classes that use arrays to store values, be sure to delete the arrays using the "destructor" of the class.

```cpp
ArrayStack::~ArrayStack() {
    // free up the memory used by our array
    delete [] _elements;
}
```

* In the above, we delete the array used to store the stack.
* The destructor is called once the ArrayStack goes out of scope.

When we enlarge arrays for dynamic memory allocation we also have to remove the previous existing array after everything has been copied over.

```cpp
void ArrayStack::enlargeArray()
{
    // copy our data into a new larger array
    int* bigger = new int[2 * _capacity]();
    for (int i = 0; i < _size; i++) {
        // first half of bigger will be populated
        // second half will be room to grow
        bigger[i] = _elements[i];
    }

    // free memory used by the old smaller array
    delete [] _elements;

    // instruct the stack to use the new larger array in the future
    _elements = bigger;
    _capacity = _capacity * 2;
}
```

---

### Uninitialized Memory

When initializing array, writing it as `new int[5]()` guarantees that all elements in the array are assigned to zero.

* Writing it as `new int[5]` makes it so all elements are indeterminant (they can be a random garbage value, or the previous value that was there before)

```cpp
type* name = new type[length];   // uninitialized
type* name = new type[length](); // initialized with zeros
```

---

### Memory Addresses

When you declare a variable, you allocate a bucket (or more) of memory for the value of that variable.

Each bucket has a unique address.

You can ask for any variable's address using the & operator.

```cpp
bool kitkat = true;
int candies = 10;

cout << &candies << endl; // prints out candies memory addr
cout << &kitkat << endl;  // prints out kitkat memory addr
```

You can create pointer variables to store the pointer of each.

```cpp
int* ptrC = &candies;
bool* ptrB = &kitkat;
```

This explains the use of `int* heapArr = new int[3]`, since `new int[3]` returns the memory address of the array in the heap, and you store that in the heapArr pointer variable.

* Memory address are typically written in hexadecimal (base 16)

"Pointer" isn't one type in C++, it depends on what it points to.

* You declare a pointer using * and the type pointed to:
  * `int* p`
  * `bool*`
  * `string*`
  * `double*`
  * `Queue<GridLocation>*`
    * This will be spread across many addresses. The address given is the smallest one of the consecutive memory addresses that the Queue takes up.
    * You can store the entire Queue object in heap memory using the `new` keyword.
  * `int**`
    * The memory address where the int-pointer variable is stored.

---

### Dynamically-allocated Object

```cpp
Queue<GridLocation>* path = new Queue<GridLocation>(); // heap queue
...(enqueue a few things)...
path->enqueue(loc);    // instead of path.enqueue(loc);
delete path;           // dont use [] here
```

---

---

## Friday, November 4

Today we're covering the priority queue ADT

---

### Priority Queue

* Emergency rooms operate with a priority queue. The order of attention given to patients is based on severity, not in the order of arrival.
* Priority queues are queues that are sorted based on priority, not arrival.
* Individual elements of our priority queue has two pieces to them:
  * An integer/double indicating the priority of the element
    * We will use a smaller number meaning a higher priority (could be done either way)
  * A "payload" of whatever the actual element data is
    * E.g. a class MedicalRecords of patient information, a string containing a name, etc

---

### Implementing priority queues (version 1: unsorted array)

* We can implement it using an unsorted array.
* We always **insert** new elements at the end of the array. **O(1)**
* We **remove** by searching the entire array for highest-priority item, then removing it, and (if needed) shifting elements over to fill the gap. **O(N)**

![image-20221107152819341](/Users/jack/Library/Application Support/typora-user-images/image-20221107152819341.png)

This implementation has a very quick add but a slow remove/peek.

---

### Implementing priority queues (version 2: sorted array)

* We can implement it using a sorted array.
* We always **insert** new elements where they go in priority-sorted order, with the highest-priority item at the end of the array. **O(N)**
  * We have to shift elements to make space for insertion.
* We **remove** by taking the last element of the array. **O(1)**

![image-20221107153011063](/Users/jack/Library/Application Support/typora-user-images/image-20221107153011063.png)

This implementation has a very quick remove/peek but a slow add.

---

### Implementing priority queues (version 3: binary heap)

* Instead of storing our priority queue nodes entirely sorted or entirely unsorted, we will store them partially sorted.
* The partial sorting will be stored in an array, but it's best to image it as a tree.

<img src="/Users/jack/Library/Application Support/typora-user-images/image-20221107153351992.png" alt="image-20221107153351992" style="zoom:50%;" />

Looking at the tree, SooMin is clearly the highest priority person.

---

### Binary trees

* A tree data structure in which each node has at most two child nodes, usually distinguished as left and right.

### Binary heaps

* A specific kind of binary tree, with a few special restrictions
  * Must be **complete**: no gaps, nodes are filled in left-to-right on each level of the tree
  * The ordering of data must obey **heap property**
    * **Min-heap**: a parent's priority is less than or equal to both its children's priority
    * **Max-heap**: a parent's priority is greater than or equal to both its children's priority

---

### Binary heap in an array

* Because of the special constraint that they must be complete, binary heaps fit nicely into an array.
  * This is not true of some other tree data structures, and we'll use a different approach for those.

<img src="/Users/jack/Library/Application Support/typora-user-images/image-20221107154345721.png" alt="image-20221107154345721" style="zoom:50%;" />

* Stored in level-order traversal.
* When stored in an array, the parent of the node found in array index `i` is found at array index `(i - 1) / 2`. 
  * Be careful not to go past the top of the array. Don't find the parent of root.
* When stored in array, the right child of the parent node at array index `i` is found at array index `(i + 1) * 2 = 2i + 2`. The left child will be at `2i + 1`.
  * Be careful not to go past the bottom of the array. Don't find the children of a leaf.

<img src="/Users/jack/Library/Application Support/typora-user-images/image-20221107154837973.png" alt="image-20221107154837973" style="zoom:50%;" />

---

### Binary heap enqueue ("bubble up")

When we enqueue, we first insert element into next position (last position in the array).

<img src="/Users/jack/Library/Application Support/typora-user-images/image-20221107154950271.png" alt="image-20221107154950271" style="zoom:50%;" />

* The number 6 was added to index 8. 
* The index of 8 is `(8-1)/2 = 3`. We compare the parent (18) to the child (6) to confirm the heap status. Since 18 > 6, we swap the two elements.

![image-20221107155200349](/Users/jack/Library/Application Support/typora-user-images/image-20221107155200349.png)

* Again, we compare the number 6 to the parent element. 6 is currently at index 3. The parent is at index 1. Since 7 > 6, we swap it again.

![image-20221107155654214](/Users/jack/Library/Application Support/typora-user-images/image-20221107155654214.png)

* At this point, we check it again. The whole tree is in heap status, so we've accomplished our purpose. No need to swap any more.

---

### Binary heap dequeue ("trickle down")

To dequeue from a binary heap, you first delete the minimum value (the root). Then, you put the last element into the root. Then, you bubble/trickle down the element at the root.

| Original binary heap                                         | Delete min                                                   | Put last in root                                             |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| ![image-20221107155951382](/Users/jack/Library/Application Support/typora-user-images/image-20221107155951382.png) | ![image-20221107160003065](/Users/jack/Library/Application Support/typora-user-images/image-20221107160003065.png) | ![image-20221107160041024](/Users/jack/Library/Application Support/typora-user-images/image-20221107160041024.png) |

![image-20221107160132253](/Users/jack/Library/Application Support/typora-user-images/image-20221107160132253.png)

* This is the original binary heap. We wish to dequeue and remove the minimum. This would remove 5, and put 18 into the spot of the root as it's the last element.

![image-20221107160207843](/Users/jack/Library/Application Support/typora-user-images/image-20221107160207843.png)

* We now start the trickle down process. We pick the minimum of the two children of 18. In this case it is 6. We swap 6 and 18.

![image-20221107160235685](/Users/jack/Library/Application Support/typora-user-images/image-20221107160235685.png)

* We do the comparisons again. We pick the minimum children of 18 again. In this case, it is 7. We swap 7 and 18.

![image-20221107160307025](/Users/jack/Library/Application Support/typora-user-images/image-20221107160307025.png)

* At this point, we've reached heap status. No need to swap anymore.

---

### Performance of the different implementations

![image-20221107160349351](/Users/jack/Library/Application Support/typora-user-images/image-20221107160349351.png)

* O(logN) is much closer to O(1) than O(N). We've achieved our goal of quick add and remove.

**Note**: the heap section of memory has nothing to do with the heap structure.

---

---

## Recursive Backtracking Review

### Choose-explore-unchoose

* **Choose**: make a choice about current path to try. Often trying out all possibilities of some subset of our current problem.
* **Explore**: recurse in the direction of your choice. Change parameters to reflect choice.
* **Unchoose**: the "backtrack". After trying all the possible options on our current choice, decide if we get to break early. Otherwise reset and choose another path.

### Pruning

* Ending a recursive call early when you've determined the solution can't be in this direction.

### When to do backtracking?

* Anything tod o with permutations, possibilities, combinations, or subsets
* Anything to do with optimization/finding the "best" result
* Anything to do with searching (e.g. DFS)

## Problem: Pattern Matching

### Regular Expression

* Encode strings into patterns using set of rules
* Pattern strings can contain letters, plus the special character star, dot, and question mark
  * a* : a followed by anything (e.g. at, attack, allow, apple)
  * ..a : two letters then letter a (e.g. tea, baa, cha, bra, aha, boa)
  * a?a : want an a, then optionally another character, then another a (e.g. aa, aaa, ala, aha, aba)
  * tr*t? : tr followed by anything, then a t, and optionally another character (e.g. treats, trot, trots trut, trout)

### Function

`bool matches(string text, string pattern);`

Inputs:

* text - input string
* pattern - the pattern to be matched

Returns:

* bool if it matches the pattern

```
treat 	tr*t?
 reat    r*t?
  eat     *t?
    
now decide how many characters star accounts for

1. eat	 t? -> take nothing, use up star
2. at	 t? -> take e, use up star
3. at	*t? -> take e, don't use up star

suppose we pick option 3

   at	*t?
    t   t?
        ?

now do we use question mark? empty string so we don't

thus, treat matches tr*t?
```



#### Notes

* What are we doing at every step
* What decisions do we make when we see a `*`
* What decisions do we make when we see a `.`
* What decisions do we make when we see a `?`
* Will we need a wrapper function
* How do we know if the string matches a pattern? How do we know if it doesn't?

#### Pseudocode

**Base Case**

* We've looked through all of text, pattern, or both.
  * Return false when text remaining but pattern empty

**Recursive Case**

* Letter: check if letter matches letter in pattern. Consume char in text and pattern
* Dot: consume char in text and dot pattern, doesn't matter what char is
* Question Mark: two options
  * consume char in text and question mark in pattern
  * just consume question mark in pattern
* Star: three options
  * consume char in text and star in pattern
  * consume char in text and keep star
  * consume star in pattern and keep char

## Approach to recursive backtracking

1. Examples
2. Recursive intuition
   1. Decide we're using recursion
   2. Figure out recursive case
   3. Figure out base case
3. Rough pseudocode
4. Code

## Print Sums Of

Write function that finds ways of writing n as a sum of nonzero natural numbers

`void printSumsOf(n);`

Examples:

1. `1`: 1
2. `2`: 2, 1+1
3. `3`: 3, 1+2, 2+1, 1+1+1

We can build a solution using solution of previous cases (e.g. build solution for 3 using solution for 2 and 1)

The solution for n is a combination of

* For all i from 1 to n-1,
  * The equations we find for n=i, plus "+ [n-i]"
* And "n" itself

E.g. for 3, it's the solutions for 1 with "+2" and the solutions for 2 with "+1"

The base case is when n=0, because we've already produced a result that sums to n

## Divide

Divide letters from word w into two words s1 and s2. Each letter from w must be used exactly once, and the relative order of the letters must be preserved, meaning s1 and s2 much both be subsequences of w.

e.g. the word "friendly" can split into s1 = "find" and s2 = "rely"

* f comes before i comes before n comes before d, etc

```cpp
void divide(Lexicon& lex, string input) {
    divideHelper(lex, input, "", "");
}

// doesn't necessarily have to be boolean
bool divideHelper(Lexicon& lex, string input, string left, string right) {
    // Base cases
    if (input.empty()) {
        if (lex.contains(left) && lex.contains(right)) { // success base case
            cout << left << " " << right << endl;
            return true;
        } else { // failure base case
        	return false;
        }
    } else if (!lex.containsPrefix(left) || !lex.containsPrefix(right)) { // pruning
        return false;
    } else { // recursive case  
        char c = input[0];
        input = input.substr(1);
        return ( divideHelper(lex, input, left + c, right) ||		// case 1: append to left
                divideHelper(lex, input, left, right + c) );			// case 2: append to right

    }
}
```

